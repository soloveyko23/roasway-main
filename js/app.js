(() => {
    var __webpack_modules__ = {
        934: module => {
            !function(e, t) {
                true ? module.exports = t() : 0;
            }(window, (function() {
                return function(e) {
                    var t = {};
                    function n(a) {
                        if (t[a]) return t[a].exports;
                        var r = t[a] = {
                            i: a,
                            l: !1,
                            exports: {}
                        };
                        return e[a].call(r.exports, r, r.exports, n), r.l = !0, r.exports;
                    }
                    return n.m = e, n.c = t, n.d = function(e, t, a) {
                        n.o(e, t) || Object.defineProperty(e, t, {
                            enumerable: !0,
                            get: a
                        });
                    }, n.r = function(e) {
                        "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e, Symbol.toStringTag, {
                            value: "Module"
                        }), Object.defineProperty(e, "__esModule", {
                            value: !0
                        });
                    }, n.t = function(e, t) {
                        if (1 & t && (e = n(e)), 8 & t) return e;
                        if (4 & t && "object" == typeof e && e && e.__esModule) return e;
                        var a = Object.create(null);
                        if (n.r(a), Object.defineProperty(a, "default", {
                            enumerable: !0,
                            value: e
                        }), 2 & t && "string" != typeof e) for (var r in e) n.d(a, r, function(t) {
                            return e[t];
                        }.bind(null, r));
                        return a;
                    }, n.n = function(e) {
                        var t = e && e.__esModule ? function() {
                            return e.default;
                        } : function() {
                            return e;
                        };
                        return n.d(t, "a", t), t;
                    }, n.o = function(e, t) {
                        return Object.prototype.hasOwnProperty.call(e, t);
                    }, n.p = "", n(n.s = 0);
                }([ function(e, t, n) {
                    "use strict";
                    n.r(t);
                    var a = [], r = [ "Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat" ], i = [ "January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December" ], o = {
                        t: "top",
                        r: "right",
                        b: "bottom",
                        l: "left",
                        c: "centered"
                    };
                    function s() {}
                    var l = [ "click", "focusin", "keydown", "input" ];
                    function d(e) {
                        l.forEach((function(t) {
                            e.addEventListener(t, e === document ? L : Y);
                        }));
                    }
                    function c(e) {
                        return Array.isArray(e) ? e.map(c) : "[object Object]" === x(e) ? Object.keys(e).reduce((function(t, n) {
                            return t[n] = c(e[n]), t;
                        }), {}) : e;
                    }
                    function u(e, t) {
                        var n = e.calendar.querySelector(".qs-overlay"), a = n && !n.classList.contains("qs-hidden");
                        t = t || new Date(e.currentYear, e.currentMonth), e.calendar.innerHTML = [ h(t, e, a), f(t, e, a), v(e, a) ].join(""), 
                        a && window.requestAnimationFrame((function() {
                            M(!0, e);
                        }));
                    }
                    function h(e, t, n) {
                        return [ '<div class="qs-controls' + (n ? " qs-blur" : "") + '">', '<div class="qs-arrow qs-left"></div>', '<div class="qs-month-year' + (t.disableYearOverlay ? " qs-disabled-year-overlay" : "") + '">', '<span class="qs-month">' + t.months[e.getMonth()] + "</span>", '<span class="qs-year">' + e.getFullYear() + "</span>", "</div>", '<div class="qs-arrow qs-right"></div>', "</div>" ].join("");
                    }
                    function f(e, t, n) {
                        var a = t.currentMonth, r = t.currentYear, i = t.dateSelected, o = t.maxDate, s = t.minDate, l = t.showAllDates, d = t.days, c = t.disabledDates, u = t.startDay, h = t.weekendIndices, f = t.events, v = t.getRange ? t.getRange() : {}, m = +v.start, y = +v.end, p = g(new Date(e).setDate(1)), w = p.getDay() - u, D = w < 0 ? 7 : 0;
                        p.setMonth(p.getMonth() + 1), p.setDate(0);
                        var b = p.getDate(), q = [], S = D + 7 * ((w + b) / 7 | 0);
                        S += (w + b) % 7 ? 7 : 0;
                        for (var M = 1; M <= S; M++) {
                            var E = (M - 1) % 7, x = d[E], C = M - (w >= 0 ? w : 7 + w), L = new Date(r, a, C), Y = f[+L], j = C < 1 || C > b, O = j ? C < 1 ? -1 : 1 : 0, P = j && !l, k = P ? "" : L.getDate(), N = +L == +i, _ = E === h[0] || E === h[1], I = m !== y, A = "qs-square " + x;
                            Y && !P && (A += " qs-event"), j && (A += " qs-outside-current-month"), !l && j || (A += " qs-num"), 
                            N && (A += " qs-active"), (c[+L] || t.disabler(L) || _ && t.noWeekends || s && +L < +s || o && +L > +o) && !P && (A += " qs-disabled"), 
                            +g(new Date) == +L && (A += " qs-current"), +L === m && y && I && (A += " qs-range-start"), 
                            +L > m && +L < y && (A += " qs-range-middle"), +L === y && m && I && (A += " qs-range-end"), 
                            P && (A += " qs-empty", k = ""), q.push('<div class="' + A + '" data-direction="' + O + '">' + k + "</div>");
                        }
                        var R = d.map((function(e) {
                            return '<div class="qs-square qs-day">' + e + "</div>";
                        })).concat(q);
                        return R.unshift('<div class="qs-squares' + (n ? " qs-blur" : "") + '">'), R.push("</div>"), 
                        R.join("");
                    }
                    function v(e, t) {
                        var n = e.overlayPlaceholder, a = e.overlayButton;
                        return [ '<div class="qs-overlay' + (t ? "" : " qs-hidden") + '">', "<div>", '<input class="qs-overlay-year" placeholder="' + n + '" inputmode="numeric" />', '<div class="qs-close">&#10005;</div>', "</div>", '<div class="qs-overlay-month-container">' + e.overlayMonths.map((function(e, t) {
                            return '<div class="qs-overlay-month" data-month-num="' + t + '">' + e + "</div>";
                        })).join("") + "</div>", '<div class="qs-submit qs-disabled">' + a + "</div>", "</div>" ].join("");
                    }
                    function m(e, t, n) {
                        var a = t.el, r = t.calendar.querySelector(".qs-active"), i = e.textContent, o = t.sibling;
                        (a.disabled || a.readOnly) && t.respectDisabledReadOnly || (t.dateSelected = n ? void 0 : new Date(t.currentYear, t.currentMonth, i), 
                        r && r.classList.remove("qs-active"), n || e.classList.add("qs-active"), p(a, t, n), 
                        n || q(t), o && (y({
                            instance: t,
                            deselect: n
                        }), t.first && !o.dateSelected && (o.currentYear = t.currentYear, o.currentMonth = t.currentMonth, 
                        o.currentMonthName = t.currentMonthName), u(t), u(o)), t.onSelect(t, n ? void 0 : new Date(t.dateSelected)));
                    }
                    function y(e) {
                        var t = e.instance.first ? e.instance : e.instance.sibling, n = t.sibling;
                        t === e.instance ? e.deselect ? (t.minDate = t.originalMinDate, n.minDate = n.originalMinDate) : n.minDate = t.dateSelected : e.deselect ? (n.maxDate = n.originalMaxDate, 
                        t.maxDate = t.originalMaxDate) : t.maxDate = n.dateSelected;
                    }
                    function p(e, t, n) {
                        if (!t.nonInput) return n ? e.value = "" : t.formatter !== s ? t.formatter(e, t.dateSelected, t) : void (e.value = t.dateSelected.toDateString());
                    }
                    function w(e, t, n, a) {
                        n || a ? (n && (t.currentYear = +n), a && (t.currentMonth = +a)) : (t.currentMonth += e.contains("qs-right") ? 1 : -1, 
                        12 === t.currentMonth ? (t.currentMonth = 0, t.currentYear++) : -1 === t.currentMonth && (t.currentMonth = 11, 
                        t.currentYear--)), t.currentMonthName = t.months[t.currentMonth], u(t), t.onMonthChange(t);
                    }
                    function D(e) {
                        if (!e.noPosition) {
                            var t = e.position.top, n = e.position.right;
                            if (e.position.centered) return e.calendarContainer.classList.add("qs-centered");
                            var a = e.positionedEl.getBoundingClientRect(), r = e.el.getBoundingClientRect(), i = e.calendarContainer.getBoundingClientRect(), o = r.top - a.top + (t ? -1 * i.height : r.height) + "px", s = r.left - a.left + (n ? r.width - i.width : 0) + "px";
                            e.calendarContainer.style.setProperty("top", o), e.calendarContainer.style.setProperty("left", s);
                        }
                    }
                    function b(e) {
                        return "[object Date]" === x(e) && "Invalid Date" !== e.toString();
                    }
                    function g(e) {
                        if (b(e) || "number" == typeof e && !isNaN(e)) {
                            var t = new Date(+e);
                            return new Date(t.getFullYear(), t.getMonth(), t.getDate());
                        }
                    }
                    function q(e) {
                        e.disabled || !e.calendarContainer.classList.contains("qs-hidden") && !e.alwaysShow && ("overlay" !== e.defaultView && M(!0, e), 
                        e.calendarContainer.classList.add("qs-hidden"), e.onHide(e));
                    }
                    function S(e) {
                        e.disabled || (e.calendarContainer.classList.remove("qs-hidden"), "overlay" === e.defaultView && M(!1, e), 
                        D(e), e.onShow(e));
                    }
                    function M(e, t) {
                        var n = t.calendar, a = n.querySelector(".qs-overlay"), r = a.querySelector(".qs-overlay-year"), i = n.querySelector(".qs-controls"), o = n.querySelector(".qs-squares");
                        e ? (a.classList.add("qs-hidden"), i.classList.remove("qs-blur"), o.classList.remove("qs-blur"), 
                        r.value = "") : (a.classList.remove("qs-hidden"), i.classList.add("qs-blur"), o.classList.add("qs-blur"), 
                        r.focus());
                    }
                    function E(e, t, n, a) {
                        var r = isNaN(+(new Date).setFullYear(t.value || void 0)), i = r ? null : t.value;
                        if (13 === e.which || 13 === e.keyCode || "click" === e.type) a ? w(null, n, i, a) : r || t.classList.contains("qs-disabled") || w(null, n, i); else if (n.calendar.contains(t)) n.calendar.querySelector(".qs-submit").classList[r ? "add" : "remove"]("qs-disabled");
                    }
                    function x(e) {
                        return {}.toString.call(e);
                    }
                    function C(e) {
                        a.forEach((function(t) {
                            t !== e && q(t);
                        }));
                    }
                    function L(e) {
                        if (!e.__qs_shadow_dom) {
                            var t = e.which || e.keyCode, n = e.type, r = e.target, o = r.classList, s = a.filter((function(e) {
                                return e.calendar.contains(r) || e.el === r;
                            }))[0], l = s && s.calendar.contains(r);
                            if (!(s && s.isMobile && s.disableMobile)) if ("click" === n) {
                                if (!s) return a.forEach(q);
                                if (s.disabled) return;
                                var d = s.calendar, c = s.calendarContainer, h = s.disableYearOverlay, f = s.nonInput, v = d.querySelector(".qs-overlay-year"), y = !!d.querySelector(".qs-hidden"), p = d.querySelector(".qs-month-year").contains(r), D = r.dataset.monthNum;
                                if (s.noPosition && !l) (c.classList.contains("qs-hidden") ? S : q)(s); else if (o.contains("qs-arrow")) w(o, s); else if (p || o.contains("qs-close")) h || M(!y, s); else if (D) E(e, v, s, D); else {
                                    if (o.contains("qs-disabled")) return;
                                    if (o.contains("qs-num")) {
                                        var b = r.textContent, g = +r.dataset.direction, x = new Date(s.currentYear, s.currentMonth + g, b);
                                        if (g) {
                                            s.currentYear = x.getFullYear(), s.currentMonth = x.getMonth(), s.currentMonthName = i[s.currentMonth], 
                                            u(s);
                                            for (var L, Y = s.calendar.querySelectorAll('[data-direction="0"]'), j = 0; !L; ) {
                                                var O = Y[j];
                                                O.textContent === b && (L = O), j++;
                                            }
                                            r = L;
                                        }
                                        return void (+x == +s.dateSelected ? m(r, s, !0) : r.classList.contains("qs-disabled") || m(r, s));
                                    }
                                    o.contains("qs-submit") ? E(e, v, s) : f && r === s.el && (S(s), C(s));
                                }
                            } else if ("focusin" === n && s) S(s), C(s); else if ("keydown" === n && 9 === t && s) q(s); else if ("keydown" === n && s && !s.disabled) {
                                var P = !s.calendar.querySelector(".qs-overlay").classList.contains("qs-hidden");
                                13 === t && P && l ? E(e, r, s) : 27 === t && P && l && M(!0, s);
                            } else if ("input" === n) {
                                if (!s || !s.calendar.contains(r)) return;
                                var k = s.calendar.querySelector(".qs-submit"), N = r.value.split("").reduce((function(e, t) {
                                    return e || "0" !== t ? e + (t.match(/[0-9]/) ? t : "") : "";
                                }), "").slice(0, 4);
                                r.value = N, k.classList[4 === N.length ? "remove" : "add"]("qs-disabled");
                            }
                        }
                    }
                    function Y(e) {
                        L(e), e.__qs_shadow_dom = !0;
                    }
                    function j(e, t) {
                        l.forEach((function(n) {
                            e.removeEventListener(n, t);
                        }));
                    }
                    function O() {
                        S(this);
                    }
                    function P() {
                        q(this);
                    }
                    function k(e, t) {
                        var n = g(e), a = this.currentYear, r = this.currentMonth, i = this.sibling;
                        if (null == e) return this.dateSelected = void 0, p(this.el, this, !0), i && (y({
                            instance: this,
                            deselect: !0
                        }), u(i)), u(this), this;
                        if (!b(e)) throw new Error("`setDate` needs a JavaScript Date object.");
                        if (this.disabledDates[+n] || n < this.minDate || n > this.maxDate) throw new Error("You can't manually set a date that's disabled.");
                        this.dateSelected = n, t && (this.currentYear = n.getFullYear(), this.currentMonth = n.getMonth(), 
                        this.currentMonthName = this.months[n.getMonth()]), p(this.el, this), i && (y({
                            instance: this
                        }), u(i));
                        var o = a === n.getFullYear() && r === n.getMonth();
                        return o || t ? u(this, n) : o || u(this, new Date(a, r, 1)), this;
                    }
                    function N(e) {
                        return I(this, e, !0);
                    }
                    function _(e) {
                        return I(this, e);
                    }
                    function I(e, t, n) {
                        var a = e.dateSelected, r = e.first, i = e.sibling, o = e.minDate, s = e.maxDate, l = g(t), d = n ? "Min" : "Max";
                        function c() {
                            return "original" + d + "Date";
                        }
                        function h() {
                            return d.toLowerCase() + "Date";
                        }
                        function f() {
                            return "set" + d;
                        }
                        function v() {
                            throw new Error("Out-of-range date passed to " + f());
                        }
                        if (null == t) e[c()] = void 0, i ? (i[c()] = void 0, n ? (r && !a || !r && !i.dateSelected) && (e.minDate = void 0, 
                        i.minDate = void 0) : (r && !i.dateSelected || !r && !a) && (e.maxDate = void 0, 
                        i.maxDate = void 0)) : e[h()] = void 0; else {
                            if (!b(t)) throw new Error("Invalid date passed to " + f());
                            i ? ((r && n && l > (a || s) || r && !n && l < (i.dateSelected || o) || !r && n && l > (i.dateSelected || s) || !r && !n && l < (a || o)) && v(), 
                            e[c()] = l, i[c()] = l, (n && (r && !a || !r && !i.dateSelected) || !n && (r && !i.dateSelected || !r && !a)) && (e[h()] = l, 
                            i[h()] = l)) : ((n && l > (a || s) || !n && l < (a || o)) && v(), e[h()] = l);
                        }
                        return i && u(i), u(e), e;
                    }
                    function A() {
                        var e = this.first ? this : this.sibling, t = e.sibling;
                        return {
                            start: e.dateSelected,
                            end: t.dateSelected
                        };
                    }
                    function R() {
                        var e = this.shadowDom, t = this.positionedEl, n = this.calendarContainer, r = this.sibling, i = this;
                        this.inlinePosition && (a.some((function(e) {
                            return e !== i && e.positionedEl === t;
                        })) || t.style.setProperty("position", null));
                        n.remove(), a = a.filter((function(e) {
                            return e !== i;
                        })), r && delete r.sibling, a.length || j(document, L);
                        var o = a.some((function(t) {
                            return t.shadowDom === e;
                        }));
                        for (var s in e && !o && j(e, Y), this) delete this[s];
                        a.length || l.forEach((function(e) {
                            document.removeEventListener(e, L);
                        }));
                    }
                    function F(e, t) {
                        var n = new Date(e);
                        if (!b(n)) throw new Error("Invalid date passed to `navigate`");
                        this.currentYear = n.getFullYear(), this.currentMonth = n.getMonth(), u(this), t && this.onMonthChange(this);
                    }
                    function B() {
                        var e = !this.calendarContainer.classList.contains("qs-hidden"), t = !this.calendarContainer.querySelector(".qs-overlay").classList.contains("qs-hidden");
                        e && M(t, this);
                    }
                    t.default = function(e, t) {
                        var n = function(e, t) {
                            var n, l, d = function(e) {
                                var t = c(e);
                                t.events && (t.events = t.events.reduce((function(e, t) {
                                    if (!b(t)) throw new Error('"options.events" must only contain valid JavaScript Date objects.');
                                    return e[+g(t)] = !0, e;
                                }), {}));
                                [ "startDate", "dateSelected", "minDate", "maxDate" ].forEach((function(e) {
                                    var n = t[e];
                                    if (n && !b(n)) throw new Error('"options.' + e + '" needs to be a valid JavaScript Date object.');
                                    t[e] = g(n);
                                }));
                                var n = t.position, i = t.maxDate, l = t.minDate, d = t.dateSelected, u = t.overlayPlaceholder, h = t.overlayButton, f = t.startDay, v = t.id;
                                if (t.startDate = g(t.startDate || d || new Date), t.disabledDates = (t.disabledDates || []).reduce((function(e, t) {
                                    var n = +g(t);
                                    if (!b(t)) throw new Error('You supplied an invalid date to "options.disabledDates".');
                                    if (n === +g(d)) throw new Error('"disabledDates" cannot contain the same date as "dateSelected".');
                                    return e[n] = 1, e;
                                }), {}), t.hasOwnProperty("id") && null == v) throw new Error("`id` cannot be `null` or `undefined`");
                                if (null != v) {
                                    var m = a.filter((function(e) {
                                        return e.id === v;
                                    }));
                                    if (m.length > 1) throw new Error("Only two datepickers can share an id.");
                                    m.length ? (t.second = !0, t.sibling = m[0]) : t.first = !0;
                                }
                                var y = [ "tr", "tl", "br", "bl", "c" ].some((function(e) {
                                    return n === e;
                                }));
                                if (n && !y) throw new Error('"options.position" must be one of the following: tl, tr, bl, br, or c.');
                                function p(e) {
                                    throw new Error('"dateSelected" in options is ' + (e ? "less" : "greater") + ' than "' + (e || "max") + 'Date".');
                                }
                                if (t.position = function(e) {
                                    var t = e[0], n = e[1], a = {};
                                    a[o[t]] = 1, n && (a[o[n]] = 1);
                                    return a;
                                }(n || "bl"), i < l) throw new Error('"maxDate" in options is less than "minDate".');
                                d && (l > d && p("min"), i < d && p());
                                if ([ "onSelect", "onShow", "onHide", "onMonthChange", "formatter", "disabler" ].forEach((function(e) {
                                    "function" != typeof t[e] && (t[e] = s);
                                })), [ "customDays", "customMonths", "customOverlayMonths" ].forEach((function(e, n) {
                                    var a = t[e], r = n ? 12 : 7;
                                    if (a) {
                                        if (!Array.isArray(a) || a.length !== r || a.some((function(e) {
                                            return "string" != typeof e;
                                        }))) throw new Error('"' + e + '" must be an array with ' + r + " strings.");
                                        t[n ? n < 2 ? "months" : "overlayMonths" : "days"] = a;
                                    }
                                })), f && f > 0 && f < 7) {
                                    var w = (t.customDays || r).slice(), D = w.splice(0, f);
                                    t.customDays = w.concat(D), t.startDay = +f, t.weekendIndices = [ w.length - 1, w.length ];
                                } else t.startDay = 0, t.weekendIndices = [ 6, 0 ];
                                "string" != typeof u && delete t.overlayPlaceholder;
                                "string" != typeof h && delete t.overlayButton;
                                var q = t.defaultView;
                                if (q && "calendar" !== q && "overlay" !== q) throw new Error('options.defaultView must either be "calendar" or "overlay".');
                                return t.defaultView = q || "calendar", t;
                            }(t || {
                                startDate: g(new Date),
                                position: "bl",
                                defaultView: "calendar"
                            }), u = e;
                            if ("string" == typeof u) u = "#" === u[0] ? document.getElementById(u.slice(1)) : document.querySelector(u); else {
                                if ("[object ShadowRoot]" === x(u)) throw new Error("Using a shadow DOM as your selector is not supported.");
                                for (var h, f = u.parentNode; !h; ) {
                                    var v = x(f);
                                    "[object HTMLDocument]" === v ? h = !0 : "[object ShadowRoot]" === v ? (h = !0, 
                                    n = f, l = f.host) : f = f.parentNode;
                                }
                            }
                            if (!u) throw new Error("No selector / element found.");
                            if (a.some((function(e) {
                                return e.el === u;
                            }))) throw new Error("A datepicker already exists on that element.");
                            var m = u === document.body, y = n ? u.parentElement || n : m ? document.body : u.parentElement, w = n ? u.parentElement || l : y, D = document.createElement("div"), q = document.createElement("div");
                            D.className = "qs-datepicker-container qs-hidden", q.className = "qs-datepicker";
                            var M = {
                                shadowDom: n,
                                customElement: l,
                                positionedEl: w,
                                el: u,
                                parent: y,
                                nonInput: "INPUT" !== u.nodeName,
                                noPosition: m,
                                position: !m && d.position,
                                startDate: d.startDate,
                                dateSelected: d.dateSelected,
                                disabledDates: d.disabledDates,
                                minDate: d.minDate,
                                maxDate: d.maxDate,
                                noWeekends: !!d.noWeekends,
                                weekendIndices: d.weekendIndices,
                                calendarContainer: D,
                                calendar: q,
                                currentMonth: (d.startDate || d.dateSelected).getMonth(),
                                currentMonthName: (d.months || i)[(d.startDate || d.dateSelected).getMonth()],
                                currentYear: (d.startDate || d.dateSelected).getFullYear(),
                                events: d.events || {},
                                defaultView: d.defaultView,
                                setDate: k,
                                remove: R,
                                setMin: N,
                                setMax: _,
                                show: O,
                                hide: P,
                                navigate: F,
                                toggleOverlay: B,
                                onSelect: d.onSelect,
                                onShow: d.onShow,
                                onHide: d.onHide,
                                onMonthChange: d.onMonthChange,
                                formatter: d.formatter,
                                disabler: d.disabler,
                                months: d.months || i,
                                days: d.customDays || r,
                                startDay: d.startDay,
                                overlayMonths: d.overlayMonths || (d.months || i).map((function(e) {
                                    return e.slice(0, 3);
                                })),
                                overlayPlaceholder: d.overlayPlaceholder || "4-digit year",
                                overlayButton: d.overlayButton || "Submit",
                                disableYearOverlay: !!d.disableYearOverlay,
                                disableMobile: !!d.disableMobile,
                                isMobile: "ontouchstart" in window,
                                alwaysShow: !!d.alwaysShow,
                                id: d.id,
                                showAllDates: !!d.showAllDates,
                                respectDisabledReadOnly: !!d.respectDisabledReadOnly,
                                first: d.first,
                                second: d.second
                            };
                            if (d.sibling) {
                                var E = d.sibling, C = M, L = E.minDate || C.minDate, Y = E.maxDate || C.maxDate;
                                C.sibling = E, E.sibling = C, E.minDate = L, E.maxDate = Y, C.minDate = L, C.maxDate = Y, 
                                E.originalMinDate = L, E.originalMaxDate = Y, C.originalMinDate = L, C.originalMaxDate = Y, 
                                E.getRange = A, C.getRange = A;
                            }
                            d.dateSelected && p(u, M);
                            var j = getComputedStyle(w).position;
                            m || j && "static" !== j || (M.inlinePosition = !0, w.style.setProperty("position", "relative"));
                            var I = a.filter((function(e) {
                                return e.positionedEl === M.positionedEl;
                            }));
                            I.some((function(e) {
                                return e.inlinePosition;
                            })) && (M.inlinePosition = !0, I.forEach((function(e) {
                                e.inlinePosition = !0;
                            })));
                            D.appendChild(q), y.appendChild(D), M.alwaysShow && S(M);
                            return M;
                        }(e, t);
                        if (a.length || d(document), n.shadowDom && (a.some((function(e) {
                            return e.shadowDom === n.shadowDom;
                        })) || d(n.shadowDom)), a.push(n), n.second) {
                            var l = n.sibling;
                            y({
                                instance: n,
                                deselect: !n.dateSelected
                            }), y({
                                instance: l,
                                deselect: !l.dateSelected
                            }), u(l);
                        }
                        return u(n, n.startDate || n.dateSelected), n.alwaysShow && D(n), n;
                    };
                } ]).default;
            }));
        }
    };
    var __webpack_module_cache__ = {};
    function __webpack_require__(moduleId) {
        var cachedModule = __webpack_module_cache__[moduleId];
        if (cachedModule !== void 0) return cachedModule.exports;
        var module = __webpack_module_cache__[moduleId] = {
            exports: {}
        };
        __webpack_modules__[moduleId](module, module.exports, __webpack_require__);
        return module.exports;
    }
    (() => {
        "use strict";
        function addLoadedClass() {
            if (!document.documentElement.classList.contains("loading")) window.addEventListener("load", (function() {
                setTimeout((function() {
                    document.documentElement.classList.add("loaded");
                }), 0);
            }));
        }
        var datepicker_min = __webpack_require__(934);
        if (document.querySelector("[data-datepicker]")) {
            const picker = datepicker_min("[data-datepicker]", {
                customDays: [ "Пн", "Вт", "Ср", "Чт", "Пт", "Сб", "Нд" ],
                customMonths: [ "Січ", "Лют", "Берез", "Квіт", "Трав", "Черв", "Лип", "Серп", "Верес", "Жовт", "Листоп", "Груд" ],
                overlayButton: "Застосувати",
                overlayPlaceholder: "Рік (4 цифри)",
                startDay: 1,
                formatter: (input, date, instance) => {
                    const value = date.toLocaleDateString();
                    input.value = value;
                },
                onSelect: function(input, instance, date) {}
            });
            picker;
        }
        function getWindow(node) {
            if (node == null) return window;
            if (node.toString() !== "[object Window]") {
                var ownerDocument = node.ownerDocument;
                return ownerDocument ? ownerDocument.defaultView || window : window;
            }
            return node;
        }
        function isElement(node) {
            var OwnElement = getWindow(node).Element;
            return node instanceof OwnElement || node instanceof Element;
        }
        function isHTMLElement(node) {
            var OwnElement = getWindow(node).HTMLElement;
            return node instanceof OwnElement || node instanceof HTMLElement;
        }
        function isShadowRoot(node) {
            if (typeof ShadowRoot === "undefined") return false;
            var OwnElement = getWindow(node).ShadowRoot;
            return node instanceof OwnElement || node instanceof ShadowRoot;
        }
        var math_max = Math.max;
        var math_min = Math.min;
        var round = Math.round;
        function getUAString() {
            var uaData = navigator.userAgentData;
            if (uaData != null && uaData.brands && Array.isArray(uaData.brands)) return uaData.brands.map((function(item) {
                return item.brand + "/" + item.version;
            })).join(" ");
            return navigator.userAgent;
        }
        function isLayoutViewport() {
            return !/^((?!chrome|android).)*safari/i.test(getUAString());
        }
        function getBoundingClientRect(element, includeScale, isFixedStrategy) {
            if (includeScale === void 0) includeScale = false;
            if (isFixedStrategy === void 0) isFixedStrategy = false;
            var clientRect = element.getBoundingClientRect();
            var scaleX = 1;
            var scaleY = 1;
            if (includeScale && isHTMLElement(element)) {
                scaleX = element.offsetWidth > 0 ? round(clientRect.width) / element.offsetWidth || 1 : 1;
                scaleY = element.offsetHeight > 0 ? round(clientRect.height) / element.offsetHeight || 1 : 1;
            }
            var _ref = isElement(element) ? getWindow(element) : window, visualViewport = _ref.visualViewport;
            var addVisualOffsets = !isLayoutViewport() && isFixedStrategy;
            var x = (clientRect.left + (addVisualOffsets && visualViewport ? visualViewport.offsetLeft : 0)) / scaleX;
            var y = (clientRect.top + (addVisualOffsets && visualViewport ? visualViewport.offsetTop : 0)) / scaleY;
            var width = clientRect.width / scaleX;
            var height = clientRect.height / scaleY;
            return {
                width,
                height,
                top: y,
                right: x + width,
                bottom: y + height,
                left: x,
                x,
                y
            };
        }
        function getWindowScroll(node) {
            var win = getWindow(node);
            var scrollLeft = win.pageXOffset;
            var scrollTop = win.pageYOffset;
            return {
                scrollLeft,
                scrollTop
            };
        }
        function getHTMLElementScroll(element) {
            return {
                scrollLeft: element.scrollLeft,
                scrollTop: element.scrollTop
            };
        }
        function getNodeScroll(node) {
            if (node === getWindow(node) || !isHTMLElement(node)) return getWindowScroll(node); else return getHTMLElementScroll(node);
        }
        function getNodeName(element) {
            return element ? (element.nodeName || "").toLowerCase() : null;
        }
        function getDocumentElement(element) {
            return ((isElement(element) ? element.ownerDocument : element.document) || window.document).documentElement;
        }
        function getWindowScrollBarX(element) {
            return getBoundingClientRect(getDocumentElement(element)).left + getWindowScroll(element).scrollLeft;
        }
        function getComputedStyle_getComputedStyle(element) {
            return getWindow(element).getComputedStyle(element);
        }
        function isScrollParent(element) {
            var _getComputedStyle = getComputedStyle_getComputedStyle(element), overflow = _getComputedStyle.overflow, overflowX = _getComputedStyle.overflowX, overflowY = _getComputedStyle.overflowY;
            return /auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX);
        }
        function isElementScaled(element) {
            var rect = element.getBoundingClientRect();
            var scaleX = round(rect.width) / element.offsetWidth || 1;
            var scaleY = round(rect.height) / element.offsetHeight || 1;
            return scaleX !== 1 || scaleY !== 1;
        }
        function getCompositeRect(elementOrVirtualElement, offsetParent, isFixed) {
            if (isFixed === void 0) isFixed = false;
            var isOffsetParentAnElement = isHTMLElement(offsetParent);
            var offsetParentIsScaled = isHTMLElement(offsetParent) && isElementScaled(offsetParent);
            var documentElement = getDocumentElement(offsetParent);
            var rect = getBoundingClientRect(elementOrVirtualElement, offsetParentIsScaled, isFixed);
            var scroll = {
                scrollLeft: 0,
                scrollTop: 0
            };
            var offsets = {
                x: 0,
                y: 0
            };
            if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
                if (getNodeName(offsetParent) !== "body" || isScrollParent(documentElement)) scroll = getNodeScroll(offsetParent);
                if (isHTMLElement(offsetParent)) {
                    offsets = getBoundingClientRect(offsetParent, true);
                    offsets.x += offsetParent.clientLeft;
                    offsets.y += offsetParent.clientTop;
                } else if (documentElement) offsets.x = getWindowScrollBarX(documentElement);
            }
            return {
                x: rect.left + scroll.scrollLeft - offsets.x,
                y: rect.top + scroll.scrollTop - offsets.y,
                width: rect.width,
                height: rect.height
            };
        }
        function getLayoutRect(element) {
            var clientRect = getBoundingClientRect(element);
            var width = element.offsetWidth;
            var height = element.offsetHeight;
            if (Math.abs(clientRect.width - width) <= 1) width = clientRect.width;
            if (Math.abs(clientRect.height - height) <= 1) height = clientRect.height;
            return {
                x: element.offsetLeft,
                y: element.offsetTop,
                width,
                height
            };
        }
        function getParentNode(element) {
            if (getNodeName(element) === "html") return element;
            return element.assignedSlot || element.parentNode || (isShadowRoot(element) ? element.host : null) || getDocumentElement(element);
        }
        function getScrollParent(node) {
            if ([ "html", "body", "#document" ].indexOf(getNodeName(node)) >= 0) return node.ownerDocument.body;
            if (isHTMLElement(node) && isScrollParent(node)) return node;
            return getScrollParent(getParentNode(node));
        }
        function listScrollParents(element, list) {
            var _element$ownerDocumen;
            if (list === void 0) list = [];
            var scrollParent = getScrollParent(element);
            var isBody = scrollParent === ((_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body);
            var win = getWindow(scrollParent);
            var target = isBody ? [ win ].concat(win.visualViewport || [], isScrollParent(scrollParent) ? scrollParent : []) : scrollParent;
            var updatedList = list.concat(target);
            return isBody ? updatedList : updatedList.concat(listScrollParents(getParentNode(target)));
        }
        function isTableElement(element) {
            return [ "table", "td", "th" ].indexOf(getNodeName(element)) >= 0;
        }
        function getTrueOffsetParent(element) {
            if (!isHTMLElement(element) || getComputedStyle_getComputedStyle(element).position === "fixed") return null;
            return element.offsetParent;
        }
        function getContainingBlock(element) {
            var isFirefox = /firefox/i.test(getUAString());
            var isIE = /Trident/i.test(getUAString());
            if (isIE && isHTMLElement(element)) {
                var elementCss = getComputedStyle_getComputedStyle(element);
                if (elementCss.position === "fixed") return null;
            }
            var currentNode = getParentNode(element);
            if (isShadowRoot(currentNode)) currentNode = currentNode.host;
            while (isHTMLElement(currentNode) && [ "html", "body" ].indexOf(getNodeName(currentNode)) < 0) {
                var css = getComputedStyle_getComputedStyle(currentNode);
                if (css.transform !== "none" || css.perspective !== "none" || css.contain === "paint" || [ "transform", "perspective" ].indexOf(css.willChange) !== -1 || isFirefox && css.willChange === "filter" || isFirefox && css.filter && css.filter !== "none") return currentNode; else currentNode = currentNode.parentNode;
            }
            return null;
        }
        function getOffsetParent(element) {
            var window = getWindow(element);
            var offsetParent = getTrueOffsetParent(element);
            while (offsetParent && isTableElement(offsetParent) && getComputedStyle_getComputedStyle(offsetParent).position === "static") offsetParent = getTrueOffsetParent(offsetParent);
            if (offsetParent && (getNodeName(offsetParent) === "html" || getNodeName(offsetParent) === "body" && getComputedStyle_getComputedStyle(offsetParent).position === "static")) return window;
            return offsetParent || getContainingBlock(element) || window;
        }
        var enums_top = "top";
        var bottom = "bottom";
        var right = "right";
        var left = "left";
        var auto = "auto";
        var basePlacements = [ enums_top, bottom, right, left ];
        var start = "start";
        var end = "end";
        var clippingParents = "clippingParents";
        var viewport = "viewport";
        var popper = "popper";
        var reference = "reference";
        var variationPlacements = basePlacements.reduce((function(acc, placement) {
            return acc.concat([ placement + "-" + start, placement + "-" + end ]);
        }), []);
        var enums_placements = [].concat(basePlacements, [ auto ]).reduce((function(acc, placement) {
            return acc.concat([ placement, placement + "-" + start, placement + "-" + end ]);
        }), []);
        var beforeRead = "beforeRead";
        var read = "read";
        var afterRead = "afterRead";
        var beforeMain = "beforeMain";
        var main = "main";
        var afterMain = "afterMain";
        var beforeWrite = "beforeWrite";
        var write = "write";
        var afterWrite = "afterWrite";
        var modifierPhases = [ beforeRead, read, afterRead, beforeMain, main, afterMain, beforeWrite, write, afterWrite ];
        function order(modifiers) {
            var map = new Map;
            var visited = new Set;
            var result = [];
            modifiers.forEach((function(modifier) {
                map.set(modifier.name, modifier);
            }));
            function sort(modifier) {
                visited.add(modifier.name);
                var requires = [].concat(modifier.requires || [], modifier.requiresIfExists || []);
                requires.forEach((function(dep) {
                    if (!visited.has(dep)) {
                        var depModifier = map.get(dep);
                        if (depModifier) sort(depModifier);
                    }
                }));
                result.push(modifier);
            }
            modifiers.forEach((function(modifier) {
                if (!visited.has(modifier.name)) sort(modifier);
            }));
            return result;
        }
        function orderModifiers(modifiers) {
            var orderedModifiers = order(modifiers);
            return modifierPhases.reduce((function(acc, phase) {
                return acc.concat(orderedModifiers.filter((function(modifier) {
                    return modifier.phase === phase;
                })));
            }), []);
        }
        function debounce(fn) {
            var pending;
            return function() {
                if (!pending) pending = new Promise((function(resolve) {
                    Promise.resolve().then((function() {
                        pending = void 0;
                        resolve(fn());
                    }));
                }));
                return pending;
            };
        }
        function mergeByName(modifiers) {
            var merged = modifiers.reduce((function(merged, current) {
                var existing = merged[current.name];
                merged[current.name] = existing ? Object.assign({}, existing, current, {
                    options: Object.assign({}, existing.options, current.options),
                    data: Object.assign({}, existing.data, current.data)
                }) : current;
                return merged;
            }), {});
            return Object.keys(merged).map((function(key) {
                return merged[key];
            }));
        }
        var DEFAULT_OPTIONS = {
            placement: "bottom",
            modifiers: [],
            strategy: "absolute"
        };
        function areValidElements() {
            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
            return !args.some((function(element) {
                return !(element && typeof element.getBoundingClientRect === "function");
            }));
        }
        function popperGenerator(generatorOptions) {
            if (generatorOptions === void 0) generatorOptions = {};
            var _generatorOptions = generatorOptions, _generatorOptions$def = _generatorOptions.defaultModifiers, defaultModifiers = _generatorOptions$def === void 0 ? [] : _generatorOptions$def, _generatorOptions$def2 = _generatorOptions.defaultOptions, defaultOptions = _generatorOptions$def2 === void 0 ? DEFAULT_OPTIONS : _generatorOptions$def2;
            return function createPopper(reference, popper, options) {
                if (options === void 0) options = defaultOptions;
                var state = {
                    placement: "bottom",
                    orderedModifiers: [],
                    options: Object.assign({}, DEFAULT_OPTIONS, defaultOptions),
                    modifiersData: {},
                    elements: {
                        reference,
                        popper
                    },
                    attributes: {},
                    styles: {}
                };
                var effectCleanupFns = [];
                var isDestroyed = false;
                var instance = {
                    state,
                    setOptions: function setOptions(setOptionsAction) {
                        var options = typeof setOptionsAction === "function" ? setOptionsAction(state.options) : setOptionsAction;
                        cleanupModifierEffects();
                        state.options = Object.assign({}, defaultOptions, state.options, options);
                        state.scrollParents = {
                            reference: isElement(reference) ? listScrollParents(reference) : reference.contextElement ? listScrollParents(reference.contextElement) : [],
                            popper: listScrollParents(popper)
                        };
                        var orderedModifiers = orderModifiers(mergeByName([].concat(defaultModifiers, state.options.modifiers)));
                        state.orderedModifiers = orderedModifiers.filter((function(m) {
                            return m.enabled;
                        }));
                        runModifierEffects();
                        return instance.update();
                    },
                    forceUpdate: function forceUpdate() {
                        if (isDestroyed) return;
                        var _state$elements = state.elements, reference = _state$elements.reference, popper = _state$elements.popper;
                        if (!areValidElements(reference, popper)) return;
                        state.rects = {
                            reference: getCompositeRect(reference, getOffsetParent(popper), state.options.strategy === "fixed"),
                            popper: getLayoutRect(popper)
                        };
                        state.reset = false;
                        state.placement = state.options.placement;
                        state.orderedModifiers.forEach((function(modifier) {
                            return state.modifiersData[modifier.name] = Object.assign({}, modifier.data);
                        }));
                        for (var index = 0; index < state.orderedModifiers.length; index++) {
                            if (state.reset === true) {
                                state.reset = false;
                                index = -1;
                                continue;
                            }
                            var _state$orderedModifie = state.orderedModifiers[index], fn = _state$orderedModifie.fn, _state$orderedModifie2 = _state$orderedModifie.options, _options = _state$orderedModifie2 === void 0 ? {} : _state$orderedModifie2, name = _state$orderedModifie.name;
                            if (typeof fn === "function") state = fn({
                                state,
                                options: _options,
                                name,
                                instance
                            }) || state;
                        }
                    },
                    update: debounce((function() {
                        return new Promise((function(resolve) {
                            instance.forceUpdate();
                            resolve(state);
                        }));
                    })),
                    destroy: function destroy() {
                        cleanupModifierEffects();
                        isDestroyed = true;
                    }
                };
                if (!areValidElements(reference, popper)) return instance;
                instance.setOptions(options).then((function(state) {
                    if (!isDestroyed && options.onFirstUpdate) options.onFirstUpdate(state);
                }));
                function runModifierEffects() {
                    state.orderedModifiers.forEach((function(_ref) {
                        var name = _ref.name, _ref$options = _ref.options, options = _ref$options === void 0 ? {} : _ref$options, effect = _ref.effect;
                        if (typeof effect === "function") {
                            var cleanupFn = effect({
                                state,
                                name,
                                instance,
                                options
                            });
                            var noopFn = function noopFn() {};
                            effectCleanupFns.push(cleanupFn || noopFn);
                        }
                    }));
                }
                function cleanupModifierEffects() {
                    effectCleanupFns.forEach((function(fn) {
                        return fn();
                    }));
                    effectCleanupFns = [];
                }
                return instance;
            };
        }
        null && popperGenerator();
        var passive = {
            passive: true
        };
        function effect(_ref) {
            var state = _ref.state, instance = _ref.instance, options = _ref.options;
            var _options$scroll = options.scroll, scroll = _options$scroll === void 0 ? true : _options$scroll, _options$resize = options.resize, resize = _options$resize === void 0 ? true : _options$resize;
            var window = getWindow(state.elements.popper);
            var scrollParents = [].concat(state.scrollParents.reference, state.scrollParents.popper);
            if (scroll) scrollParents.forEach((function(scrollParent) {
                scrollParent.addEventListener("scroll", instance.update, passive);
            }));
            if (resize) window.addEventListener("resize", instance.update, passive);
            return function() {
                if (scroll) scrollParents.forEach((function(scrollParent) {
                    scrollParent.removeEventListener("scroll", instance.update, passive);
                }));
                if (resize) window.removeEventListener("resize", instance.update, passive);
            };
        }
        const eventListeners = {
            name: "eventListeners",
            enabled: true,
            phase: "write",
            fn: function fn() {},
            effect,
            data: {}
        };
        function getBasePlacement(placement) {
            return placement.split("-")[0];
        }
        function getVariation(placement) {
            return placement.split("-")[1];
        }
        function getMainAxisFromPlacement(placement) {
            return [ "top", "bottom" ].indexOf(placement) >= 0 ? "x" : "y";
        }
        function computeOffsets(_ref) {
            var reference = _ref.reference, element = _ref.element, placement = _ref.placement;
            var basePlacement = placement ? getBasePlacement(placement) : null;
            var variation = placement ? getVariation(placement) : null;
            var commonX = reference.x + reference.width / 2 - element.width / 2;
            var commonY = reference.y + reference.height / 2 - element.height / 2;
            var offsets;
            switch (basePlacement) {
              case enums_top:
                offsets = {
                    x: commonX,
                    y: reference.y - element.height
                };
                break;

              case bottom:
                offsets = {
                    x: commonX,
                    y: reference.y + reference.height
                };
                break;

              case right:
                offsets = {
                    x: reference.x + reference.width,
                    y: commonY
                };
                break;

              case left:
                offsets = {
                    x: reference.x - element.width,
                    y: commonY
                };
                break;

              default:
                offsets = {
                    x: reference.x,
                    y: reference.y
                };
            }
            var mainAxis = basePlacement ? getMainAxisFromPlacement(basePlacement) : null;
            if (mainAxis != null) {
                var len = mainAxis === "y" ? "height" : "width";
                switch (variation) {
                  case start:
                    offsets[mainAxis] = offsets[mainAxis] - (reference[len] / 2 - element[len] / 2);
                    break;

                  case end:
                    offsets[mainAxis] = offsets[mainAxis] + (reference[len] / 2 - element[len] / 2);
                    break;

                  default:
                }
            }
            return offsets;
        }
        function popperOffsets(_ref) {
            var state = _ref.state, name = _ref.name;
            state.modifiersData[name] = computeOffsets({
                reference: state.rects.reference,
                element: state.rects.popper,
                strategy: "absolute",
                placement: state.placement
            });
        }
        const modifiers_popperOffsets = {
            name: "popperOffsets",
            enabled: true,
            phase: "read",
            fn: popperOffsets,
            data: {}
        };
        var unsetSides = {
            top: "auto",
            right: "auto",
            bottom: "auto",
            left: "auto"
        };
        function roundOffsetsByDPR(_ref, win) {
            var x = _ref.x, y = _ref.y;
            var dpr = win.devicePixelRatio || 1;
            return {
                x: round(x * dpr) / dpr || 0,
                y: round(y * dpr) / dpr || 0
            };
        }
        function mapToStyles(_ref2) {
            var _Object$assign2;
            var popper = _ref2.popper, popperRect = _ref2.popperRect, placement = _ref2.placement, variation = _ref2.variation, offsets = _ref2.offsets, position = _ref2.position, gpuAcceleration = _ref2.gpuAcceleration, adaptive = _ref2.adaptive, roundOffsets = _ref2.roundOffsets, isFixed = _ref2.isFixed;
            var _offsets$x = offsets.x, x = _offsets$x === void 0 ? 0 : _offsets$x, _offsets$y = offsets.y, y = _offsets$y === void 0 ? 0 : _offsets$y;
            var _ref3 = typeof roundOffsets === "function" ? roundOffsets({
                x,
                y
            }) : {
                x,
                y
            };
            x = _ref3.x;
            y = _ref3.y;
            var hasX = offsets.hasOwnProperty("x");
            var hasY = offsets.hasOwnProperty("y");
            var sideX = left;
            var sideY = enums_top;
            var win = window;
            if (adaptive) {
                var offsetParent = getOffsetParent(popper);
                var heightProp = "clientHeight";
                var widthProp = "clientWidth";
                if (offsetParent === getWindow(popper)) {
                    offsetParent = getDocumentElement(popper);
                    if (getComputedStyle_getComputedStyle(offsetParent).position !== "static" && position === "absolute") {
                        heightProp = "scrollHeight";
                        widthProp = "scrollWidth";
                    }
                }
                offsetParent;
                if (placement === enums_top || (placement === left || placement === right) && variation === end) {
                    sideY = bottom;
                    var offsetY = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.height : offsetParent[heightProp];
                    y -= offsetY - popperRect.height;
                    y *= gpuAcceleration ? 1 : -1;
                }
                if (placement === left || (placement === enums_top || placement === bottom) && variation === end) {
                    sideX = right;
                    var offsetX = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.width : offsetParent[widthProp];
                    x -= offsetX - popperRect.width;
                    x *= gpuAcceleration ? 1 : -1;
                }
            }
            var commonStyles = Object.assign({
                position
            }, adaptive && unsetSides);
            var _ref4 = roundOffsets === true ? roundOffsetsByDPR({
                x,
                y
            }, getWindow(popper)) : {
                x,
                y
            };
            x = _ref4.x;
            y = _ref4.y;
            if (gpuAcceleration) {
                var _Object$assign;
                return Object.assign({}, commonStyles, (_Object$assign = {}, _Object$assign[sideY] = hasY ? "0" : "", 
                _Object$assign[sideX] = hasX ? "0" : "", _Object$assign.transform = (win.devicePixelRatio || 1) <= 1 ? "translate(" + x + "px, " + y + "px)" : "translate3d(" + x + "px, " + y + "px, 0)", 
                _Object$assign));
            }
            return Object.assign({}, commonStyles, (_Object$assign2 = {}, _Object$assign2[sideY] = hasY ? y + "px" : "", 
            _Object$assign2[sideX] = hasX ? x + "px" : "", _Object$assign2.transform = "", _Object$assign2));
        }
        function computeStyles(_ref5) {
            var state = _ref5.state, options = _ref5.options;
            var _options$gpuAccelerat = options.gpuAcceleration, gpuAcceleration = _options$gpuAccelerat === void 0 ? true : _options$gpuAccelerat, _options$adaptive = options.adaptive, adaptive = _options$adaptive === void 0 ? true : _options$adaptive, _options$roundOffsets = options.roundOffsets, roundOffsets = _options$roundOffsets === void 0 ? true : _options$roundOffsets;
            var commonStyles = {
                placement: getBasePlacement(state.placement),
                variation: getVariation(state.placement),
                popper: state.elements.popper,
                popperRect: state.rects.popper,
                gpuAcceleration,
                isFixed: state.options.strategy === "fixed"
            };
            if (state.modifiersData.popperOffsets != null) state.styles.popper = Object.assign({}, state.styles.popper, mapToStyles(Object.assign({}, commonStyles, {
                offsets: state.modifiersData.popperOffsets,
                position: state.options.strategy,
                adaptive,
                roundOffsets
            })));
            if (state.modifiersData.arrow != null) state.styles.arrow = Object.assign({}, state.styles.arrow, mapToStyles(Object.assign({}, commonStyles, {
                offsets: state.modifiersData.arrow,
                position: "absolute",
                adaptive: false,
                roundOffsets
            })));
            state.attributes.popper = Object.assign({}, state.attributes.popper, {
                "data-popper-placement": state.placement
            });
        }
        const modifiers_computeStyles = {
            name: "computeStyles",
            enabled: true,
            phase: "beforeWrite",
            fn: computeStyles,
            data: {}
        };
        function applyStyles(_ref) {
            var state = _ref.state;
            Object.keys(state.elements).forEach((function(name) {
                var style = state.styles[name] || {};
                var attributes = state.attributes[name] || {};
                var element = state.elements[name];
                if (!isHTMLElement(element) || !getNodeName(element)) return;
                Object.assign(element.style, style);
                Object.keys(attributes).forEach((function(name) {
                    var value = attributes[name];
                    if (value === false) element.removeAttribute(name); else element.setAttribute(name, value === true ? "" : value);
                }));
            }));
        }
        function applyStyles_effect(_ref2) {
            var state = _ref2.state;
            var initialStyles = {
                popper: {
                    position: state.options.strategy,
                    left: "0",
                    top: "0",
                    margin: "0"
                },
                arrow: {
                    position: "absolute"
                },
                reference: {}
            };
            Object.assign(state.elements.popper.style, initialStyles.popper);
            state.styles = initialStyles;
            if (state.elements.arrow) Object.assign(state.elements.arrow.style, initialStyles.arrow);
            return function() {
                Object.keys(state.elements).forEach((function(name) {
                    var element = state.elements[name];
                    var attributes = state.attributes[name] || {};
                    var styleProperties = Object.keys(state.styles.hasOwnProperty(name) ? state.styles[name] : initialStyles[name]);
                    var style = styleProperties.reduce((function(style, property) {
                        style[property] = "";
                        return style;
                    }), {});
                    if (!isHTMLElement(element) || !getNodeName(element)) return;
                    Object.assign(element.style, style);
                    Object.keys(attributes).forEach((function(attribute) {
                        element.removeAttribute(attribute);
                    }));
                }));
            };
        }
        const modifiers_applyStyles = {
            name: "applyStyles",
            enabled: true,
            phase: "write",
            fn: applyStyles,
            effect: applyStyles_effect,
            requires: [ "computeStyles" ]
        };
        function distanceAndSkiddingToXY(placement, rects, offset) {
            var basePlacement = getBasePlacement(placement);
            var invertDistance = [ left, enums_top ].indexOf(basePlacement) >= 0 ? -1 : 1;
            var _ref = typeof offset === "function" ? offset(Object.assign({}, rects, {
                placement
            })) : offset, skidding = _ref[0], distance = _ref[1];
            skidding = skidding || 0;
            distance = (distance || 0) * invertDistance;
            return [ left, right ].indexOf(basePlacement) >= 0 ? {
                x: distance,
                y: skidding
            } : {
                x: skidding,
                y: distance
            };
        }
        function offset(_ref2) {
            var state = _ref2.state, options = _ref2.options, name = _ref2.name;
            var _options$offset = options.offset, offset = _options$offset === void 0 ? [ 0, 0 ] : _options$offset;
            var data = enums_placements.reduce((function(acc, placement) {
                acc[placement] = distanceAndSkiddingToXY(placement, state.rects, offset);
                return acc;
            }), {});
            var _data$state$placement = data[state.placement], x = _data$state$placement.x, y = _data$state$placement.y;
            if (state.modifiersData.popperOffsets != null) {
                state.modifiersData.popperOffsets.x += x;
                state.modifiersData.popperOffsets.y += y;
            }
            state.modifiersData[name] = data;
        }
        const modifiers_offset = {
            name: "offset",
            enabled: true,
            phase: "main",
            requires: [ "popperOffsets" ],
            fn: offset
        };
        var hash = {
            left: "right",
            right: "left",
            bottom: "top",
            top: "bottom"
        };
        function getOppositePlacement(placement) {
            return placement.replace(/left|right|bottom|top/g, (function(matched) {
                return hash[matched];
            }));
        }
        var getOppositeVariationPlacement_hash = {
            start: "end",
            end: "start"
        };
        function getOppositeVariationPlacement(placement) {
            return placement.replace(/start|end/g, (function(matched) {
                return getOppositeVariationPlacement_hash[matched];
            }));
        }
        function getViewportRect(element, strategy) {
            var win = getWindow(element);
            var html = getDocumentElement(element);
            var visualViewport = win.visualViewport;
            var width = html.clientWidth;
            var height = html.clientHeight;
            var x = 0;
            var y = 0;
            if (visualViewport) {
                width = visualViewport.width;
                height = visualViewport.height;
                var layoutViewport = isLayoutViewport();
                if (layoutViewport || !layoutViewport && strategy === "fixed") {
                    x = visualViewport.offsetLeft;
                    y = visualViewport.offsetTop;
                }
            }
            return {
                width,
                height,
                x: x + getWindowScrollBarX(element),
                y
            };
        }
        function getDocumentRect(element) {
            var _element$ownerDocumen;
            var html = getDocumentElement(element);
            var winScroll = getWindowScroll(element);
            var body = (_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body;
            var width = math_max(html.scrollWidth, html.clientWidth, body ? body.scrollWidth : 0, body ? body.clientWidth : 0);
            var height = math_max(html.scrollHeight, html.clientHeight, body ? body.scrollHeight : 0, body ? body.clientHeight : 0);
            var x = -winScroll.scrollLeft + getWindowScrollBarX(element);
            var y = -winScroll.scrollTop;
            if (getComputedStyle_getComputedStyle(body || html).direction === "rtl") x += math_max(html.clientWidth, body ? body.clientWidth : 0) - width;
            return {
                width,
                height,
                x,
                y
            };
        }
        function contains(parent, child) {
            var rootNode = child.getRootNode && child.getRootNode();
            if (parent.contains(child)) return true; else if (rootNode && isShadowRoot(rootNode)) {
                var next = child;
                do {
                    if (next && parent.isSameNode(next)) return true;
                    next = next.parentNode || next.host;
                } while (next);
            }
            return false;
        }
        function rectToClientRect(rect) {
            return Object.assign({}, rect, {
                left: rect.x,
                top: rect.y,
                right: rect.x + rect.width,
                bottom: rect.y + rect.height
            });
        }
        function getInnerBoundingClientRect(element, strategy) {
            var rect = getBoundingClientRect(element, false, strategy === "fixed");
            rect.top = rect.top + element.clientTop;
            rect.left = rect.left + element.clientLeft;
            rect.bottom = rect.top + element.clientHeight;
            rect.right = rect.left + element.clientWidth;
            rect.width = element.clientWidth;
            rect.height = element.clientHeight;
            rect.x = rect.left;
            rect.y = rect.top;
            return rect;
        }
        function getClientRectFromMixedType(element, clippingParent, strategy) {
            return clippingParent === viewport ? rectToClientRect(getViewportRect(element, strategy)) : isElement(clippingParent) ? getInnerBoundingClientRect(clippingParent, strategy) : rectToClientRect(getDocumentRect(getDocumentElement(element)));
        }
        function getClippingParents(element) {
            var clippingParents = listScrollParents(getParentNode(element));
            var canEscapeClipping = [ "absolute", "fixed" ].indexOf(getComputedStyle_getComputedStyle(element).position) >= 0;
            var clipperElement = canEscapeClipping && isHTMLElement(element) ? getOffsetParent(element) : element;
            if (!isElement(clipperElement)) return [];
            return clippingParents.filter((function(clippingParent) {
                return isElement(clippingParent) && contains(clippingParent, clipperElement) && getNodeName(clippingParent) !== "body";
            }));
        }
        function getClippingRect(element, boundary, rootBoundary, strategy) {
            var mainClippingParents = boundary === "clippingParents" ? getClippingParents(element) : [].concat(boundary);
            var clippingParents = [].concat(mainClippingParents, [ rootBoundary ]);
            var firstClippingParent = clippingParents[0];
            var clippingRect = clippingParents.reduce((function(accRect, clippingParent) {
                var rect = getClientRectFromMixedType(element, clippingParent, strategy);
                accRect.top = math_max(rect.top, accRect.top);
                accRect.right = math_min(rect.right, accRect.right);
                accRect.bottom = math_min(rect.bottom, accRect.bottom);
                accRect.left = math_max(rect.left, accRect.left);
                return accRect;
            }), getClientRectFromMixedType(element, firstClippingParent, strategy));
            clippingRect.width = clippingRect.right - clippingRect.left;
            clippingRect.height = clippingRect.bottom - clippingRect.top;
            clippingRect.x = clippingRect.left;
            clippingRect.y = clippingRect.top;
            return clippingRect;
        }
        function getFreshSideObject() {
            return {
                top: 0,
                right: 0,
                bottom: 0,
                left: 0
            };
        }
        function mergePaddingObject(paddingObject) {
            return Object.assign({}, getFreshSideObject(), paddingObject);
        }
        function expandToHashMap(value, keys) {
            return keys.reduce((function(hashMap, key) {
                hashMap[key] = value;
                return hashMap;
            }), {});
        }
        function detectOverflow(state, options) {
            if (options === void 0) options = {};
            var _options = options, _options$placement = _options.placement, placement = _options$placement === void 0 ? state.placement : _options$placement, _options$strategy = _options.strategy, strategy = _options$strategy === void 0 ? state.strategy : _options$strategy, _options$boundary = _options.boundary, boundary = _options$boundary === void 0 ? clippingParents : _options$boundary, _options$rootBoundary = _options.rootBoundary, rootBoundary = _options$rootBoundary === void 0 ? viewport : _options$rootBoundary, _options$elementConte = _options.elementContext, elementContext = _options$elementConte === void 0 ? popper : _options$elementConte, _options$altBoundary = _options.altBoundary, altBoundary = _options$altBoundary === void 0 ? false : _options$altBoundary, _options$padding = _options.padding, padding = _options$padding === void 0 ? 0 : _options$padding;
            var paddingObject = mergePaddingObject(typeof padding !== "number" ? padding : expandToHashMap(padding, basePlacements));
            var altContext = elementContext === popper ? reference : popper;
            var popperRect = state.rects.popper;
            var element = state.elements[altBoundary ? altContext : elementContext];
            var clippingClientRect = getClippingRect(isElement(element) ? element : element.contextElement || getDocumentElement(state.elements.popper), boundary, rootBoundary, strategy);
            var referenceClientRect = getBoundingClientRect(state.elements.reference);
            var popperOffsets = computeOffsets({
                reference: referenceClientRect,
                element: popperRect,
                strategy: "absolute",
                placement
            });
            var popperClientRect = rectToClientRect(Object.assign({}, popperRect, popperOffsets));
            var elementClientRect = elementContext === popper ? popperClientRect : referenceClientRect;
            var overflowOffsets = {
                top: clippingClientRect.top - elementClientRect.top + paddingObject.top,
                bottom: elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom,
                left: clippingClientRect.left - elementClientRect.left + paddingObject.left,
                right: elementClientRect.right - clippingClientRect.right + paddingObject.right
            };
            var offsetData = state.modifiersData.offset;
            if (elementContext === popper && offsetData) {
                var offset = offsetData[placement];
                Object.keys(overflowOffsets).forEach((function(key) {
                    var multiply = [ right, bottom ].indexOf(key) >= 0 ? 1 : -1;
                    var axis = [ enums_top, bottom ].indexOf(key) >= 0 ? "y" : "x";
                    overflowOffsets[key] += offset[axis] * multiply;
                }));
            }
            return overflowOffsets;
        }
        function computeAutoPlacement(state, options) {
            if (options === void 0) options = {};
            var _options = options, placement = _options.placement, boundary = _options.boundary, rootBoundary = _options.rootBoundary, padding = _options.padding, flipVariations = _options.flipVariations, _options$allowedAutoP = _options.allowedAutoPlacements, allowedAutoPlacements = _options$allowedAutoP === void 0 ? enums_placements : _options$allowedAutoP;
            var variation = getVariation(placement);
            var placements = variation ? flipVariations ? variationPlacements : variationPlacements.filter((function(placement) {
                return getVariation(placement) === variation;
            })) : basePlacements;
            var allowedPlacements = placements.filter((function(placement) {
                return allowedAutoPlacements.indexOf(placement) >= 0;
            }));
            if (allowedPlacements.length === 0) allowedPlacements = placements;
            var overflows = allowedPlacements.reduce((function(acc, placement) {
                acc[placement] = detectOverflow(state, {
                    placement,
                    boundary,
                    rootBoundary,
                    padding
                })[getBasePlacement(placement)];
                return acc;
            }), {});
            return Object.keys(overflows).sort((function(a, b) {
                return overflows[a] - overflows[b];
            }));
        }
        function getExpandedFallbackPlacements(placement) {
            if (getBasePlacement(placement) === auto) return [];
            var oppositePlacement = getOppositePlacement(placement);
            return [ getOppositeVariationPlacement(placement), oppositePlacement, getOppositeVariationPlacement(oppositePlacement) ];
        }
        function flip(_ref) {
            var state = _ref.state, options = _ref.options, name = _ref.name;
            if (state.modifiersData[name]._skip) return;
            var _options$mainAxis = options.mainAxis, checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis, _options$altAxis = options.altAxis, checkAltAxis = _options$altAxis === void 0 ? true : _options$altAxis, specifiedFallbackPlacements = options.fallbackPlacements, padding = options.padding, boundary = options.boundary, rootBoundary = options.rootBoundary, altBoundary = options.altBoundary, _options$flipVariatio = options.flipVariations, flipVariations = _options$flipVariatio === void 0 ? true : _options$flipVariatio, allowedAutoPlacements = options.allowedAutoPlacements;
            var preferredPlacement = state.options.placement;
            var basePlacement = getBasePlacement(preferredPlacement);
            var isBasePlacement = basePlacement === preferredPlacement;
            var fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipVariations ? [ getOppositePlacement(preferredPlacement) ] : getExpandedFallbackPlacements(preferredPlacement));
            var placements = [ preferredPlacement ].concat(fallbackPlacements).reduce((function(acc, placement) {
                return acc.concat(getBasePlacement(placement) === auto ? computeAutoPlacement(state, {
                    placement,
                    boundary,
                    rootBoundary,
                    padding,
                    flipVariations,
                    allowedAutoPlacements
                }) : placement);
            }), []);
            var referenceRect = state.rects.reference;
            var popperRect = state.rects.popper;
            var checksMap = new Map;
            var makeFallbackChecks = true;
            var firstFittingPlacement = placements[0];
            for (var i = 0; i < placements.length; i++) {
                var placement = placements[i];
                var _basePlacement = getBasePlacement(placement);
                var isStartVariation = getVariation(placement) === start;
                var isVertical = [ enums_top, bottom ].indexOf(_basePlacement) >= 0;
                var len = isVertical ? "width" : "height";
                var overflow = detectOverflow(state, {
                    placement,
                    boundary,
                    rootBoundary,
                    altBoundary,
                    padding
                });
                var mainVariationSide = isVertical ? isStartVariation ? right : left : isStartVariation ? bottom : enums_top;
                if (referenceRect[len] > popperRect[len]) mainVariationSide = getOppositePlacement(mainVariationSide);
                var altVariationSide = getOppositePlacement(mainVariationSide);
                var checks = [];
                if (checkMainAxis) checks.push(overflow[_basePlacement] <= 0);
                if (checkAltAxis) checks.push(overflow[mainVariationSide] <= 0, overflow[altVariationSide] <= 0);
                if (checks.every((function(check) {
                    return check;
                }))) {
                    firstFittingPlacement = placement;
                    makeFallbackChecks = false;
                    break;
                }
                checksMap.set(placement, checks);
            }
            if (makeFallbackChecks) {
                var numberOfChecks = flipVariations ? 3 : 1;
                var _loop = function _loop(_i) {
                    var fittingPlacement = placements.find((function(placement) {
                        var checks = checksMap.get(placement);
                        if (checks) return checks.slice(0, _i).every((function(check) {
                            return check;
                        }));
                    }));
                    if (fittingPlacement) {
                        firstFittingPlacement = fittingPlacement;
                        return "break";
                    }
                };
                for (var _i = numberOfChecks; _i > 0; _i--) {
                    var _ret = _loop(_i);
                    if (_ret === "break") break;
                }
            }
            if (state.placement !== firstFittingPlacement) {
                state.modifiersData[name]._skip = true;
                state.placement = firstFittingPlacement;
                state.reset = true;
            }
        }
        const modifiers_flip = {
            name: "flip",
            enabled: true,
            phase: "main",
            fn: flip,
            requiresIfExists: [ "offset" ],
            data: {
                _skip: false
            }
        };
        function getAltAxis(axis) {
            return axis === "x" ? "y" : "x";
        }
        function within(min, value, max) {
            return math_max(min, math_min(value, max));
        }
        function withinMaxClamp(min, value, max) {
            var v = within(min, value, max);
            return v > max ? max : v;
        }
        function preventOverflow(_ref) {
            var state = _ref.state, options = _ref.options, name = _ref.name;
            var _options$mainAxis = options.mainAxis, checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis, _options$altAxis = options.altAxis, checkAltAxis = _options$altAxis === void 0 ? false : _options$altAxis, boundary = options.boundary, rootBoundary = options.rootBoundary, altBoundary = options.altBoundary, padding = options.padding, _options$tether = options.tether, tether = _options$tether === void 0 ? true : _options$tether, _options$tetherOffset = options.tetherOffset, tetherOffset = _options$tetherOffset === void 0 ? 0 : _options$tetherOffset;
            var overflow = detectOverflow(state, {
                boundary,
                rootBoundary,
                padding,
                altBoundary
            });
            var basePlacement = getBasePlacement(state.placement);
            var variation = getVariation(state.placement);
            var isBasePlacement = !variation;
            var mainAxis = getMainAxisFromPlacement(basePlacement);
            var altAxis = getAltAxis(mainAxis);
            var popperOffsets = state.modifiersData.popperOffsets;
            var referenceRect = state.rects.reference;
            var popperRect = state.rects.popper;
            var tetherOffsetValue = typeof tetherOffset === "function" ? tetherOffset(Object.assign({}, state.rects, {
                placement: state.placement
            })) : tetherOffset;
            var normalizedTetherOffsetValue = typeof tetherOffsetValue === "number" ? {
                mainAxis: tetherOffsetValue,
                altAxis: tetherOffsetValue
            } : Object.assign({
                mainAxis: 0,
                altAxis: 0
            }, tetherOffsetValue);
            var offsetModifierState = state.modifiersData.offset ? state.modifiersData.offset[state.placement] : null;
            var data = {
                x: 0,
                y: 0
            };
            if (!popperOffsets) return;
            if (checkMainAxis) {
                var _offsetModifierState$;
                var mainSide = mainAxis === "y" ? enums_top : left;
                var altSide = mainAxis === "y" ? bottom : right;
                var len = mainAxis === "y" ? "height" : "width";
                var offset = popperOffsets[mainAxis];
                var min = offset + overflow[mainSide];
                var max = offset - overflow[altSide];
                var additive = tether ? -popperRect[len] / 2 : 0;
                var minLen = variation === start ? referenceRect[len] : popperRect[len];
                var maxLen = variation === start ? -popperRect[len] : -referenceRect[len];
                var arrowElement = state.elements.arrow;
                var arrowRect = tether && arrowElement ? getLayoutRect(arrowElement) : {
                    width: 0,
                    height: 0
                };
                var arrowPaddingObject = state.modifiersData["arrow#persistent"] ? state.modifiersData["arrow#persistent"].padding : getFreshSideObject();
                var arrowPaddingMin = arrowPaddingObject[mainSide];
                var arrowPaddingMax = arrowPaddingObject[altSide];
                var arrowLen = within(0, referenceRect[len], arrowRect[len]);
                var minOffset = isBasePlacement ? referenceRect[len] / 2 - additive - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis : minLen - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis;
                var maxOffset = isBasePlacement ? -referenceRect[len] / 2 + additive + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis : maxLen + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis;
                var arrowOffsetParent = state.elements.arrow && getOffsetParent(state.elements.arrow);
                var clientOffset = arrowOffsetParent ? mainAxis === "y" ? arrowOffsetParent.clientTop || 0 : arrowOffsetParent.clientLeft || 0 : 0;
                var offsetModifierValue = (_offsetModifierState$ = offsetModifierState == null ? void 0 : offsetModifierState[mainAxis]) != null ? _offsetModifierState$ : 0;
                var tetherMin = offset + minOffset - offsetModifierValue - clientOffset;
                var tetherMax = offset + maxOffset - offsetModifierValue;
                var preventedOffset = within(tether ? math_min(min, tetherMin) : min, offset, tether ? math_max(max, tetherMax) : max);
                popperOffsets[mainAxis] = preventedOffset;
                data[mainAxis] = preventedOffset - offset;
            }
            if (checkAltAxis) {
                var _offsetModifierState$2;
                var _mainSide = mainAxis === "x" ? enums_top : left;
                var _altSide = mainAxis === "x" ? bottom : right;
                var _offset = popperOffsets[altAxis];
                var _len = altAxis === "y" ? "height" : "width";
                var _min = _offset + overflow[_mainSide];
                var _max = _offset - overflow[_altSide];
                var isOriginSide = [ enums_top, left ].indexOf(basePlacement) !== -1;
                var _offsetModifierValue = (_offsetModifierState$2 = offsetModifierState == null ? void 0 : offsetModifierState[altAxis]) != null ? _offsetModifierState$2 : 0;
                var _tetherMin = isOriginSide ? _min : _offset - referenceRect[_len] - popperRect[_len] - _offsetModifierValue + normalizedTetherOffsetValue.altAxis;
                var _tetherMax = isOriginSide ? _offset + referenceRect[_len] + popperRect[_len] - _offsetModifierValue - normalizedTetherOffsetValue.altAxis : _max;
                var _preventedOffset = tether && isOriginSide ? withinMaxClamp(_tetherMin, _offset, _tetherMax) : within(tether ? _tetherMin : _min, _offset, tether ? _tetherMax : _max);
                popperOffsets[altAxis] = _preventedOffset;
                data[altAxis] = _preventedOffset - _offset;
            }
            state.modifiersData[name] = data;
        }
        const modifiers_preventOverflow = {
            name: "preventOverflow",
            enabled: true,
            phase: "main",
            fn: preventOverflow,
            requiresIfExists: [ "offset" ]
        };
        var toPaddingObject = function toPaddingObject(padding, state) {
            padding = typeof padding === "function" ? padding(Object.assign({}, state.rects, {
                placement: state.placement
            })) : padding;
            return mergePaddingObject(typeof padding !== "number" ? padding : expandToHashMap(padding, basePlacements));
        };
        function arrow(_ref) {
            var _state$modifiersData$;
            var state = _ref.state, name = _ref.name, options = _ref.options;
            var arrowElement = state.elements.arrow;
            var popperOffsets = state.modifiersData.popperOffsets;
            var basePlacement = getBasePlacement(state.placement);
            var axis = getMainAxisFromPlacement(basePlacement);
            var isVertical = [ left, right ].indexOf(basePlacement) >= 0;
            var len = isVertical ? "height" : "width";
            if (!arrowElement || !popperOffsets) return;
            var paddingObject = toPaddingObject(options.padding, state);
            var arrowRect = getLayoutRect(arrowElement);
            var minProp = axis === "y" ? enums_top : left;
            var maxProp = axis === "y" ? bottom : right;
            var endDiff = state.rects.reference[len] + state.rects.reference[axis] - popperOffsets[axis] - state.rects.popper[len];
            var startDiff = popperOffsets[axis] - state.rects.reference[axis];
            var arrowOffsetParent = getOffsetParent(arrowElement);
            var clientSize = arrowOffsetParent ? axis === "y" ? arrowOffsetParent.clientHeight || 0 : arrowOffsetParent.clientWidth || 0 : 0;
            var centerToReference = endDiff / 2 - startDiff / 2;
            var min = paddingObject[minProp];
            var max = clientSize - arrowRect[len] - paddingObject[maxProp];
            var center = clientSize / 2 - arrowRect[len] / 2 + centerToReference;
            var offset = within(min, center, max);
            var axisProp = axis;
            state.modifiersData[name] = (_state$modifiersData$ = {}, _state$modifiersData$[axisProp] = offset, 
            _state$modifiersData$.centerOffset = offset - center, _state$modifiersData$);
        }
        function arrow_effect(_ref2) {
            var state = _ref2.state, options = _ref2.options;
            var _options$element = options.element, arrowElement = _options$element === void 0 ? "[data-popper-arrow]" : _options$element;
            if (arrowElement == null) return;
            if (typeof arrowElement === "string") {
                arrowElement = state.elements.popper.querySelector(arrowElement);
                if (!arrowElement) return;
            }
            if (!contains(state.elements.popper, arrowElement)) return;
            state.elements.arrow = arrowElement;
        }
        const modifiers_arrow = {
            name: "arrow",
            enabled: true,
            phase: "main",
            fn: arrow,
            effect: arrow_effect,
            requires: [ "popperOffsets" ],
            requiresIfExists: [ "preventOverflow" ]
        };
        function getSideOffsets(overflow, rect, preventedOffsets) {
            if (preventedOffsets === void 0) preventedOffsets = {
                x: 0,
                y: 0
            };
            return {
                top: overflow.top - rect.height - preventedOffsets.y,
                right: overflow.right - rect.width + preventedOffsets.x,
                bottom: overflow.bottom - rect.height + preventedOffsets.y,
                left: overflow.left - rect.width - preventedOffsets.x
            };
        }
        function isAnySideFullyClipped(overflow) {
            return [ enums_top, right, bottom, left ].some((function(side) {
                return overflow[side] >= 0;
            }));
        }
        function hide(_ref) {
            var state = _ref.state, name = _ref.name;
            var referenceRect = state.rects.reference;
            var popperRect = state.rects.popper;
            var preventedOffsets = state.modifiersData.preventOverflow;
            var referenceOverflow = detectOverflow(state, {
                elementContext: "reference"
            });
            var popperAltOverflow = detectOverflow(state, {
                altBoundary: true
            });
            var referenceClippingOffsets = getSideOffsets(referenceOverflow, referenceRect);
            var popperEscapeOffsets = getSideOffsets(popperAltOverflow, popperRect, preventedOffsets);
            var isReferenceHidden = isAnySideFullyClipped(referenceClippingOffsets);
            var hasPopperEscaped = isAnySideFullyClipped(popperEscapeOffsets);
            state.modifiersData[name] = {
                referenceClippingOffsets,
                popperEscapeOffsets,
                isReferenceHidden,
                hasPopperEscaped
            };
            state.attributes.popper = Object.assign({}, state.attributes.popper, {
                "data-popper-reference-hidden": isReferenceHidden,
                "data-popper-escaped": hasPopperEscaped
            });
        }
        const modifiers_hide = {
            name: "hide",
            enabled: true,
            phase: "main",
            requiresIfExists: [ "preventOverflow" ],
            fn: hide
        };
        var defaultModifiers = [ eventListeners, modifiers_popperOffsets, modifiers_computeStyles, modifiers_applyStyles, modifiers_offset, modifiers_flip, modifiers_preventOverflow, modifiers_arrow, modifiers_hide ];
        var popper_createPopper = popperGenerator({
            defaultModifiers
        });
        var BOX_CLASS = "tippy-box";
        var CONTENT_CLASS = "tippy-content";
        var BACKDROP_CLASS = "tippy-backdrop";
        var ARROW_CLASS = "tippy-arrow";
        var SVG_ARROW_CLASS = "tippy-svg-arrow";
        var TOUCH_OPTIONS = {
            passive: true,
            capture: true
        };
        var TIPPY_DEFAULT_APPEND_TO = function TIPPY_DEFAULT_APPEND_TO() {
            return document.body;
        };
        function getValueAtIndexOrReturn(value, index, defaultValue) {
            if (Array.isArray(value)) {
                var v = value[index];
                return v == null ? Array.isArray(defaultValue) ? defaultValue[index] : defaultValue : v;
            }
            return value;
        }
        function isType(value, type) {
            var str = {}.toString.call(value);
            return str.indexOf("[object") === 0 && str.indexOf(type + "]") > -1;
        }
        function invokeWithArgsOrReturn(value, args) {
            return typeof value === "function" ? value.apply(void 0, args) : value;
        }
        function tippy_esm_debounce(fn, ms) {
            if (ms === 0) return fn;
            var timeout;
            return function(arg) {
                clearTimeout(timeout);
                timeout = setTimeout((function() {
                    fn(arg);
                }), ms);
            };
        }
        function splitBySpaces(value) {
            return value.split(/\s+/).filter(Boolean);
        }
        function normalizeToArray(value) {
            return [].concat(value);
        }
        function pushIfUnique(arr, value) {
            if (arr.indexOf(value) === -1) arr.push(value);
        }
        function unique(arr) {
            return arr.filter((function(item, index) {
                return arr.indexOf(item) === index;
            }));
        }
        function tippy_esm_getBasePlacement(placement) {
            return placement.split("-")[0];
        }
        function arrayFrom(value) {
            return [].slice.call(value);
        }
        function removeUndefinedProps(obj) {
            return Object.keys(obj).reduce((function(acc, key) {
                if (obj[key] !== void 0) acc[key] = obj[key];
                return acc;
            }), {});
        }
        function div() {
            return document.createElement("div");
        }
        function tippy_esm_isElement(value) {
            return [ "Element", "Fragment" ].some((function(type) {
                return isType(value, type);
            }));
        }
        function isNodeList(value) {
            return isType(value, "NodeList");
        }
        function isMouseEvent(value) {
            return isType(value, "MouseEvent");
        }
        function isReferenceElement(value) {
            return !!(value && value._tippy && value._tippy.reference === value);
        }
        function getArrayOfElements(value) {
            if (tippy_esm_isElement(value)) return [ value ];
            if (isNodeList(value)) return arrayFrom(value);
            if (Array.isArray(value)) return value;
            return arrayFrom(document.querySelectorAll(value));
        }
        function setTransitionDuration(els, value) {
            els.forEach((function(el) {
                if (el) el.style.transitionDuration = value + "ms";
            }));
        }
        function setVisibilityState(els, state) {
            els.forEach((function(el) {
                if (el) el.setAttribute("data-state", state);
            }));
        }
        function getOwnerDocument(elementOrElements) {
            var _element$ownerDocumen;
            var _normalizeToArray = normalizeToArray(elementOrElements), element = _normalizeToArray[0];
            return element != null && (_element$ownerDocumen = element.ownerDocument) != null && _element$ownerDocumen.body ? element.ownerDocument : document;
        }
        function isCursorOutsideInteractiveBorder(popperTreeData, event) {
            var clientX = event.clientX, clientY = event.clientY;
            return popperTreeData.every((function(_ref) {
                var popperRect = _ref.popperRect, popperState = _ref.popperState, props = _ref.props;
                var interactiveBorder = props.interactiveBorder;
                var basePlacement = tippy_esm_getBasePlacement(popperState.placement);
                var offsetData = popperState.modifiersData.offset;
                if (!offsetData) return true;
                var topDistance = basePlacement === "bottom" ? offsetData.top.y : 0;
                var bottomDistance = basePlacement === "top" ? offsetData.bottom.y : 0;
                var leftDistance = basePlacement === "right" ? offsetData.left.x : 0;
                var rightDistance = basePlacement === "left" ? offsetData.right.x : 0;
                var exceedsTop = popperRect.top - clientY + topDistance > interactiveBorder;
                var exceedsBottom = clientY - popperRect.bottom - bottomDistance > interactiveBorder;
                var exceedsLeft = popperRect.left - clientX + leftDistance > interactiveBorder;
                var exceedsRight = clientX - popperRect.right - rightDistance > interactiveBorder;
                return exceedsTop || exceedsBottom || exceedsLeft || exceedsRight;
            }));
        }
        function updateTransitionEndListener(box, action, listener) {
            var method = action + "EventListener";
            [ "transitionend", "webkitTransitionEnd" ].forEach((function(event) {
                box[method](event, listener);
            }));
        }
        function actualContains(parent, child) {
            var target = child;
            while (target) {
                var _target$getRootNode;
                if (parent.contains(target)) return true;
                target = target.getRootNode == null ? void 0 : (_target$getRootNode = target.getRootNode()) == null ? void 0 : _target$getRootNode.host;
            }
            return false;
        }
        var currentInput = {
            isTouch: false
        };
        var lastMouseMoveTime = 0;
        function onDocumentTouchStart() {
            if (currentInput.isTouch) return;
            currentInput.isTouch = true;
            if (window.performance) document.addEventListener("mousemove", onDocumentMouseMove);
        }
        function onDocumentMouseMove() {
            var now = performance.now();
            if (now - lastMouseMoveTime < 20) {
                currentInput.isTouch = false;
                document.removeEventListener("mousemove", onDocumentMouseMove);
            }
            lastMouseMoveTime = now;
        }
        function onWindowBlur() {
            var activeElement = document.activeElement;
            if (isReferenceElement(activeElement)) {
                var instance = activeElement._tippy;
                if (activeElement.blur && !instance.state.isVisible) activeElement.blur();
            }
        }
        function bindGlobalEventListeners() {
            document.addEventListener("touchstart", onDocumentTouchStart, TOUCH_OPTIONS);
            window.addEventListener("blur", onWindowBlur);
        }
        var isBrowser = typeof window !== "undefined" && typeof document !== "undefined";
        var isIE11 = isBrowser ? !!window.msCrypto : false;
        if (false) ;
        var pluginProps = {
            animateFill: false,
            followCursor: false,
            inlinePositioning: false,
            sticky: false
        };
        var renderProps = {
            allowHTML: false,
            animation: "fade",
            arrow: true,
            content: "",
            inertia: false,
            maxWidth: 350,
            role: "tooltip",
            theme: "",
            zIndex: 9999
        };
        var defaultProps = Object.assign({
            appendTo: TIPPY_DEFAULT_APPEND_TO,
            aria: {
                content: "auto",
                expanded: "auto"
            },
            delay: 0,
            duration: [ 300, 250 ],
            getReferenceClientRect: null,
            hideOnClick: true,
            ignoreAttributes: false,
            interactive: false,
            interactiveBorder: 2,
            interactiveDebounce: 0,
            moveTransition: "",
            offset: [ 0, 10 ],
            onAfterUpdate: function onAfterUpdate() {},
            onBeforeUpdate: function onBeforeUpdate() {},
            onCreate: function onCreate() {},
            onDestroy: function onDestroy() {},
            onHidden: function onHidden() {},
            onHide: function onHide() {},
            onMount: function onMount() {},
            onShow: function onShow() {},
            onShown: function onShown() {},
            onTrigger: function onTrigger() {},
            onUntrigger: function onUntrigger() {},
            onClickOutside: function onClickOutside() {},
            placement: "top",
            plugins: [],
            popperOptions: {},
            render: null,
            showOnCreate: false,
            touch: true,
            trigger: "mouseenter focus",
            triggerTarget: null
        }, pluginProps, renderProps);
        var defaultKeys = Object.keys(defaultProps);
        var setDefaultProps = function setDefaultProps(partialProps) {
            if (false) ;
            var keys = Object.keys(partialProps);
            keys.forEach((function(key) {
                defaultProps[key] = partialProps[key];
            }));
        };
        function getExtendedPassedProps(passedProps) {
            var plugins = passedProps.plugins || [];
            var pluginProps = plugins.reduce((function(acc, plugin) {
                var name = plugin.name, defaultValue = plugin.defaultValue;
                if (name) {
                    var _name;
                    acc[name] = passedProps[name] !== void 0 ? passedProps[name] : (_name = defaultProps[name]) != null ? _name : defaultValue;
                }
                return acc;
            }), {});
            return Object.assign({}, passedProps, pluginProps);
        }
        function getDataAttributeProps(reference, plugins) {
            var propKeys = plugins ? Object.keys(getExtendedPassedProps(Object.assign({}, defaultProps, {
                plugins
            }))) : defaultKeys;
            var props = propKeys.reduce((function(acc, key) {
                var valueAsString = (reference.getAttribute("data-tippy-" + key) || "").trim();
                if (!valueAsString) return acc;
                if (key === "content") acc[key] = valueAsString; else try {
                    acc[key] = JSON.parse(valueAsString);
                } catch (e) {
                    acc[key] = valueAsString;
                }
                return acc;
            }), {});
            return props;
        }
        function evaluateProps(reference, props) {
            var out = Object.assign({}, props, {
                content: invokeWithArgsOrReturn(props.content, [ reference ])
            }, props.ignoreAttributes ? {} : getDataAttributeProps(reference, props.plugins));
            out.aria = Object.assign({}, defaultProps.aria, out.aria);
            out.aria = {
                expanded: out.aria.expanded === "auto" ? props.interactive : out.aria.expanded,
                content: out.aria.content === "auto" ? props.interactive ? null : "describedby" : out.aria.content
            };
            return out;
        }
        var innerHTML = function innerHTML() {
            return "innerHTML";
        };
        function dangerouslySetInnerHTML(element, html) {
            element[innerHTML()] = html;
        }
        function createArrowElement(value) {
            var arrow = div();
            if (value === true) arrow.className = ARROW_CLASS; else {
                arrow.className = SVG_ARROW_CLASS;
                if (tippy_esm_isElement(value)) arrow.appendChild(value); else dangerouslySetInnerHTML(arrow, value);
            }
            return arrow;
        }
        function setContent(content, props) {
            if (tippy_esm_isElement(props.content)) {
                dangerouslySetInnerHTML(content, "");
                content.appendChild(props.content);
            } else if (typeof props.content !== "function") if (props.allowHTML) dangerouslySetInnerHTML(content, props.content); else content.textContent = props.content;
        }
        function getChildren(popper) {
            var box = popper.firstElementChild;
            var boxChildren = arrayFrom(box.children);
            return {
                box,
                content: boxChildren.find((function(node) {
                    return node.classList.contains(CONTENT_CLASS);
                })),
                arrow: boxChildren.find((function(node) {
                    return node.classList.contains(ARROW_CLASS) || node.classList.contains(SVG_ARROW_CLASS);
                })),
                backdrop: boxChildren.find((function(node) {
                    return node.classList.contains(BACKDROP_CLASS);
                }))
            };
        }
        function render(instance) {
            var popper = div();
            var box = div();
            box.className = BOX_CLASS;
            box.setAttribute("data-state", "hidden");
            box.setAttribute("tabindex", "-1");
            var content = div();
            content.className = CONTENT_CLASS;
            content.setAttribute("data-state", "hidden");
            setContent(content, instance.props);
            popper.appendChild(box);
            box.appendChild(content);
            onUpdate(instance.props, instance.props);
            function onUpdate(prevProps, nextProps) {
                var _getChildren = getChildren(popper), box = _getChildren.box, content = _getChildren.content, arrow = _getChildren.arrow;
                if (nextProps.theme) box.setAttribute("data-theme", nextProps.theme); else box.removeAttribute("data-theme");
                if (typeof nextProps.animation === "string") box.setAttribute("data-animation", nextProps.animation); else box.removeAttribute("data-animation");
                if (nextProps.inertia) box.setAttribute("data-inertia", ""); else box.removeAttribute("data-inertia");
                box.style.maxWidth = typeof nextProps.maxWidth === "number" ? nextProps.maxWidth + "px" : nextProps.maxWidth;
                if (nextProps.role) box.setAttribute("role", nextProps.role); else box.removeAttribute("role");
                if (prevProps.content !== nextProps.content || prevProps.allowHTML !== nextProps.allowHTML) setContent(content, instance.props);
                if (nextProps.arrow) {
                    if (!arrow) box.appendChild(createArrowElement(nextProps.arrow)); else if (prevProps.arrow !== nextProps.arrow) {
                        box.removeChild(arrow);
                        box.appendChild(createArrowElement(nextProps.arrow));
                    }
                } else if (arrow) box.removeChild(arrow);
            }
            return {
                popper,
                onUpdate
            };
        }
        render.$$tippy = true;
        var idCounter = 1;
        var mouseMoveListeners = [];
        var mountedInstances = [];
        function createTippy(reference, passedProps) {
            var props = evaluateProps(reference, Object.assign({}, defaultProps, getExtendedPassedProps(removeUndefinedProps(passedProps))));
            var showTimeout;
            var hideTimeout;
            var scheduleHideAnimationFrame;
            var isVisibleFromClick = false;
            var didHideDueToDocumentMouseDown = false;
            var didTouchMove = false;
            var ignoreOnFirstUpdate = false;
            var lastTriggerEvent;
            var currentTransitionEndListener;
            var onFirstUpdate;
            var listeners = [];
            var debouncedOnMouseMove = tippy_esm_debounce(onMouseMove, props.interactiveDebounce);
            var currentTarget;
            var id = idCounter++;
            var popperInstance = null;
            var plugins = unique(props.plugins);
            var state = {
                isEnabled: true,
                isVisible: false,
                isDestroyed: false,
                isMounted: false,
                isShown: false
            };
            var instance = {
                id,
                reference,
                popper: div(),
                popperInstance,
                props,
                state,
                plugins,
                clearDelayTimeouts,
                setProps,
                setContent,
                show,
                hide,
                hideWithInteractivity,
                enable,
                disable,
                unmount,
                destroy
            };
            if (!props.render) {
                if (false) ;
                return instance;
            }
            var _props$render = props.render(instance), popper = _props$render.popper, onUpdate = _props$render.onUpdate;
            popper.setAttribute("data-tippy-root", "");
            popper.id = "tippy-" + instance.id;
            instance.popper = popper;
            reference._tippy = instance;
            popper._tippy = instance;
            var pluginsHooks = plugins.map((function(plugin) {
                return plugin.fn(instance);
            }));
            var hasAriaExpanded = reference.hasAttribute("aria-expanded");
            addListeners();
            handleAriaExpandedAttribute();
            handleStyles();
            invokeHook("onCreate", [ instance ]);
            if (props.showOnCreate) scheduleShow();
            popper.addEventListener("mouseenter", (function() {
                if (instance.props.interactive && instance.state.isVisible) instance.clearDelayTimeouts();
            }));
            popper.addEventListener("mouseleave", (function() {
                if (instance.props.interactive && instance.props.trigger.indexOf("mouseenter") >= 0) getDocument().addEventListener("mousemove", debouncedOnMouseMove);
            }));
            return instance;
            function getNormalizedTouchSettings() {
                var touch = instance.props.touch;
                return Array.isArray(touch) ? touch : [ touch, 0 ];
            }
            function getIsCustomTouchBehavior() {
                return getNormalizedTouchSettings()[0] === "hold";
            }
            function getIsDefaultRenderFn() {
                var _instance$props$rende;
                return !!((_instance$props$rende = instance.props.render) != null && _instance$props$rende.$$tippy);
            }
            function getCurrentTarget() {
                return currentTarget || reference;
            }
            function getDocument() {
                var parent = getCurrentTarget().parentNode;
                return parent ? getOwnerDocument(parent) : document;
            }
            function getDefaultTemplateChildren() {
                return getChildren(popper);
            }
            function getDelay(isShow) {
                if (instance.state.isMounted && !instance.state.isVisible || currentInput.isTouch || lastTriggerEvent && lastTriggerEvent.type === "focus") return 0;
                return getValueAtIndexOrReturn(instance.props.delay, isShow ? 0 : 1, defaultProps.delay);
            }
            function handleStyles(fromHide) {
                if (fromHide === void 0) fromHide = false;
                popper.style.pointerEvents = instance.props.interactive && !fromHide ? "" : "none";
                popper.style.zIndex = "" + instance.props.zIndex;
            }
            function invokeHook(hook, args, shouldInvokePropsHook) {
                if (shouldInvokePropsHook === void 0) shouldInvokePropsHook = true;
                pluginsHooks.forEach((function(pluginHooks) {
                    if (pluginHooks[hook]) pluginHooks[hook].apply(pluginHooks, args);
                }));
                if (shouldInvokePropsHook) {
                    var _instance$props;
                    (_instance$props = instance.props)[hook].apply(_instance$props, args);
                }
            }
            function handleAriaContentAttribute() {
                var aria = instance.props.aria;
                if (!aria.content) return;
                var attr = "aria-" + aria.content;
                var id = popper.id;
                var nodes = normalizeToArray(instance.props.triggerTarget || reference);
                nodes.forEach((function(node) {
                    var currentValue = node.getAttribute(attr);
                    if (instance.state.isVisible) node.setAttribute(attr, currentValue ? currentValue + " " + id : id); else {
                        var nextValue = currentValue && currentValue.replace(id, "").trim();
                        if (nextValue) node.setAttribute(attr, nextValue); else node.removeAttribute(attr);
                    }
                }));
            }
            function handleAriaExpandedAttribute() {
                if (hasAriaExpanded || !instance.props.aria.expanded) return;
                var nodes = normalizeToArray(instance.props.triggerTarget || reference);
                nodes.forEach((function(node) {
                    if (instance.props.interactive) node.setAttribute("aria-expanded", instance.state.isVisible && node === getCurrentTarget() ? "true" : "false"); else node.removeAttribute("aria-expanded");
                }));
            }
            function cleanupInteractiveMouseListeners() {
                getDocument().removeEventListener("mousemove", debouncedOnMouseMove);
                mouseMoveListeners = mouseMoveListeners.filter((function(listener) {
                    return listener !== debouncedOnMouseMove;
                }));
            }
            function onDocumentPress(event) {
                if (currentInput.isTouch) if (didTouchMove || event.type === "mousedown") return;
                var actualTarget = event.composedPath && event.composedPath()[0] || event.target;
                if (instance.props.interactive && actualContains(popper, actualTarget)) return;
                if (normalizeToArray(instance.props.triggerTarget || reference).some((function(el) {
                    return actualContains(el, actualTarget);
                }))) {
                    if (currentInput.isTouch) return;
                    if (instance.state.isVisible && instance.props.trigger.indexOf("click") >= 0) return;
                } else invokeHook("onClickOutside", [ instance, event ]);
                if (instance.props.hideOnClick === true) {
                    instance.clearDelayTimeouts();
                    instance.hide();
                    didHideDueToDocumentMouseDown = true;
                    setTimeout((function() {
                        didHideDueToDocumentMouseDown = false;
                    }));
                    if (!instance.state.isMounted) removeDocumentPress();
                }
            }
            function onTouchMove() {
                didTouchMove = true;
            }
            function onTouchStart() {
                didTouchMove = false;
            }
            function addDocumentPress() {
                var doc = getDocument();
                doc.addEventListener("mousedown", onDocumentPress, true);
                doc.addEventListener("touchend", onDocumentPress, TOUCH_OPTIONS);
                doc.addEventListener("touchstart", onTouchStart, TOUCH_OPTIONS);
                doc.addEventListener("touchmove", onTouchMove, TOUCH_OPTIONS);
            }
            function removeDocumentPress() {
                var doc = getDocument();
                doc.removeEventListener("mousedown", onDocumentPress, true);
                doc.removeEventListener("touchend", onDocumentPress, TOUCH_OPTIONS);
                doc.removeEventListener("touchstart", onTouchStart, TOUCH_OPTIONS);
                doc.removeEventListener("touchmove", onTouchMove, TOUCH_OPTIONS);
            }
            function onTransitionedOut(duration, callback) {
                onTransitionEnd(duration, (function() {
                    if (!instance.state.isVisible && popper.parentNode && popper.parentNode.contains(popper)) callback();
                }));
            }
            function onTransitionedIn(duration, callback) {
                onTransitionEnd(duration, callback);
            }
            function onTransitionEnd(duration, callback) {
                var box = getDefaultTemplateChildren().box;
                function listener(event) {
                    if (event.target === box) {
                        updateTransitionEndListener(box, "remove", listener);
                        callback();
                    }
                }
                if (duration === 0) return callback();
                updateTransitionEndListener(box, "remove", currentTransitionEndListener);
                updateTransitionEndListener(box, "add", listener);
                currentTransitionEndListener = listener;
            }
            function on(eventType, handler, options) {
                if (options === void 0) options = false;
                var nodes = normalizeToArray(instance.props.triggerTarget || reference);
                nodes.forEach((function(node) {
                    node.addEventListener(eventType, handler, options);
                    listeners.push({
                        node,
                        eventType,
                        handler,
                        options
                    });
                }));
            }
            function addListeners() {
                if (getIsCustomTouchBehavior()) {
                    on("touchstart", onTrigger, {
                        passive: true
                    });
                    on("touchend", onMouseLeave, {
                        passive: true
                    });
                }
                splitBySpaces(instance.props.trigger).forEach((function(eventType) {
                    if (eventType === "manual") return;
                    on(eventType, onTrigger);
                    switch (eventType) {
                      case "mouseenter":
                        on("mouseleave", onMouseLeave);
                        break;

                      case "focus":
                        on(isIE11 ? "focusout" : "blur", onBlurOrFocusOut);
                        break;

                      case "focusin":
                        on("focusout", onBlurOrFocusOut);
                        break;
                    }
                }));
            }
            function removeListeners() {
                listeners.forEach((function(_ref) {
                    var node = _ref.node, eventType = _ref.eventType, handler = _ref.handler, options = _ref.options;
                    node.removeEventListener(eventType, handler, options);
                }));
                listeners = [];
            }
            function onTrigger(event) {
                var _lastTriggerEvent;
                var shouldScheduleClickHide = false;
                if (!instance.state.isEnabled || isEventListenerStopped(event) || didHideDueToDocumentMouseDown) return;
                var wasFocused = ((_lastTriggerEvent = lastTriggerEvent) == null ? void 0 : _lastTriggerEvent.type) === "focus";
                lastTriggerEvent = event;
                currentTarget = event.currentTarget;
                handleAriaExpandedAttribute();
                if (!instance.state.isVisible && isMouseEvent(event)) mouseMoveListeners.forEach((function(listener) {
                    return listener(event);
                }));
                if (event.type === "click" && (instance.props.trigger.indexOf("mouseenter") < 0 || isVisibleFromClick) && instance.props.hideOnClick !== false && instance.state.isVisible) shouldScheduleClickHide = true; else scheduleShow(event);
                if (event.type === "click") isVisibleFromClick = !shouldScheduleClickHide;
                if (shouldScheduleClickHide && !wasFocused) scheduleHide(event);
            }
            function onMouseMove(event) {
                var target = event.target;
                var isCursorOverReferenceOrPopper = getCurrentTarget().contains(target) || popper.contains(target);
                if (event.type === "mousemove" && isCursorOverReferenceOrPopper) return;
                var popperTreeData = getNestedPopperTree().concat(popper).map((function(popper) {
                    var _instance$popperInsta;
                    var instance = popper._tippy;
                    var state = (_instance$popperInsta = instance.popperInstance) == null ? void 0 : _instance$popperInsta.state;
                    if (state) return {
                        popperRect: popper.getBoundingClientRect(),
                        popperState: state,
                        props
                    };
                    return null;
                })).filter(Boolean);
                if (isCursorOutsideInteractiveBorder(popperTreeData, event)) {
                    cleanupInteractiveMouseListeners();
                    scheduleHide(event);
                }
            }
            function onMouseLeave(event) {
                var shouldBail = isEventListenerStopped(event) || instance.props.trigger.indexOf("click") >= 0 && isVisibleFromClick;
                if (shouldBail) return;
                if (instance.props.interactive) {
                    instance.hideWithInteractivity(event);
                    return;
                }
                scheduleHide(event);
            }
            function onBlurOrFocusOut(event) {
                if (instance.props.trigger.indexOf("focusin") < 0 && event.target !== getCurrentTarget()) return;
                if (instance.props.interactive && event.relatedTarget && popper.contains(event.relatedTarget)) return;
                scheduleHide(event);
            }
            function isEventListenerStopped(event) {
                return currentInput.isTouch ? getIsCustomTouchBehavior() !== event.type.indexOf("touch") >= 0 : false;
            }
            function createPopperInstance() {
                destroyPopperInstance();
                var _instance$props2 = instance.props, popperOptions = _instance$props2.popperOptions, placement = _instance$props2.placement, offset = _instance$props2.offset, getReferenceClientRect = _instance$props2.getReferenceClientRect, moveTransition = _instance$props2.moveTransition;
                var arrow = getIsDefaultRenderFn() ? getChildren(popper).arrow : null;
                var computedReference = getReferenceClientRect ? {
                    getBoundingClientRect: getReferenceClientRect,
                    contextElement: getReferenceClientRect.contextElement || getCurrentTarget()
                } : reference;
                var tippyModifier = {
                    name: "$$tippy",
                    enabled: true,
                    phase: "beforeWrite",
                    requires: [ "computeStyles" ],
                    fn: function fn(_ref2) {
                        var state = _ref2.state;
                        if (getIsDefaultRenderFn()) {
                            var _getDefaultTemplateCh = getDefaultTemplateChildren(), box = _getDefaultTemplateCh.box;
                            [ "placement", "reference-hidden", "escaped" ].forEach((function(attr) {
                                if (attr === "placement") box.setAttribute("data-placement", state.placement); else if (state.attributes.popper["data-popper-" + attr]) box.setAttribute("data-" + attr, ""); else box.removeAttribute("data-" + attr);
                            }));
                            state.attributes.popper = {};
                        }
                    }
                };
                var modifiers = [ {
                    name: "offset",
                    options: {
                        offset
                    }
                }, {
                    name: "preventOverflow",
                    options: {
                        padding: {
                            top: 2,
                            bottom: 2,
                            left: 5,
                            right: 5
                        }
                    }
                }, {
                    name: "flip",
                    options: {
                        padding: 5
                    }
                }, {
                    name: "computeStyles",
                    options: {
                        adaptive: !moveTransition
                    }
                }, tippyModifier ];
                if (getIsDefaultRenderFn() && arrow) modifiers.push({
                    name: "arrow",
                    options: {
                        element: arrow,
                        padding: 3
                    }
                });
                modifiers.push.apply(modifiers, (popperOptions == null ? void 0 : popperOptions.modifiers) || []);
                instance.popperInstance = popper_createPopper(computedReference, popper, Object.assign({}, popperOptions, {
                    placement,
                    onFirstUpdate,
                    modifiers
                }));
            }
            function destroyPopperInstance() {
                if (instance.popperInstance) {
                    instance.popperInstance.destroy();
                    instance.popperInstance = null;
                }
            }
            function mount() {
                var appendTo = instance.props.appendTo;
                var parentNode;
                var node = getCurrentTarget();
                if (instance.props.interactive && appendTo === TIPPY_DEFAULT_APPEND_TO || appendTo === "parent") parentNode = node.parentNode; else parentNode = invokeWithArgsOrReturn(appendTo, [ node ]);
                if (!parentNode.contains(popper)) parentNode.appendChild(popper);
                instance.state.isMounted = true;
                createPopperInstance();
                if (false) ;
            }
            function getNestedPopperTree() {
                return arrayFrom(popper.querySelectorAll("[data-tippy-root]"));
            }
            function scheduleShow(event) {
                instance.clearDelayTimeouts();
                if (event) invokeHook("onTrigger", [ instance, event ]);
                addDocumentPress();
                var delay = getDelay(true);
                var _getNormalizedTouchSe = getNormalizedTouchSettings(), touchValue = _getNormalizedTouchSe[0], touchDelay = _getNormalizedTouchSe[1];
                if (currentInput.isTouch && touchValue === "hold" && touchDelay) delay = touchDelay;
                if (delay) showTimeout = setTimeout((function() {
                    instance.show();
                }), delay); else instance.show();
            }
            function scheduleHide(event) {
                instance.clearDelayTimeouts();
                invokeHook("onUntrigger", [ instance, event ]);
                if (!instance.state.isVisible) {
                    removeDocumentPress();
                    return;
                }
                if (instance.props.trigger.indexOf("mouseenter") >= 0 && instance.props.trigger.indexOf("click") >= 0 && [ "mouseleave", "mousemove" ].indexOf(event.type) >= 0 && isVisibleFromClick) return;
                var delay = getDelay(false);
                if (delay) hideTimeout = setTimeout((function() {
                    if (instance.state.isVisible) instance.hide();
                }), delay); else scheduleHideAnimationFrame = requestAnimationFrame((function() {
                    instance.hide();
                }));
            }
            function enable() {
                instance.state.isEnabled = true;
            }
            function disable() {
                instance.hide();
                instance.state.isEnabled = false;
            }
            function clearDelayTimeouts() {
                clearTimeout(showTimeout);
                clearTimeout(hideTimeout);
                cancelAnimationFrame(scheduleHideAnimationFrame);
            }
            function setProps(partialProps) {
                if (false) ;
                if (instance.state.isDestroyed) return;
                invokeHook("onBeforeUpdate", [ instance, partialProps ]);
                removeListeners();
                var prevProps = instance.props;
                var nextProps = evaluateProps(reference, Object.assign({}, prevProps, removeUndefinedProps(partialProps), {
                    ignoreAttributes: true
                }));
                instance.props = nextProps;
                addListeners();
                if (prevProps.interactiveDebounce !== nextProps.interactiveDebounce) {
                    cleanupInteractiveMouseListeners();
                    debouncedOnMouseMove = tippy_esm_debounce(onMouseMove, nextProps.interactiveDebounce);
                }
                if (prevProps.triggerTarget && !nextProps.triggerTarget) normalizeToArray(prevProps.triggerTarget).forEach((function(node) {
                    node.removeAttribute("aria-expanded");
                })); else if (nextProps.triggerTarget) reference.removeAttribute("aria-expanded");
                handleAriaExpandedAttribute();
                handleStyles();
                if (onUpdate) onUpdate(prevProps, nextProps);
                if (instance.popperInstance) {
                    createPopperInstance();
                    getNestedPopperTree().forEach((function(nestedPopper) {
                        requestAnimationFrame(nestedPopper._tippy.popperInstance.forceUpdate);
                    }));
                }
                invokeHook("onAfterUpdate", [ instance, partialProps ]);
            }
            function setContent(content) {
                instance.setProps({
                    content
                });
            }
            function show() {
                if (false) ;
                var isAlreadyVisible = instance.state.isVisible;
                var isDestroyed = instance.state.isDestroyed;
                var isDisabled = !instance.state.isEnabled;
                var isTouchAndTouchDisabled = currentInput.isTouch && !instance.props.touch;
                var duration = getValueAtIndexOrReturn(instance.props.duration, 0, defaultProps.duration);
                if (isAlreadyVisible || isDestroyed || isDisabled || isTouchAndTouchDisabled) return;
                if (getCurrentTarget().hasAttribute("disabled")) return;
                invokeHook("onShow", [ instance ], false);
                if (instance.props.onShow(instance) === false) return;
                instance.state.isVisible = true;
                if (getIsDefaultRenderFn()) popper.style.visibility = "visible";
                handleStyles();
                addDocumentPress();
                if (!instance.state.isMounted) popper.style.transition = "none";
                if (getIsDefaultRenderFn()) {
                    var _getDefaultTemplateCh2 = getDefaultTemplateChildren(), box = _getDefaultTemplateCh2.box, content = _getDefaultTemplateCh2.content;
                    setTransitionDuration([ box, content ], 0);
                }
                onFirstUpdate = function onFirstUpdate() {
                    var _instance$popperInsta2;
                    if (!instance.state.isVisible || ignoreOnFirstUpdate) return;
                    ignoreOnFirstUpdate = true;
                    void popper.offsetHeight;
                    popper.style.transition = instance.props.moveTransition;
                    if (getIsDefaultRenderFn() && instance.props.animation) {
                        var _getDefaultTemplateCh3 = getDefaultTemplateChildren(), _box = _getDefaultTemplateCh3.box, _content = _getDefaultTemplateCh3.content;
                        setTransitionDuration([ _box, _content ], duration);
                        setVisibilityState([ _box, _content ], "visible");
                    }
                    handleAriaContentAttribute();
                    handleAriaExpandedAttribute();
                    pushIfUnique(mountedInstances, instance);
                    (_instance$popperInsta2 = instance.popperInstance) == null ? void 0 : _instance$popperInsta2.forceUpdate();
                    invokeHook("onMount", [ instance ]);
                    if (instance.props.animation && getIsDefaultRenderFn()) onTransitionedIn(duration, (function() {
                        instance.state.isShown = true;
                        invokeHook("onShown", [ instance ]);
                    }));
                };
                mount();
            }
            function hide() {
                if (false) ;
                var isAlreadyHidden = !instance.state.isVisible;
                var isDestroyed = instance.state.isDestroyed;
                var isDisabled = !instance.state.isEnabled;
                var duration = getValueAtIndexOrReturn(instance.props.duration, 1, defaultProps.duration);
                if (isAlreadyHidden || isDestroyed || isDisabled) return;
                invokeHook("onHide", [ instance ], false);
                if (instance.props.onHide(instance) === false) return;
                instance.state.isVisible = false;
                instance.state.isShown = false;
                ignoreOnFirstUpdate = false;
                isVisibleFromClick = false;
                if (getIsDefaultRenderFn()) popper.style.visibility = "hidden";
                cleanupInteractiveMouseListeners();
                removeDocumentPress();
                handleStyles(true);
                if (getIsDefaultRenderFn()) {
                    var _getDefaultTemplateCh4 = getDefaultTemplateChildren(), box = _getDefaultTemplateCh4.box, content = _getDefaultTemplateCh4.content;
                    if (instance.props.animation) {
                        setTransitionDuration([ box, content ], duration);
                        setVisibilityState([ box, content ], "hidden");
                    }
                }
                handleAriaContentAttribute();
                handleAriaExpandedAttribute();
                if (instance.props.animation) {
                    if (getIsDefaultRenderFn()) onTransitionedOut(duration, instance.unmount);
                } else instance.unmount();
            }
            function hideWithInteractivity(event) {
                if (false) ;
                getDocument().addEventListener("mousemove", debouncedOnMouseMove);
                pushIfUnique(mouseMoveListeners, debouncedOnMouseMove);
                debouncedOnMouseMove(event);
            }
            function unmount() {
                if (false) ;
                if (instance.state.isVisible) instance.hide();
                if (!instance.state.isMounted) return;
                destroyPopperInstance();
                getNestedPopperTree().forEach((function(nestedPopper) {
                    nestedPopper._tippy.unmount();
                }));
                if (popper.parentNode) popper.parentNode.removeChild(popper);
                mountedInstances = mountedInstances.filter((function(i) {
                    return i !== instance;
                }));
                instance.state.isMounted = false;
                invokeHook("onHidden", [ instance ]);
            }
            function destroy() {
                if (false) ;
                if (instance.state.isDestroyed) return;
                instance.clearDelayTimeouts();
                instance.unmount();
                removeListeners();
                delete reference._tippy;
                instance.state.isDestroyed = true;
                invokeHook("onDestroy", [ instance ]);
            }
        }
        function tippy(targets, optionalProps) {
            if (optionalProps === void 0) optionalProps = {};
            var plugins = defaultProps.plugins.concat(optionalProps.plugins || []);
            if (false) ;
            bindGlobalEventListeners();
            var passedProps = Object.assign({}, optionalProps, {
                plugins
            });
            var elements = getArrayOfElements(targets);
            if (false) ;
            var instances = elements.reduce((function(acc, reference) {
                var instance = reference && createTippy(reference, passedProps);
                if (instance) acc.push(instance);
                return acc;
            }), []);
            return tippy_esm_isElement(targets) ? instances[0] : instances;
        }
        tippy.defaultProps = defaultProps;
        tippy.setDefaultProps = setDefaultProps;
        tippy.currentInput = currentInput;
        Object.assign({}, modifiers_applyStyles, {
            effect: function effect(_ref) {
                var state = _ref.state;
                var initialStyles = {
                    popper: {
                        position: state.options.strategy,
                        left: "0",
                        top: "0",
                        margin: "0"
                    },
                    arrow: {
                        position: "absolute"
                    },
                    reference: {}
                };
                Object.assign(state.elements.popper.style, initialStyles.popper);
                state.styles = initialStyles;
                if (state.elements.arrow) Object.assign(state.elements.arrow.style, initialStyles.arrow);
            }
        });
        tippy.setDefaultProps({
            render
        });
        const tippy_esm = tippy;
        tippy_esm("[data-tippy-small]", {
            arrow: true,
            content(reference) {
                return reference.getAttribute("data-tippy-content");
            },
            theme: "small",
            animation: "shift-away",
            allowHTML: true
        });
        tippy_esm("[data-tippy-medium]", {
            content(reference) {
                const contentId = reference.getAttribute("data-tippy-medium");
                const contentElement = document.querySelector(`#tooltip-contents #${contentId}`);
                return contentElement ? contentElement.innerHTML : "Контент не найден";
            },
            theme: "small",
            animation: "shift-away",
            allowHTML: true,
            maxWidth: 400
        });
        function isObject(value) {
            var type = typeof value;
            return value != null && (type == "object" || type == "function");
        }
        const lodash_es_isObject = isObject;
        var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
        const _freeGlobal = freeGlobal;
        var freeSelf = typeof self == "object" && self && self.Object === Object && self;
        var root = _freeGlobal || freeSelf || Function("return this")();
        const _root = root;
        var now = function() {
            return _root.Date.now();
        };
        const lodash_es_now = now;
        var reWhitespace = /\s/;
        function trimmedEndIndex(string) {
            var index = string.length;
            while (index-- && reWhitespace.test(string.charAt(index))) ;
            return index;
        }
        const _trimmedEndIndex = trimmedEndIndex;
        var reTrimStart = /^\s+/;
        function baseTrim(string) {
            return string ? string.slice(0, _trimmedEndIndex(string) + 1).replace(reTrimStart, "") : string;
        }
        const _baseTrim = baseTrim;
        var _Symbol_Symbol = _root.Symbol;
        const _Symbol = _Symbol_Symbol;
        var objectProto = Object.prototype;
        var _getRawTag_hasOwnProperty = objectProto.hasOwnProperty;
        var nativeObjectToString = objectProto.toString;
        var symToStringTag = _Symbol ? _Symbol.toStringTag : void 0;
        function getRawTag(value) {
            var isOwn = _getRawTag_hasOwnProperty.call(value, symToStringTag), tag = value[symToStringTag];
            try {
                value[symToStringTag] = void 0;
                var unmasked = true;
            } catch (e) {}
            var result = nativeObjectToString.call(value);
            if (unmasked) if (isOwn) value[symToStringTag] = tag; else delete value[symToStringTag];
            return result;
        }
        const _getRawTag = getRawTag;
        var _objectToString_objectProto = Object.prototype;
        var _objectToString_nativeObjectToString = _objectToString_objectProto.toString;
        function objectToString(value) {
            return _objectToString_nativeObjectToString.call(value);
        }
        const _objectToString = objectToString;
        var nullTag = "[object Null]", undefinedTag = "[object Undefined]";
        var _baseGetTag_symToStringTag = _Symbol ? _Symbol.toStringTag : void 0;
        function baseGetTag(value) {
            if (value == null) return value === void 0 ? undefinedTag : nullTag;
            return _baseGetTag_symToStringTag && _baseGetTag_symToStringTag in Object(value) ? _getRawTag(value) : _objectToString(value);
        }
        const _baseGetTag = baseGetTag;
        function isObjectLike(value) {
            return value != null && typeof value == "object";
        }
        const lodash_es_isObjectLike = isObjectLike;
        var symbolTag = "[object Symbol]";
        function isSymbol(value) {
            return typeof value == "symbol" || lodash_es_isObjectLike(value) && _baseGetTag(value) == symbolTag;
        }
        const lodash_es_isSymbol = isSymbol;
        var NAN = 0 / 0;
        var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
        var reIsBinary = /^0b[01]+$/i;
        var reIsOctal = /^0o[0-7]+$/i;
        var freeParseInt = parseInt;
        function toNumber(value) {
            if (typeof value == "number") return value;
            if (lodash_es_isSymbol(value)) return NAN;
            if (lodash_es_isObject(value)) {
                var other = typeof value.valueOf == "function" ? value.valueOf() : value;
                value = lodash_es_isObject(other) ? other + "" : other;
            }
            if (typeof value != "string") return value === 0 ? value : +value;
            value = _baseTrim(value);
            var isBinary = reIsBinary.test(value);
            return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
        }
        const lodash_es_toNumber = toNumber;
        var FUNC_ERROR_TEXT = "Expected a function";
        var nativeMax = Math.max, nativeMin = Math.min;
        function debounce_debounce(func, wait, options) {
            var lastArgs, lastThis, maxWait, result, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
            if (typeof func != "function") throw new TypeError(FUNC_ERROR_TEXT);
            wait = lodash_es_toNumber(wait) || 0;
            if (lodash_es_isObject(options)) {
                leading = !!options.leading;
                maxing = "maxWait" in options;
                maxWait = maxing ? nativeMax(lodash_es_toNumber(options.maxWait) || 0, wait) : maxWait;
                trailing = "trailing" in options ? !!options.trailing : trailing;
            }
            function invokeFunc(time) {
                var args = lastArgs, thisArg = lastThis;
                lastArgs = lastThis = void 0;
                lastInvokeTime = time;
                result = func.apply(thisArg, args);
                return result;
            }
            function leadingEdge(time) {
                lastInvokeTime = time;
                timerId = setTimeout(timerExpired, wait);
                return leading ? invokeFunc(time) : result;
            }
            function remainingWait(time) {
                var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, timeWaiting = wait - timeSinceLastCall;
                return maxing ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
            }
            function shouldInvoke(time) {
                var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
                return lastCallTime === void 0 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
            }
            function timerExpired() {
                var time = lodash_es_now();
                if (shouldInvoke(time)) return trailingEdge(time);
                timerId = setTimeout(timerExpired, remainingWait(time));
            }
            function trailingEdge(time) {
                timerId = void 0;
                if (trailing && lastArgs) return invokeFunc(time);
                lastArgs = lastThis = void 0;
                return result;
            }
            function cancel() {
                if (timerId !== void 0) clearTimeout(timerId);
                lastInvokeTime = 0;
                lastArgs = lastCallTime = lastThis = timerId = void 0;
            }
            function flush() {
                return timerId === void 0 ? result : trailingEdge(lodash_es_now());
            }
            function debounced() {
                var time = lodash_es_now(), isInvoking = shouldInvoke(time);
                lastArgs = arguments;
                lastThis = this;
                lastCallTime = time;
                if (isInvoking) {
                    if (timerId === void 0) return leadingEdge(lastCallTime);
                    if (maxing) {
                        clearTimeout(timerId);
                        timerId = setTimeout(timerExpired, wait);
                        return invokeFunc(lastCallTime);
                    }
                }
                if (timerId === void 0) timerId = setTimeout(timerExpired, wait);
                return result;
            }
            debounced.cancel = cancel;
            debounced.flush = flush;
            return debounced;
        }
        const lodash_es_debounce = debounce_debounce;
        var throttle_FUNC_ERROR_TEXT = "Expected a function";
        function throttle(func, wait, options) {
            var leading = true, trailing = true;
            if (typeof func != "function") throw new TypeError(throttle_FUNC_ERROR_TEXT);
            if (lodash_es_isObject(options)) {
                leading = "leading" in options ? !!options.leading : leading;
                trailing = "trailing" in options ? !!options.trailing : trailing;
            }
            return lodash_es_debounce(func, wait, {
                leading,
                maxWait: wait,
                trailing
            });
        }
        const lodash_es_throttle = throttle;
        var __assign = function() {
            __assign = Object.assign || function __assign(t) {
                for (var s, i = 1, n = arguments.length; i < n; i++) {
                    s = arguments[i];
                    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
                }
                return t;
            };
            return __assign.apply(this, arguments);
        };
        function getElementWindow$1(element) {
            if (!element || !element.ownerDocument || !element.ownerDocument.defaultView) return window;
            return element.ownerDocument.defaultView;
        }
        function getElementDocument$1(element) {
            if (!element || !element.ownerDocument) return document;
            return element.ownerDocument;
        }
        var getOptions$1 = function(obj) {
            var initialObj = {};
            var options = Array.prototype.reduce.call(obj, (function(acc, attribute) {
                var option = attribute.name.match(/data-simplebar-(.+)/);
                if (option) {
                    var key = option[1].replace(/\W+(.)/g, (function(_, chr) {
                        return chr.toUpperCase();
                    }));
                    switch (attribute.value) {
                      case "true":
                        acc[key] = true;
                        break;

                      case "false":
                        acc[key] = false;
                        break;

                      case void 0:
                        acc[key] = true;
                        break;

                      default:
                        acc[key] = attribute.value;
                    }
                }
                return acc;
            }), initialObj);
            return options;
        };
        function addClasses$1(el, classes) {
            var _a;
            if (!el) return;
            (_a = el.classList).add.apply(_a, classes.split(" "));
        }
        function removeClasses$1(el, classes) {
            if (!el) return;
            classes.split(" ").forEach((function(className) {
                el.classList.remove(className);
            }));
        }
        function classNamesToQuery$1(classNames) {
            return ".".concat(classNames.split(" ").join("."));
        }
        var canUseDOM = !!(typeof window !== "undefined" && window.document && window.document.createElement);
        var helpers = Object.freeze({
            __proto__: null,
            addClasses: addClasses$1,
            canUseDOM,
            classNamesToQuery: classNamesToQuery$1,
            getElementDocument: getElementDocument$1,
            getElementWindow: getElementWindow$1,
            getOptions: getOptions$1,
            removeClasses: removeClasses$1
        });
        var cachedScrollbarWidth = null;
        var cachedDevicePixelRatio = null;
        if (canUseDOM) window.addEventListener("resize", (function() {
            if (cachedDevicePixelRatio !== window.devicePixelRatio) {
                cachedDevicePixelRatio = window.devicePixelRatio;
                cachedScrollbarWidth = null;
            }
        }));
        function scrollbarWidth() {
            if (cachedScrollbarWidth === null) {
                if (typeof document === "undefined") {
                    cachedScrollbarWidth = 0;
                    return cachedScrollbarWidth;
                }
                var body = document.body;
                var box = document.createElement("div");
                box.classList.add("simplebar-hide-scrollbar");
                body.appendChild(box);
                var width = box.getBoundingClientRect().right;
                body.removeChild(box);
                cachedScrollbarWidth = width;
            }
            return cachedScrollbarWidth;
        }
        var getElementWindow = getElementWindow$1, getElementDocument = getElementDocument$1, getOptions = getOptions$1, addClasses = addClasses$1, dist_removeClasses = removeClasses$1, classNamesToQuery = classNamesToQuery$1;
        var SimpleBarCore = function() {
            function SimpleBarCore(element, options) {
                if (options === void 0) options = {};
                var _this = this;
                this.removePreventClickId = null;
                this.minScrollbarWidth = 20;
                this.stopScrollDelay = 175;
                this.isScrolling = false;
                this.isMouseEntering = false;
                this.isDragging = false;
                this.scrollXTicking = false;
                this.scrollYTicking = false;
                this.wrapperEl = null;
                this.contentWrapperEl = null;
                this.contentEl = null;
                this.offsetEl = null;
                this.maskEl = null;
                this.placeholderEl = null;
                this.heightAutoObserverWrapperEl = null;
                this.heightAutoObserverEl = null;
                this.rtlHelpers = null;
                this.scrollbarWidth = 0;
                this.resizeObserver = null;
                this.mutationObserver = null;
                this.elStyles = null;
                this.isRtl = null;
                this.mouseX = 0;
                this.mouseY = 0;
                this.onMouseMove = function() {};
                this.onWindowResize = function() {};
                this.onStopScrolling = function() {};
                this.onMouseEntered = function() {};
                this.onScroll = function() {
                    var elWindow = getElementWindow(_this.el);
                    if (!_this.scrollXTicking) {
                        elWindow.requestAnimationFrame(_this.scrollX);
                        _this.scrollXTicking = true;
                    }
                    if (!_this.scrollYTicking) {
                        elWindow.requestAnimationFrame(_this.scrollY);
                        _this.scrollYTicking = true;
                    }
                    if (!_this.isScrolling) {
                        _this.isScrolling = true;
                        addClasses(_this.el, _this.classNames.scrolling);
                    }
                    _this.showScrollbar("x");
                    _this.showScrollbar("y");
                    _this.onStopScrolling();
                };
                this.scrollX = function() {
                    if (_this.axis.x.isOverflowing) _this.positionScrollbar("x");
                    _this.scrollXTicking = false;
                };
                this.scrollY = function() {
                    if (_this.axis.y.isOverflowing) _this.positionScrollbar("y");
                    _this.scrollYTicking = false;
                };
                this._onStopScrolling = function() {
                    dist_removeClasses(_this.el, _this.classNames.scrolling);
                    if (_this.options.autoHide) {
                        _this.hideScrollbar("x");
                        _this.hideScrollbar("y");
                    }
                    _this.isScrolling = false;
                };
                this.onMouseEnter = function() {
                    if (!_this.isMouseEntering) {
                        addClasses(_this.el, _this.classNames.mouseEntered);
                        _this.showScrollbar("x");
                        _this.showScrollbar("y");
                        _this.isMouseEntering = true;
                    }
                    _this.onMouseEntered();
                };
                this._onMouseEntered = function() {
                    dist_removeClasses(_this.el, _this.classNames.mouseEntered);
                    if (_this.options.autoHide) {
                        _this.hideScrollbar("x");
                        _this.hideScrollbar("y");
                    }
                    _this.isMouseEntering = false;
                };
                this._onMouseMove = function(e) {
                    _this.mouseX = e.clientX;
                    _this.mouseY = e.clientY;
                    if (_this.axis.x.isOverflowing || _this.axis.x.forceVisible) _this.onMouseMoveForAxis("x");
                    if (_this.axis.y.isOverflowing || _this.axis.y.forceVisible) _this.onMouseMoveForAxis("y");
                };
                this.onMouseLeave = function() {
                    _this.onMouseMove.cancel();
                    if (_this.axis.x.isOverflowing || _this.axis.x.forceVisible) _this.onMouseLeaveForAxis("x");
                    if (_this.axis.y.isOverflowing || _this.axis.y.forceVisible) _this.onMouseLeaveForAxis("y");
                    _this.mouseX = -1;
                    _this.mouseY = -1;
                };
                this._onWindowResize = function() {
                    _this.scrollbarWidth = _this.getScrollbarWidth();
                    _this.hideNativeScrollbar();
                };
                this.onPointerEvent = function(e) {
                    if (!_this.axis.x.track.el || !_this.axis.y.track.el || !_this.axis.x.scrollbar.el || !_this.axis.y.scrollbar.el) return;
                    var isWithinTrackXBounds, isWithinTrackYBounds;
                    _this.axis.x.track.rect = _this.axis.x.track.el.getBoundingClientRect();
                    _this.axis.y.track.rect = _this.axis.y.track.el.getBoundingClientRect();
                    if (_this.axis.x.isOverflowing || _this.axis.x.forceVisible) isWithinTrackXBounds = _this.isWithinBounds(_this.axis.x.track.rect);
                    if (_this.axis.y.isOverflowing || _this.axis.y.forceVisible) isWithinTrackYBounds = _this.isWithinBounds(_this.axis.y.track.rect);
                    if (isWithinTrackXBounds || isWithinTrackYBounds) {
                        e.stopPropagation();
                        if (e.type === "pointerdown" && e.pointerType !== "touch") {
                            if (isWithinTrackXBounds) {
                                _this.axis.x.scrollbar.rect = _this.axis.x.scrollbar.el.getBoundingClientRect();
                                if (_this.isWithinBounds(_this.axis.x.scrollbar.rect)) _this.onDragStart(e, "x"); else _this.onTrackClick(e, "x");
                            }
                            if (isWithinTrackYBounds) {
                                _this.axis.y.scrollbar.rect = _this.axis.y.scrollbar.el.getBoundingClientRect();
                                if (_this.isWithinBounds(_this.axis.y.scrollbar.rect)) _this.onDragStart(e, "y"); else _this.onTrackClick(e, "y");
                            }
                        }
                    }
                };
                this.drag = function(e) {
                    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l;
                    if (!_this.draggedAxis || !_this.contentWrapperEl) return;
                    var eventOffset;
                    var track = _this.axis[_this.draggedAxis].track;
                    var trackSize = (_b = (_a = track.rect) === null || _a === void 0 ? void 0 : _a[_this.axis[_this.draggedAxis].sizeAttr]) !== null && _b !== void 0 ? _b : 0;
                    var scrollbar = _this.axis[_this.draggedAxis].scrollbar;
                    var contentSize = (_d = (_c = _this.contentWrapperEl) === null || _c === void 0 ? void 0 : _c[_this.axis[_this.draggedAxis].scrollSizeAttr]) !== null && _d !== void 0 ? _d : 0;
                    var hostSize = parseInt((_f = (_e = _this.elStyles) === null || _e === void 0 ? void 0 : _e[_this.axis[_this.draggedAxis].sizeAttr]) !== null && _f !== void 0 ? _f : "0px", 10);
                    e.preventDefault();
                    e.stopPropagation();
                    if (_this.draggedAxis === "y") eventOffset = e.pageY; else eventOffset = e.pageX;
                    var dragPos = eventOffset - ((_h = (_g = track.rect) === null || _g === void 0 ? void 0 : _g[_this.axis[_this.draggedAxis].offsetAttr]) !== null && _h !== void 0 ? _h : 0) - _this.axis[_this.draggedAxis].dragOffset;
                    dragPos = _this.draggedAxis === "x" && _this.isRtl ? ((_k = (_j = track.rect) === null || _j === void 0 ? void 0 : _j[_this.axis[_this.draggedAxis].sizeAttr]) !== null && _k !== void 0 ? _k : 0) - scrollbar.size - dragPos : dragPos;
                    var dragPerc = dragPos / (trackSize - scrollbar.size);
                    var scrollPos = dragPerc * (contentSize - hostSize);
                    if (_this.draggedAxis === "x" && _this.isRtl) scrollPos = ((_l = SimpleBarCore.getRtlHelpers()) === null || _l === void 0 ? void 0 : _l.isScrollingToNegative) ? -scrollPos : scrollPos;
                    _this.contentWrapperEl[_this.axis[_this.draggedAxis].scrollOffsetAttr] = scrollPos;
                };
                this.onEndDrag = function(e) {
                    _this.isDragging = false;
                    var elDocument = getElementDocument(_this.el);
                    var elWindow = getElementWindow(_this.el);
                    e.preventDefault();
                    e.stopPropagation();
                    dist_removeClasses(_this.el, _this.classNames.dragging);
                    _this.onStopScrolling();
                    elDocument.removeEventListener("mousemove", _this.drag, true);
                    elDocument.removeEventListener("mouseup", _this.onEndDrag, true);
                    _this.removePreventClickId = elWindow.setTimeout((function() {
                        elDocument.removeEventListener("click", _this.preventClick, true);
                        elDocument.removeEventListener("dblclick", _this.preventClick, true);
                        _this.removePreventClickId = null;
                    }));
                };
                this.preventClick = function(e) {
                    e.preventDefault();
                    e.stopPropagation();
                };
                this.el = element;
                this.options = __assign(__assign({}, SimpleBarCore.defaultOptions), options);
                this.classNames = __assign(__assign({}, SimpleBarCore.defaultOptions.classNames), options.classNames);
                this.axis = {
                    x: {
                        scrollOffsetAttr: "scrollLeft",
                        sizeAttr: "width",
                        scrollSizeAttr: "scrollWidth",
                        offsetSizeAttr: "offsetWidth",
                        offsetAttr: "left",
                        overflowAttr: "overflowX",
                        dragOffset: 0,
                        isOverflowing: true,
                        forceVisible: false,
                        track: {
                            size: null,
                            el: null,
                            rect: null,
                            isVisible: false
                        },
                        scrollbar: {
                            size: null,
                            el: null,
                            rect: null,
                            isVisible: false
                        }
                    },
                    y: {
                        scrollOffsetAttr: "scrollTop",
                        sizeAttr: "height",
                        scrollSizeAttr: "scrollHeight",
                        offsetSizeAttr: "offsetHeight",
                        offsetAttr: "top",
                        overflowAttr: "overflowY",
                        dragOffset: 0,
                        isOverflowing: true,
                        forceVisible: false,
                        track: {
                            size: null,
                            el: null,
                            rect: null,
                            isVisible: false
                        },
                        scrollbar: {
                            size: null,
                            el: null,
                            rect: null,
                            isVisible: false
                        }
                    }
                };
                if (typeof this.el !== "object" || !this.el.nodeName) throw new Error("Argument passed to SimpleBar must be an HTML element instead of ".concat(this.el));
                this.onMouseMove = lodash_es_throttle(this._onMouseMove, 64);
                this.onWindowResize = lodash_es_debounce(this._onWindowResize, 64, {
                    leading: true
                });
                this.onStopScrolling = lodash_es_debounce(this._onStopScrolling, this.stopScrollDelay);
                this.onMouseEntered = lodash_es_debounce(this._onMouseEntered, this.stopScrollDelay);
                this.init();
            }
            SimpleBarCore.getRtlHelpers = function() {
                if (SimpleBarCore.rtlHelpers) return SimpleBarCore.rtlHelpers;
                var dummyDiv = document.createElement("div");
                dummyDiv.innerHTML = '<div class="simplebar-dummy-scrollbar-size"><div></div></div>';
                var scrollbarDummyEl = dummyDiv.firstElementChild;
                var dummyChild = scrollbarDummyEl === null || scrollbarDummyEl === void 0 ? void 0 : scrollbarDummyEl.firstElementChild;
                if (!dummyChild) return null;
                document.body.appendChild(scrollbarDummyEl);
                scrollbarDummyEl.scrollLeft = 0;
                var dummyContainerOffset = SimpleBarCore.getOffset(scrollbarDummyEl);
                var dummyChildOffset = SimpleBarCore.getOffset(dummyChild);
                scrollbarDummyEl.scrollLeft = -999;
                var dummyChildOffsetAfterScroll = SimpleBarCore.getOffset(dummyChild);
                document.body.removeChild(scrollbarDummyEl);
                SimpleBarCore.rtlHelpers = {
                    isScrollOriginAtZero: dummyContainerOffset.left !== dummyChildOffset.left,
                    isScrollingToNegative: dummyChildOffset.left !== dummyChildOffsetAfterScroll.left
                };
                return SimpleBarCore.rtlHelpers;
            };
            SimpleBarCore.prototype.getScrollbarWidth = function() {
                try {
                    if (this.contentWrapperEl && getComputedStyle(this.contentWrapperEl, "::-webkit-scrollbar").display === "none" || "scrollbarWidth" in document.documentElement.style || "-ms-overflow-style" in document.documentElement.style) return 0; else return scrollbarWidth();
                } catch (e) {
                    return scrollbarWidth();
                }
            };
            SimpleBarCore.getOffset = function(el) {
                var rect = el.getBoundingClientRect();
                var elDocument = getElementDocument(el);
                var elWindow = getElementWindow(el);
                return {
                    top: rect.top + (elWindow.pageYOffset || elDocument.documentElement.scrollTop),
                    left: rect.left + (elWindow.pageXOffset || elDocument.documentElement.scrollLeft)
                };
            };
            SimpleBarCore.prototype.init = function() {
                if (canUseDOM) {
                    this.initDOM();
                    this.rtlHelpers = SimpleBarCore.getRtlHelpers();
                    this.scrollbarWidth = this.getScrollbarWidth();
                    this.recalculate();
                    this.initListeners();
                }
            };
            SimpleBarCore.prototype.initDOM = function() {
                var _a, _b;
                this.wrapperEl = this.el.querySelector(classNamesToQuery(this.classNames.wrapper));
                this.contentWrapperEl = this.options.scrollableNode || this.el.querySelector(classNamesToQuery(this.classNames.contentWrapper));
                this.contentEl = this.options.contentNode || this.el.querySelector(classNamesToQuery(this.classNames.contentEl));
                this.offsetEl = this.el.querySelector(classNamesToQuery(this.classNames.offset));
                this.maskEl = this.el.querySelector(classNamesToQuery(this.classNames.mask));
                this.placeholderEl = this.findChild(this.wrapperEl, classNamesToQuery(this.classNames.placeholder));
                this.heightAutoObserverWrapperEl = this.el.querySelector(classNamesToQuery(this.classNames.heightAutoObserverWrapperEl));
                this.heightAutoObserverEl = this.el.querySelector(classNamesToQuery(this.classNames.heightAutoObserverEl));
                this.axis.x.track.el = this.findChild(this.el, "".concat(classNamesToQuery(this.classNames.track)).concat(classNamesToQuery(this.classNames.horizontal)));
                this.axis.y.track.el = this.findChild(this.el, "".concat(classNamesToQuery(this.classNames.track)).concat(classNamesToQuery(this.classNames.vertical)));
                this.axis.x.scrollbar.el = ((_a = this.axis.x.track.el) === null || _a === void 0 ? void 0 : _a.querySelector(classNamesToQuery(this.classNames.scrollbar))) || null;
                this.axis.y.scrollbar.el = ((_b = this.axis.y.track.el) === null || _b === void 0 ? void 0 : _b.querySelector(classNamesToQuery(this.classNames.scrollbar))) || null;
                if (!this.options.autoHide) {
                    addClasses(this.axis.x.scrollbar.el, this.classNames.visible);
                    addClasses(this.axis.y.scrollbar.el, this.classNames.visible);
                }
            };
            SimpleBarCore.prototype.initListeners = function() {
                var _this = this;
                var _a;
                var elWindow = getElementWindow(this.el);
                this.el.addEventListener("mouseenter", this.onMouseEnter);
                this.el.addEventListener("pointerdown", this.onPointerEvent, true);
                this.el.addEventListener("mousemove", this.onMouseMove);
                this.el.addEventListener("mouseleave", this.onMouseLeave);
                (_a = this.contentWrapperEl) === null || _a === void 0 ? void 0 : _a.addEventListener("scroll", this.onScroll);
                elWindow.addEventListener("resize", this.onWindowResize);
                if (!this.contentEl) return;
                if (window.ResizeObserver) {
                    var resizeObserverStarted_1 = false;
                    var resizeObserver = elWindow.ResizeObserver || ResizeObserver;
                    this.resizeObserver = new resizeObserver((function() {
                        if (!resizeObserverStarted_1) return;
                        elWindow.requestAnimationFrame((function() {
                            _this.recalculate();
                        }));
                    }));
                    this.resizeObserver.observe(this.el);
                    this.resizeObserver.observe(this.contentEl);
                    elWindow.requestAnimationFrame((function() {
                        resizeObserverStarted_1 = true;
                    }));
                }
                this.mutationObserver = new elWindow.MutationObserver((function() {
                    elWindow.requestAnimationFrame((function() {
                        _this.recalculate();
                    }));
                }));
                this.mutationObserver.observe(this.contentEl, {
                    childList: true,
                    subtree: true,
                    characterData: true
                });
            };
            SimpleBarCore.prototype.recalculate = function() {
                if (!this.heightAutoObserverEl || !this.contentEl || !this.contentWrapperEl || !this.wrapperEl || !this.placeholderEl) return;
                var elWindow = getElementWindow(this.el);
                this.elStyles = elWindow.getComputedStyle(this.el);
                this.isRtl = this.elStyles.direction === "rtl";
                var contentElOffsetWidth = this.contentEl.offsetWidth;
                var isHeightAuto = this.heightAutoObserverEl.offsetHeight <= 1;
                var isWidthAuto = this.heightAutoObserverEl.offsetWidth <= 1 || contentElOffsetWidth > 0;
                var contentWrapperElOffsetWidth = this.contentWrapperEl.offsetWidth;
                var elOverflowX = this.elStyles.overflowX;
                var elOverflowY = this.elStyles.overflowY;
                this.contentEl.style.padding = "".concat(this.elStyles.paddingTop, " ").concat(this.elStyles.paddingRight, " ").concat(this.elStyles.paddingBottom, " ").concat(this.elStyles.paddingLeft);
                this.wrapperEl.style.margin = "-".concat(this.elStyles.paddingTop, " -").concat(this.elStyles.paddingRight, " -").concat(this.elStyles.paddingBottom, " -").concat(this.elStyles.paddingLeft);
                var contentElScrollHeight = this.contentEl.scrollHeight;
                var contentElScrollWidth = this.contentEl.scrollWidth;
                this.contentWrapperEl.style.height = isHeightAuto ? "auto" : "100%";
                this.placeholderEl.style.width = isWidthAuto ? "".concat(contentElOffsetWidth || contentElScrollWidth, "px") : "auto";
                this.placeholderEl.style.height = "".concat(contentElScrollHeight, "px");
                var contentWrapperElOffsetHeight = this.contentWrapperEl.offsetHeight;
                this.axis.x.isOverflowing = contentElOffsetWidth !== 0 && contentElScrollWidth > contentElOffsetWidth;
                this.axis.y.isOverflowing = contentElScrollHeight > contentWrapperElOffsetHeight;
                this.axis.x.isOverflowing = elOverflowX === "hidden" ? false : this.axis.x.isOverflowing;
                this.axis.y.isOverflowing = elOverflowY === "hidden" ? false : this.axis.y.isOverflowing;
                this.axis.x.forceVisible = this.options.forceVisible === "x" || this.options.forceVisible === true;
                this.axis.y.forceVisible = this.options.forceVisible === "y" || this.options.forceVisible === true;
                this.hideNativeScrollbar();
                var offsetForXScrollbar = this.axis.x.isOverflowing ? this.scrollbarWidth : 0;
                var offsetForYScrollbar = this.axis.y.isOverflowing ? this.scrollbarWidth : 0;
                this.axis.x.isOverflowing = this.axis.x.isOverflowing && contentElScrollWidth > contentWrapperElOffsetWidth - offsetForYScrollbar;
                this.axis.y.isOverflowing = this.axis.y.isOverflowing && contentElScrollHeight > contentWrapperElOffsetHeight - offsetForXScrollbar;
                this.axis.x.scrollbar.size = this.getScrollbarSize("x");
                this.axis.y.scrollbar.size = this.getScrollbarSize("y");
                if (this.axis.x.scrollbar.el) this.axis.x.scrollbar.el.style.width = "".concat(this.axis.x.scrollbar.size, "px");
                if (this.axis.y.scrollbar.el) this.axis.y.scrollbar.el.style.height = "".concat(this.axis.y.scrollbar.size, "px");
                this.positionScrollbar("x");
                this.positionScrollbar("y");
                this.toggleTrackVisibility("x");
                this.toggleTrackVisibility("y");
            };
            SimpleBarCore.prototype.getScrollbarSize = function(axis) {
                var _a, _b;
                if (axis === void 0) axis = "y";
                if (!this.axis[axis].isOverflowing || !this.contentEl) return 0;
                var contentSize = this.contentEl[this.axis[axis].scrollSizeAttr];
                var trackSize = (_b = (_a = this.axis[axis].track.el) === null || _a === void 0 ? void 0 : _a[this.axis[axis].offsetSizeAttr]) !== null && _b !== void 0 ? _b : 0;
                var scrollbarRatio = trackSize / contentSize;
                var scrollbarSize;
                scrollbarSize = Math.max(~~(scrollbarRatio * trackSize), this.options.scrollbarMinSize);
                if (this.options.scrollbarMaxSize) scrollbarSize = Math.min(scrollbarSize, this.options.scrollbarMaxSize);
                return scrollbarSize;
            };
            SimpleBarCore.prototype.positionScrollbar = function(axis) {
                var _a, _b, _c;
                if (axis === void 0) axis = "y";
                var scrollbar = this.axis[axis].scrollbar;
                if (!this.axis[axis].isOverflowing || !this.contentWrapperEl || !scrollbar.el || !this.elStyles) return;
                var contentSize = this.contentWrapperEl[this.axis[axis].scrollSizeAttr];
                var trackSize = ((_a = this.axis[axis].track.el) === null || _a === void 0 ? void 0 : _a[this.axis[axis].offsetSizeAttr]) || 0;
                var hostSize = parseInt(this.elStyles[this.axis[axis].sizeAttr], 10);
                var scrollOffset = this.contentWrapperEl[this.axis[axis].scrollOffsetAttr];
                scrollOffset = axis === "x" && this.isRtl && ((_b = SimpleBarCore.getRtlHelpers()) === null || _b === void 0 ? void 0 : _b.isScrollOriginAtZero) ? -scrollOffset : scrollOffset;
                if (axis === "x" && this.isRtl) scrollOffset = ((_c = SimpleBarCore.getRtlHelpers()) === null || _c === void 0 ? void 0 : _c.isScrollingToNegative) ? scrollOffset : -scrollOffset;
                var scrollPourcent = scrollOffset / (contentSize - hostSize);
                var handleOffset = ~~((trackSize - scrollbar.size) * scrollPourcent);
                handleOffset = axis === "x" && this.isRtl ? -handleOffset + (trackSize - scrollbar.size) : handleOffset;
                scrollbar.el.style.transform = axis === "x" ? "translate3d(".concat(handleOffset, "px, 0, 0)") : "translate3d(0, ".concat(handleOffset, "px, 0)");
            };
            SimpleBarCore.prototype.toggleTrackVisibility = function(axis) {
                if (axis === void 0) axis = "y";
                var track = this.axis[axis].track.el;
                var scrollbar = this.axis[axis].scrollbar.el;
                if (!track || !scrollbar || !this.contentWrapperEl) return;
                if (this.axis[axis].isOverflowing || this.axis[axis].forceVisible) {
                    track.style.visibility = "visible";
                    this.contentWrapperEl.style[this.axis[axis].overflowAttr] = "scroll";
                    this.el.classList.add("".concat(this.classNames.scrollable, "-").concat(axis));
                } else {
                    track.style.visibility = "hidden";
                    this.contentWrapperEl.style[this.axis[axis].overflowAttr] = "hidden";
                    this.el.classList.remove("".concat(this.classNames.scrollable, "-").concat(axis));
                }
                if (this.axis[axis].isOverflowing) scrollbar.style.display = "block"; else scrollbar.style.display = "none";
            };
            SimpleBarCore.prototype.showScrollbar = function(axis) {
                if (axis === void 0) axis = "y";
                if (this.axis[axis].isOverflowing && !this.axis[axis].scrollbar.isVisible) {
                    addClasses(this.axis[axis].scrollbar.el, this.classNames.visible);
                    this.axis[axis].scrollbar.isVisible = true;
                }
            };
            SimpleBarCore.prototype.hideScrollbar = function(axis) {
                if (axis === void 0) axis = "y";
                if (this.isDragging) return;
                if (this.axis[axis].isOverflowing && this.axis[axis].scrollbar.isVisible) {
                    dist_removeClasses(this.axis[axis].scrollbar.el, this.classNames.visible);
                    this.axis[axis].scrollbar.isVisible = false;
                }
            };
            SimpleBarCore.prototype.hideNativeScrollbar = function() {
                if (!this.offsetEl) return;
                this.offsetEl.style[this.isRtl ? "left" : "right"] = this.axis.y.isOverflowing || this.axis.y.forceVisible ? "-".concat(this.scrollbarWidth, "px") : "0px";
                this.offsetEl.style.bottom = this.axis.x.isOverflowing || this.axis.x.forceVisible ? "-".concat(this.scrollbarWidth, "px") : "0px";
            };
            SimpleBarCore.prototype.onMouseMoveForAxis = function(axis) {
                if (axis === void 0) axis = "y";
                var currentAxis = this.axis[axis];
                if (!currentAxis.track.el || !currentAxis.scrollbar.el) return;
                currentAxis.track.rect = currentAxis.track.el.getBoundingClientRect();
                currentAxis.scrollbar.rect = currentAxis.scrollbar.el.getBoundingClientRect();
                if (this.isWithinBounds(currentAxis.track.rect)) {
                    this.showScrollbar(axis);
                    addClasses(currentAxis.track.el, this.classNames.hover);
                    if (this.isWithinBounds(currentAxis.scrollbar.rect)) addClasses(currentAxis.scrollbar.el, this.classNames.hover); else dist_removeClasses(currentAxis.scrollbar.el, this.classNames.hover);
                } else {
                    dist_removeClasses(currentAxis.track.el, this.classNames.hover);
                    if (this.options.autoHide) this.hideScrollbar(axis);
                }
            };
            SimpleBarCore.prototype.onMouseLeaveForAxis = function(axis) {
                if (axis === void 0) axis = "y";
                dist_removeClasses(this.axis[axis].track.el, this.classNames.hover);
                dist_removeClasses(this.axis[axis].scrollbar.el, this.classNames.hover);
                if (this.options.autoHide) this.hideScrollbar(axis);
            };
            SimpleBarCore.prototype.onDragStart = function(e, axis) {
                var _a;
                if (axis === void 0) axis = "y";
                this.isDragging = true;
                var elDocument = getElementDocument(this.el);
                var elWindow = getElementWindow(this.el);
                var scrollbar = this.axis[axis].scrollbar;
                var eventOffset = axis === "y" ? e.pageY : e.pageX;
                this.axis[axis].dragOffset = eventOffset - (((_a = scrollbar.rect) === null || _a === void 0 ? void 0 : _a[this.axis[axis].offsetAttr]) || 0);
                this.draggedAxis = axis;
                addClasses(this.el, this.classNames.dragging);
                elDocument.addEventListener("mousemove", this.drag, true);
                elDocument.addEventListener("mouseup", this.onEndDrag, true);
                if (this.removePreventClickId === null) {
                    elDocument.addEventListener("click", this.preventClick, true);
                    elDocument.addEventListener("dblclick", this.preventClick, true);
                } else {
                    elWindow.clearTimeout(this.removePreventClickId);
                    this.removePreventClickId = null;
                }
            };
            SimpleBarCore.prototype.onTrackClick = function(e, axis) {
                var _this = this;
                var _a, _b, _c, _d;
                if (axis === void 0) axis = "y";
                var currentAxis = this.axis[axis];
                if (!this.options.clickOnTrack || !currentAxis.scrollbar.el || !this.contentWrapperEl) return;
                e.preventDefault();
                var elWindow = getElementWindow(this.el);
                this.axis[axis].scrollbar.rect = currentAxis.scrollbar.el.getBoundingClientRect();
                var scrollbar = this.axis[axis].scrollbar;
                var scrollbarOffset = (_b = (_a = scrollbar.rect) === null || _a === void 0 ? void 0 : _a[this.axis[axis].offsetAttr]) !== null && _b !== void 0 ? _b : 0;
                var hostSize = parseInt((_d = (_c = this.elStyles) === null || _c === void 0 ? void 0 : _c[this.axis[axis].sizeAttr]) !== null && _d !== void 0 ? _d : "0px", 10);
                var scrolled = this.contentWrapperEl[this.axis[axis].scrollOffsetAttr];
                var t = axis === "y" ? this.mouseY - scrollbarOffset : this.mouseX - scrollbarOffset;
                var dir = t < 0 ? -1 : 1;
                var scrollSize = dir === -1 ? scrolled - hostSize : scrolled + hostSize;
                var speed = 40;
                var scrollTo = function() {
                    if (!_this.contentWrapperEl) return;
                    if (dir === -1) {
                        if (scrolled > scrollSize) {
                            scrolled -= speed;
                            _this.contentWrapperEl[_this.axis[axis].scrollOffsetAttr] = scrolled;
                            elWindow.requestAnimationFrame(scrollTo);
                        }
                    } else if (scrolled < scrollSize) {
                        scrolled += speed;
                        _this.contentWrapperEl[_this.axis[axis].scrollOffsetAttr] = scrolled;
                        elWindow.requestAnimationFrame(scrollTo);
                    }
                };
                scrollTo();
            };
            SimpleBarCore.prototype.getContentElement = function() {
                return this.contentEl;
            };
            SimpleBarCore.prototype.getScrollElement = function() {
                return this.contentWrapperEl;
            };
            SimpleBarCore.prototype.removeListeners = function() {
                var elWindow = getElementWindow(this.el);
                this.el.removeEventListener("mouseenter", this.onMouseEnter);
                this.el.removeEventListener("pointerdown", this.onPointerEvent, true);
                this.el.removeEventListener("mousemove", this.onMouseMove);
                this.el.removeEventListener("mouseleave", this.onMouseLeave);
                if (this.contentWrapperEl) this.contentWrapperEl.removeEventListener("scroll", this.onScroll);
                elWindow.removeEventListener("resize", this.onWindowResize);
                if (this.mutationObserver) this.mutationObserver.disconnect();
                if (this.resizeObserver) this.resizeObserver.disconnect();
                this.onMouseMove.cancel();
                this.onWindowResize.cancel();
                this.onStopScrolling.cancel();
                this.onMouseEntered.cancel();
            };
            SimpleBarCore.prototype.unMount = function() {
                this.removeListeners();
            };
            SimpleBarCore.prototype.isWithinBounds = function(bbox) {
                return this.mouseX >= bbox.left && this.mouseX <= bbox.left + bbox.width && this.mouseY >= bbox.top && this.mouseY <= bbox.top + bbox.height;
            };
            SimpleBarCore.prototype.findChild = function(el, query) {
                var matches = el.matches || el.webkitMatchesSelector || el.mozMatchesSelector || el.msMatchesSelector;
                return Array.prototype.filter.call(el.children, (function(child) {
                    return matches.call(child, query);
                }))[0];
            };
            SimpleBarCore.rtlHelpers = null;
            SimpleBarCore.defaultOptions = {
                forceVisible: false,
                clickOnTrack: true,
                scrollbarMinSize: 25,
                scrollbarMaxSize: 0,
                ariaLabel: "scrollable content",
                tabIndex: 0,
                classNames: {
                    contentEl: "simplebar-content",
                    contentWrapper: "simplebar-content-wrapper",
                    offset: "simplebar-offset",
                    mask: "simplebar-mask",
                    wrapper: "simplebar-wrapper",
                    placeholder: "simplebar-placeholder",
                    scrollbar: "simplebar-scrollbar",
                    track: "simplebar-track",
                    heightAutoObserverWrapperEl: "simplebar-height-auto-observer-wrapper",
                    heightAutoObserverEl: "simplebar-height-auto-observer",
                    visible: "simplebar-visible",
                    horizontal: "simplebar-horizontal",
                    vertical: "simplebar-vertical",
                    hover: "simplebar-hover",
                    dragging: "simplebar-dragging",
                    scrolling: "simplebar-scrolling",
                    scrollable: "simplebar-scrollable",
                    mouseEntered: "simplebar-mouse-entered"
                },
                scrollableNode: null,
                contentNode: null,
                autoHide: true
            };
            SimpleBarCore.getOptions = getOptions;
            SimpleBarCore.helpers = helpers;
            return SimpleBarCore;
        }();
        var extendStatics = function(d, b) {
            extendStatics = Object.setPrototypeOf || {
                __proto__: []
            } instanceof Array && function(d, b) {
                d.__proto__ = b;
            } || function(d, b) {
                for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
            };
            return extendStatics(d, b);
        };
        function __extends(d, b) {
            if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
            extendStatics(d, b);
            function __() {
                this.constructor = d;
            }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __);
        }
        var _a = SimpleBarCore.helpers, dist_getOptions = _a.getOptions, dist_addClasses = _a.addClasses, dist_canUseDOM = _a.canUseDOM;
        var SimpleBar = function(_super) {
            __extends(SimpleBar, _super);
            function SimpleBar() {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) args[_i] = arguments[_i];
                var _this = _super.apply(this, args) || this;
                SimpleBar.instances.set(args[0], _this);
                return _this;
            }
            SimpleBar.initDOMLoadedElements = function() {
                document.removeEventListener("DOMContentLoaded", this.initDOMLoadedElements);
                window.removeEventListener("load", this.initDOMLoadedElements);
                Array.prototype.forEach.call(document.querySelectorAll("[data-simplebar]"), (function(el) {
                    if (el.getAttribute("data-simplebar") !== "init" && !SimpleBar.instances.has(el)) new SimpleBar(el, dist_getOptions(el.attributes));
                }));
            };
            SimpleBar.removeObserver = function() {
                var _a;
                (_a = SimpleBar.globalObserver) === null || _a === void 0 ? void 0 : _a.disconnect();
            };
            SimpleBar.prototype.initDOM = function() {
                var _this = this;
                var _a, _b, _c;
                if (!Array.prototype.filter.call(this.el.children, (function(child) {
                    return child.classList.contains(_this.classNames.wrapper);
                })).length) {
                    this.wrapperEl = document.createElement("div");
                    this.contentWrapperEl = document.createElement("div");
                    this.offsetEl = document.createElement("div");
                    this.maskEl = document.createElement("div");
                    this.contentEl = document.createElement("div");
                    this.placeholderEl = document.createElement("div");
                    this.heightAutoObserverWrapperEl = document.createElement("div");
                    this.heightAutoObserverEl = document.createElement("div");
                    dist_addClasses(this.wrapperEl, this.classNames.wrapper);
                    dist_addClasses(this.contentWrapperEl, this.classNames.contentWrapper);
                    dist_addClasses(this.offsetEl, this.classNames.offset);
                    dist_addClasses(this.maskEl, this.classNames.mask);
                    dist_addClasses(this.contentEl, this.classNames.contentEl);
                    dist_addClasses(this.placeholderEl, this.classNames.placeholder);
                    dist_addClasses(this.heightAutoObserverWrapperEl, this.classNames.heightAutoObserverWrapperEl);
                    dist_addClasses(this.heightAutoObserverEl, this.classNames.heightAutoObserverEl);
                    while (this.el.firstChild) this.contentEl.appendChild(this.el.firstChild);
                    this.contentWrapperEl.appendChild(this.contentEl);
                    this.offsetEl.appendChild(this.contentWrapperEl);
                    this.maskEl.appendChild(this.offsetEl);
                    this.heightAutoObserverWrapperEl.appendChild(this.heightAutoObserverEl);
                    this.wrapperEl.appendChild(this.heightAutoObserverWrapperEl);
                    this.wrapperEl.appendChild(this.maskEl);
                    this.wrapperEl.appendChild(this.placeholderEl);
                    this.el.appendChild(this.wrapperEl);
                    (_a = this.contentWrapperEl) === null || _a === void 0 ? void 0 : _a.setAttribute("tabindex", this.options.tabIndex.toString());
                    (_b = this.contentWrapperEl) === null || _b === void 0 ? void 0 : _b.setAttribute("role", "region");
                    (_c = this.contentWrapperEl) === null || _c === void 0 ? void 0 : _c.setAttribute("aria-label", this.options.ariaLabel);
                }
                if (!this.axis.x.track.el || !this.axis.y.track.el) {
                    var track = document.createElement("div");
                    var scrollbar = document.createElement("div");
                    dist_addClasses(track, this.classNames.track);
                    dist_addClasses(scrollbar, this.classNames.scrollbar);
                    track.appendChild(scrollbar);
                    this.axis.x.track.el = track.cloneNode(true);
                    dist_addClasses(this.axis.x.track.el, this.classNames.horizontal);
                    this.axis.y.track.el = track.cloneNode(true);
                    dist_addClasses(this.axis.y.track.el, this.classNames.vertical);
                    this.el.appendChild(this.axis.x.track.el);
                    this.el.appendChild(this.axis.y.track.el);
                }
                SimpleBarCore.prototype.initDOM.call(this);
                this.el.setAttribute("data-simplebar", "init");
            };
            SimpleBar.prototype.unMount = function() {
                SimpleBarCore.prototype.unMount.call(this);
                SimpleBar.instances["delete"](this.el);
            };
            SimpleBar.initHtmlApi = function() {
                this.initDOMLoadedElements = this.initDOMLoadedElements.bind(this);
                if (typeof MutationObserver !== "undefined") {
                    this.globalObserver = new MutationObserver(SimpleBar.handleMutations);
                    this.globalObserver.observe(document, {
                        childList: true,
                        subtree: true
                    });
                }
                if (document.readyState === "complete" || document.readyState !== "loading" && !document.documentElement.doScroll) window.setTimeout(this.initDOMLoadedElements); else {
                    document.addEventListener("DOMContentLoaded", this.initDOMLoadedElements);
                    window.addEventListener("load", this.initDOMLoadedElements);
                }
            };
            SimpleBar.handleMutations = function(mutations) {
                mutations.forEach((function(mutation) {
                    mutation.addedNodes.forEach((function(addedNode) {
                        if (addedNode.nodeType === 1) if (addedNode.hasAttribute("data-simplebar")) !SimpleBar.instances.has(addedNode) && document.documentElement.contains(addedNode) && new SimpleBar(addedNode, dist_getOptions(addedNode.attributes)); else addedNode.querySelectorAll("[data-simplebar]").forEach((function(el) {
                            if (el.getAttribute("data-simplebar") !== "init" && !SimpleBar.instances.has(el) && document.documentElement.contains(el)) new SimpleBar(el, dist_getOptions(el.attributes));
                        }));
                    }));
                    mutation.removedNodes.forEach((function(removedNode) {
                        var _a;
                        if (removedNode.nodeType === 1) if (removedNode.getAttribute("data-simplebar") === "init") !document.documentElement.contains(removedNode) && ((_a = SimpleBar.instances.get(removedNode)) === null || _a === void 0 ? void 0 : _a.unMount()); else Array.prototype.forEach.call(removedNode.querySelectorAll('[data-simplebar="init"]'), (function(el) {
                            var _a;
                            !document.documentElement.contains(el) && ((_a = SimpleBar.instances.get(el)) === null || _a === void 0 ? void 0 : _a.unMount());
                        }));
                    }));
                }));
            };
            SimpleBar.instances = new WeakMap;
            return SimpleBar;
        }(SimpleBarCore);
        if (dist_canUseDOM) SimpleBar.initHtmlApi();
        if (document.querySelectorAll("[data-simplebar]").length) document.querySelectorAll("[data-simplebar]").forEach((scrollBlock => {
            new SimpleBar(scrollBlock, {
                autoHide: false
            });
        }));
        let addWindowScrollEvent = false;
        setTimeout((() => {
            if (addWindowScrollEvent) {
                let windowScroll = new Event("windowScroll");
                window.addEventListener("scroll", (function(e) {
                    document.dispatchEvent(windowScroll);
                }));
            }
        }), 0);
        var Events = function() {
            function Events(eventType, eventFunctions) {
                if (eventFunctions === void 0) eventFunctions = [];
                this._eventType = eventType;
                this._eventFunctions = eventFunctions;
            }
            Events.prototype.init = function() {
                var _this = this;
                this._eventFunctions.forEach((function(eventFunction) {
                    if (typeof window !== "undefined") window.addEventListener(_this._eventType, eventFunction);
                }));
            };
            return Events;
        }();
        const events = Events;
        var Instances = function() {
            function Instances() {
                this._instances = {
                    Accordion: {},
                    Carousel: {},
                    Collapse: {},
                    Dial: {},
                    Dismiss: {},
                    Drawer: {},
                    Dropdown: {},
                    Modal: {},
                    Popover: {},
                    Tabs: {},
                    Tooltip: {},
                    InputCounter: {},
                    CopyClipboard: {},
                    Datepicker: {}
                };
            }
            Instances.prototype.addInstance = function(component, instance, id, override) {
                if (override === void 0) override = false;
                if (!this._instances[component]) {
                    console.warn("Flowbite: Component ".concat(component, " does not exist."));
                    return false;
                }
                if (this._instances[component][id] && !override) {
                    console.warn("Flowbite: Instance with ID ".concat(id, " already exists."));
                    return;
                }
                if (override && this._instances[component][id]) this._instances[component][id].destroyAndRemoveInstance();
                this._instances[component][id ? id : this._generateRandomId()] = instance;
            };
            Instances.prototype.getAllInstances = function() {
                return this._instances;
            };
            Instances.prototype.getInstances = function(component) {
                if (!this._instances[component]) {
                    console.warn("Flowbite: Component ".concat(component, " does not exist."));
                    return false;
                }
                return this._instances[component];
            };
            Instances.prototype.getInstance = function(component, id) {
                if (!this._componentAndInstanceCheck(component, id)) return;
                if (!this._instances[component][id]) {
                    console.warn("Flowbite: Instance with ID ".concat(id, " does not exist."));
                    return;
                }
                return this._instances[component][id];
            };
            Instances.prototype.destroyAndRemoveInstance = function(component, id) {
                if (!this._componentAndInstanceCheck(component, id)) return;
                this.destroyInstanceObject(component, id);
                this.removeInstance(component, id);
            };
            Instances.prototype.removeInstance = function(component, id) {
                if (!this._componentAndInstanceCheck(component, id)) return;
                delete this._instances[component][id];
            };
            Instances.prototype.destroyInstanceObject = function(component, id) {
                if (!this._componentAndInstanceCheck(component, id)) return;
                this._instances[component][id].destroy();
            };
            Instances.prototype.instanceExists = function(component, id) {
                if (!this._instances[component]) return false;
                if (!this._instances[component][id]) return false;
                return true;
            };
            Instances.prototype._generateRandomId = function() {
                return Math.random().toString(36).substr(2, 9);
            };
            Instances.prototype._componentAndInstanceCheck = function(component, id) {
                if (!this._instances[component]) {
                    console.warn("Flowbite: Component ".concat(component, " does not exist."));
                    return false;
                }
                if (!this._instances[component][id]) {
                    console.warn("Flowbite: Instance with ID ".concat(id, " does not exist."));
                    return false;
                }
                return true;
            };
            return Instances;
        }();
        var instances = new Instances;
        const dom_instances = instances;
        if (typeof window !== "undefined") window.FlowbiteInstances = instances;
        var accordion_assign = void 0 && (void 0).__assign || function() {
            accordion_assign = Object.assign || function(t) {
                for (var s, i = 1, n = arguments.length; i < n; i++) {
                    s = arguments[i];
                    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
                }
                return t;
            };
            return accordion_assign.apply(this, arguments);
        };
        var Default = {
            alwaysOpen: false,
            activeClasses: "bg-gray-100 dark:bg-gray-800 text-gray-900 dark:text-white",
            inactiveClasses: "text-gray-500 dark:text-gray-400",
            onOpen: function() {},
            onClose: function() {},
            onToggle: function() {}
        };
        var DefaultInstanceOptions = {
            id: null,
            override: true
        };
        var Accordion = function() {
            function Accordion(accordionEl, items, options, instanceOptions) {
                if (accordionEl === void 0) accordionEl = null;
                if (items === void 0) items = [];
                if (options === void 0) options = Default;
                if (instanceOptions === void 0) instanceOptions = DefaultInstanceOptions;
                this._instanceId = instanceOptions.id ? instanceOptions.id : accordionEl.id;
                this._accordionEl = accordionEl;
                this._items = items;
                this._options = accordion_assign(accordion_assign({}, Default), options);
                this._initialized = false;
                this.init();
                dom_instances.addInstance("Accordion", this, this._instanceId, instanceOptions.override);
            }
            Accordion.prototype.init = function() {
                var _this = this;
                if (this._items.length && !this._initialized) {
                    this._items.forEach((function(item) {
                        if (item.active) _this.open(item.id);
                        var clickHandler = function() {
                            _this.toggle(item.id);
                        };
                        item.triggerEl.addEventListener("click", clickHandler);
                        item.clickHandler = clickHandler;
                    }));
                    this._initialized = true;
                }
            };
            Accordion.prototype.destroy = function() {
                if (this._items.length && this._initialized) {
                    this._items.forEach((function(item) {
                        item.triggerEl.removeEventListener("click", item.clickHandler);
                        delete item.clickHandler;
                    }));
                    this._initialized = false;
                }
            };
            Accordion.prototype.removeInstance = function() {
                dom_instances.removeInstance("Accordion", this._instanceId);
            };
            Accordion.prototype.destroyAndRemoveInstance = function() {
                this.destroy();
                this.removeInstance();
            };
            Accordion.prototype.getItem = function(id) {
                return this._items.filter((function(item) {
                    return item.id === id;
                }))[0];
            };
            Accordion.prototype.open = function(id) {
                var _a, _b;
                var _this = this;
                var item = this.getItem(id);
                if (!this._options.alwaysOpen) this._items.map((function(i) {
                    var _a, _b;
                    if (i !== item) {
                        (_a = i.triggerEl.classList).remove.apply(_a, _this._options.activeClasses.split(" "));
                        (_b = i.triggerEl.classList).add.apply(_b, _this._options.inactiveClasses.split(" "));
                        i.targetEl.classList.add("hidden");
                        i.triggerEl.setAttribute("aria-expanded", "false");
                        i.active = false;
                        if (i.iconEl) i.iconEl.classList.add("rotate-180");
                    }
                }));
                (_a = item.triggerEl.classList).add.apply(_a, this._options.activeClasses.split(" "));
                (_b = item.triggerEl.classList).remove.apply(_b, this._options.inactiveClasses.split(" "));
                item.triggerEl.setAttribute("aria-expanded", "true");
                item.targetEl.classList.remove("hidden");
                item.active = true;
                if (item.iconEl) item.iconEl.classList.remove("rotate-180");
                this._options.onOpen(this, item);
            };
            Accordion.prototype.toggle = function(id) {
                var item = this.getItem(id);
                if (item.active) this.close(id); else this.open(id);
                this._options.onToggle(this, item);
            };
            Accordion.prototype.close = function(id) {
                var _a, _b;
                var item = this.getItem(id);
                (_a = item.triggerEl.classList).remove.apply(_a, this._options.activeClasses.split(" "));
                (_b = item.triggerEl.classList).add.apply(_b, this._options.inactiveClasses.split(" "));
                item.targetEl.classList.add("hidden");
                item.triggerEl.setAttribute("aria-expanded", "false");
                item.active = false;
                if (item.iconEl) item.iconEl.classList.add("rotate-180");
                this._options.onClose(this, item);
            };
            Accordion.prototype.updateOnOpen = function(callback) {
                this._options.onOpen = callback;
            };
            Accordion.prototype.updateOnClose = function(callback) {
                this._options.onClose = callback;
            };
            Accordion.prototype.updateOnToggle = function(callback) {
                this._options.onToggle = callback;
            };
            return Accordion;
        }();
        function initAccordions() {
            document.querySelectorAll("[data-accordion]").forEach((function($accordionEl) {
                var alwaysOpen = $accordionEl.getAttribute("data-accordion");
                var activeClasses = $accordionEl.getAttribute("data-active-classes");
                var inactiveClasses = $accordionEl.getAttribute("data-inactive-classes");
                var items = [];
                $accordionEl.querySelectorAll("[data-accordion-target]").forEach((function($triggerEl) {
                    if ($triggerEl.closest("[data-accordion]") === $accordionEl) {
                        var item = {
                            id: $triggerEl.getAttribute("data-accordion-target"),
                            triggerEl: $triggerEl,
                            targetEl: document.querySelector($triggerEl.getAttribute("data-accordion-target")),
                            iconEl: $triggerEl.querySelector("[data-accordion-icon]"),
                            active: $triggerEl.getAttribute("aria-expanded") === "true" ? true : false
                        };
                        items.push(item);
                    }
                }));
                new Accordion($accordionEl, items, {
                    alwaysOpen: alwaysOpen === "open" ? true : false,
                    activeClasses: activeClasses ? activeClasses : Default.activeClasses,
                    inactiveClasses: inactiveClasses ? inactiveClasses : Default.inactiveClasses
                });
            }));
        }
        if (typeof window !== "undefined") {
            window.Accordion = Accordion;
            window.initAccordions = initAccordions;
        }
        var collapse_assign = void 0 && (void 0).__assign || function() {
            collapse_assign = Object.assign || function(t) {
                for (var s, i = 1, n = arguments.length; i < n; i++) {
                    s = arguments[i];
                    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
                }
                return t;
            };
            return collapse_assign.apply(this, arguments);
        };
        var collapse_Default = {
            onCollapse: function() {},
            onExpand: function() {},
            onToggle: function() {}
        };
        var collapse_DefaultInstanceOptions = {
            id: null,
            override: true
        };
        var Collapse = function() {
            function Collapse(targetEl, triggerEl, options, instanceOptions) {
                if (targetEl === void 0) targetEl = null;
                if (triggerEl === void 0) triggerEl = null;
                if (options === void 0) options = collapse_Default;
                if (instanceOptions === void 0) instanceOptions = collapse_DefaultInstanceOptions;
                this._instanceId = instanceOptions.id ? instanceOptions.id : targetEl.id;
                this._targetEl = targetEl;
                this._triggerEl = triggerEl;
                this._options = collapse_assign(collapse_assign({}, collapse_Default), options);
                this._visible = false;
                this._initialized = false;
                this.init();
                dom_instances.addInstance("Collapse", this, this._instanceId, instanceOptions.override);
            }
            Collapse.prototype.init = function() {
                var _this = this;
                if (this._triggerEl && this._targetEl && !this._initialized) {
                    if (this._triggerEl.hasAttribute("aria-expanded")) this._visible = this._triggerEl.getAttribute("aria-expanded") === "true"; else this._visible = !this._targetEl.classList.contains("hidden");
                    this._clickHandler = function() {
                        _this.toggle();
                    };
                    this._triggerEl.addEventListener("click", this._clickHandler);
                    this._initialized = true;
                }
            };
            Collapse.prototype.destroy = function() {
                if (this._triggerEl && this._initialized) {
                    this._triggerEl.removeEventListener("click", this._clickHandler);
                    this._initialized = false;
                }
            };
            Collapse.prototype.removeInstance = function() {
                dom_instances.removeInstance("Collapse", this._instanceId);
            };
            Collapse.prototype.destroyAndRemoveInstance = function() {
                this.destroy();
                this.removeInstance();
            };
            Collapse.prototype.collapse = function() {
                this._targetEl.classList.add("hidden");
                if (this._triggerEl) this._triggerEl.setAttribute("aria-expanded", "false");
                this._visible = false;
                this._options.onCollapse(this);
            };
            Collapse.prototype.expand = function() {
                this._targetEl.classList.remove("hidden");
                if (this._triggerEl) this._triggerEl.setAttribute("aria-expanded", "true");
                this._visible = true;
                this._options.onExpand(this);
            };
            Collapse.prototype.toggle = function() {
                if (this._visible) this.collapse(); else this.expand();
                this._options.onToggle(this);
            };
            Collapse.prototype.updateOnCollapse = function(callback) {
                this._options.onCollapse = callback;
            };
            Collapse.prototype.updateOnExpand = function(callback) {
                this._options.onExpand = callback;
            };
            Collapse.prototype.updateOnToggle = function(callback) {
                this._options.onToggle = callback;
            };
            return Collapse;
        }();
        function initCollapses() {
            document.querySelectorAll("[data-collapse-toggle]").forEach((function($triggerEl) {
                var targetId = $triggerEl.getAttribute("data-collapse-toggle");
                var $targetEl = document.getElementById(targetId);
                if ($targetEl) if (!dom_instances.instanceExists("Collapse", $targetEl.getAttribute("id"))) new Collapse($targetEl, $triggerEl); else new Collapse($targetEl, $triggerEl, {}, {
                    id: $targetEl.getAttribute("id") + "_" + dom_instances._generateRandomId()
                }); else console.error('The target element with id "'.concat(targetId, '" does not exist. Please check the data-collapse-toggle attribute.'));
            }));
        }
        if (typeof window !== "undefined") {
            window.Collapse = Collapse;
            window.initCollapses = initCollapses;
        }
        var carousel_assign = void 0 && (void 0).__assign || function() {
            carousel_assign = Object.assign || function(t) {
                for (var s, i = 1, n = arguments.length; i < n; i++) {
                    s = arguments[i];
                    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
                }
                return t;
            };
            return carousel_assign.apply(this, arguments);
        };
        var carousel_Default = {
            defaultPosition: 0,
            indicators: {
                items: [],
                activeClasses: "bg-white dark:bg-gray-800",
                inactiveClasses: "bg-white/50 dark:bg-gray-800/50 hover:bg-white dark:hover:bg-gray-800"
            },
            interval: 3e3,
            onNext: function() {},
            onPrev: function() {},
            onChange: function() {}
        };
        var carousel_DefaultInstanceOptions = {
            id: null,
            override: true
        };
        var Carousel = function() {
            function Carousel(carouselEl, items, options, instanceOptions) {
                if (carouselEl === void 0) carouselEl = null;
                if (items === void 0) items = [];
                if (options === void 0) options = carousel_Default;
                if (instanceOptions === void 0) instanceOptions = carousel_DefaultInstanceOptions;
                this._instanceId = instanceOptions.id ? instanceOptions.id : carouselEl.id;
                this._carouselEl = carouselEl;
                this._items = items;
                this._options = carousel_assign(carousel_assign(carousel_assign({}, carousel_Default), options), {
                    indicators: carousel_assign(carousel_assign({}, carousel_Default.indicators), options.indicators)
                });
                this._activeItem = this.getItem(this._options.defaultPosition);
                this._indicators = this._options.indicators.items;
                this._intervalDuration = this._options.interval;
                this._intervalInstance = null;
                this._initialized = false;
                this.init();
                dom_instances.addInstance("Carousel", this, this._instanceId, instanceOptions.override);
            }
            Carousel.prototype.init = function() {
                var _this = this;
                if (this._items.length && !this._initialized) {
                    this._items.map((function(item) {
                        item.el.classList.add("absolute", "inset-0", "transition-transform", "transform");
                    }));
                    if (this.getActiveItem()) this.slideTo(this.getActiveItem().position); else this.slideTo(0);
                    this._indicators.map((function(indicator, position) {
                        indicator.el.addEventListener("click", (function() {
                            _this.slideTo(position);
                        }));
                    }));
                    this._initialized = true;
                }
            };
            Carousel.prototype.destroy = function() {
                if (this._initialized) this._initialized = false;
            };
            Carousel.prototype.removeInstance = function() {
                dom_instances.removeInstance("Carousel", this._instanceId);
            };
            Carousel.prototype.destroyAndRemoveInstance = function() {
                this.destroy();
                this.removeInstance();
            };
            Carousel.prototype.getItem = function(position) {
                return this._items[position];
            };
            Carousel.prototype.slideTo = function(position) {
                var nextItem = this._items[position];
                var rotationItems = {
                    left: nextItem.position === 0 ? this._items[this._items.length - 1] : this._items[nextItem.position - 1],
                    middle: nextItem,
                    right: nextItem.position === this._items.length - 1 ? this._items[0] : this._items[nextItem.position + 1]
                };
                this._rotate(rotationItems);
                this._setActiveItem(nextItem);
                if (this._intervalInstance) {
                    this.pause();
                    this.cycle();
                }
                this._options.onChange(this);
            };
            Carousel.prototype.next = function() {
                var activeItem = this.getActiveItem();
                var nextItem = null;
                if (activeItem.position === this._items.length - 1) nextItem = this._items[0]; else nextItem = this._items[activeItem.position + 1];
                this.slideTo(nextItem.position);
                this._options.onNext(this);
            };
            Carousel.prototype.prev = function() {
                var activeItem = this.getActiveItem();
                var prevItem = null;
                if (activeItem.position === 0) prevItem = this._items[this._items.length - 1]; else prevItem = this._items[activeItem.position - 1];
                this.slideTo(prevItem.position);
                this._options.onPrev(this);
            };
            Carousel.prototype._rotate = function(rotationItems) {
                this._items.map((function(item) {
                    item.el.classList.add("hidden");
                }));
                if (this._items.length === 1) {
                    rotationItems.middle.el.classList.remove("-translate-x-full", "translate-x-full", "translate-x-0", "hidden", "z-10");
                    rotationItems.middle.el.classList.add("translate-x-0", "z-20");
                    return;
                }
                rotationItems.left.el.classList.remove("-translate-x-full", "translate-x-full", "translate-x-0", "hidden", "z-20");
                rotationItems.left.el.classList.add("-translate-x-full", "z-10");
                rotationItems.middle.el.classList.remove("-translate-x-full", "translate-x-full", "translate-x-0", "hidden", "z-10");
                rotationItems.middle.el.classList.add("translate-x-0", "z-30");
                rotationItems.right.el.classList.remove("-translate-x-full", "translate-x-full", "translate-x-0", "hidden", "z-30");
                rotationItems.right.el.classList.add("translate-x-full", "z-20");
            };
            Carousel.prototype.cycle = function() {
                var _this = this;
                if (typeof window !== "undefined") this._intervalInstance = window.setInterval((function() {
                    _this.next();
                }), this._intervalDuration);
            };
            Carousel.prototype.pause = function() {
                clearInterval(this._intervalInstance);
            };
            Carousel.prototype.getActiveItem = function() {
                return this._activeItem;
            };
            Carousel.prototype._setActiveItem = function(item) {
                var _a, _b;
                var _this = this;
                this._activeItem = item;
                var position = item.position;
                if (this._indicators.length) {
                    this._indicators.map((function(indicator) {
                        var _a, _b;
                        indicator.el.setAttribute("aria-current", "false");
                        (_a = indicator.el.classList).remove.apply(_a, _this._options.indicators.activeClasses.split(" "));
                        (_b = indicator.el.classList).add.apply(_b, _this._options.indicators.inactiveClasses.split(" "));
                    }));
                    (_a = this._indicators[position].el.classList).add.apply(_a, this._options.indicators.activeClasses.split(" "));
                    (_b = this._indicators[position].el.classList).remove.apply(_b, this._options.indicators.inactiveClasses.split(" "));
                    this._indicators[position].el.setAttribute("aria-current", "true");
                }
            };
            Carousel.prototype.updateOnNext = function(callback) {
                this._options.onNext = callback;
            };
            Carousel.prototype.updateOnPrev = function(callback) {
                this._options.onPrev = callback;
            };
            Carousel.prototype.updateOnChange = function(callback) {
                this._options.onChange = callback;
            };
            return Carousel;
        }();
        function initCarousels() {
            document.querySelectorAll("[data-carousel]").forEach((function($carouselEl) {
                var interval = $carouselEl.getAttribute("data-carousel-interval");
                var slide = $carouselEl.getAttribute("data-carousel") === "slide" ? true : false;
                var items = [];
                var defaultPosition = 0;
                if ($carouselEl.querySelectorAll("[data-carousel-item]").length) Array.from($carouselEl.querySelectorAll("[data-carousel-item]")).map((function($carouselItemEl, position) {
                    items.push({
                        position,
                        el: $carouselItemEl
                    });
                    if ($carouselItemEl.getAttribute("data-carousel-item") === "active") defaultPosition = position;
                }));
                var indicators = [];
                if ($carouselEl.querySelectorAll("[data-carousel-slide-to]").length) Array.from($carouselEl.querySelectorAll("[data-carousel-slide-to]")).map((function($indicatorEl) {
                    indicators.push({
                        position: parseInt($indicatorEl.getAttribute("data-carousel-slide-to")),
                        el: $indicatorEl
                    });
                }));
                var carousel = new Carousel($carouselEl, items, {
                    defaultPosition,
                    indicators: {
                        items: indicators
                    },
                    interval: interval ? interval : carousel_Default.interval
                });
                if (slide) carousel.cycle();
                var carouselNextEl = $carouselEl.querySelector("[data-carousel-next]");
                var carouselPrevEl = $carouselEl.querySelector("[data-carousel-prev]");
                if (carouselNextEl) carouselNextEl.addEventListener("click", (function() {
                    carousel.next();
                }));
                if (carouselPrevEl) carouselPrevEl.addEventListener("click", (function() {
                    carousel.prev();
                }));
            }));
        }
        if (typeof window !== "undefined") {
            window.Carousel = Carousel;
            window.initCarousels = initCarousels;
        }
        var dismiss_assign = void 0 && (void 0).__assign || function() {
            dismiss_assign = Object.assign || function(t) {
                for (var s, i = 1, n = arguments.length; i < n; i++) {
                    s = arguments[i];
                    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
                }
                return t;
            };
            return dismiss_assign.apply(this, arguments);
        };
        var dismiss_Default = {
            transition: "transition-opacity",
            duration: 300,
            timing: "ease-out",
            onHide: function() {}
        };
        var dismiss_DefaultInstanceOptions = {
            id: null,
            override: true
        };
        var Dismiss = function() {
            function Dismiss(targetEl, triggerEl, options, instanceOptions) {
                if (targetEl === void 0) targetEl = null;
                if (triggerEl === void 0) triggerEl = null;
                if (options === void 0) options = dismiss_Default;
                if (instanceOptions === void 0) instanceOptions = dismiss_DefaultInstanceOptions;
                this._instanceId = instanceOptions.id ? instanceOptions.id : targetEl.id;
                this._targetEl = targetEl;
                this._triggerEl = triggerEl;
                this._options = dismiss_assign(dismiss_assign({}, dismiss_Default), options);
                this._initialized = false;
                this.init();
                dom_instances.addInstance("Dismiss", this, this._instanceId, instanceOptions.override);
            }
            Dismiss.prototype.init = function() {
                var _this = this;
                if (this._triggerEl && this._targetEl && !this._initialized) {
                    this._clickHandler = function() {
                        _this.hide();
                    };
                    this._triggerEl.addEventListener("click", this._clickHandler);
                    this._initialized = true;
                }
            };
            Dismiss.prototype.destroy = function() {
                if (this._triggerEl && this._initialized) {
                    this._triggerEl.removeEventListener("click", this._clickHandler);
                    this._initialized = false;
                }
            };
            Dismiss.prototype.removeInstance = function() {
                dom_instances.removeInstance("Dismiss", this._instanceId);
            };
            Dismiss.prototype.destroyAndRemoveInstance = function() {
                this.destroy();
                this.removeInstance();
            };
            Dismiss.prototype.hide = function() {
                var _this = this;
                this._targetEl.classList.add(this._options.transition, "duration-".concat(this._options.duration), this._options.timing, "opacity-0");
                setTimeout((function() {
                    _this._targetEl.classList.add("hidden");
                }), this._options.duration);
                this._options.onHide(this, this._targetEl);
            };
            Dismiss.prototype.updateOnHide = function(callback) {
                this._options.onHide = callback;
            };
            return Dismiss;
        }();
        function initDismisses() {
            document.querySelectorAll("[data-dismiss-target]").forEach((function($triggerEl) {
                var targetId = $triggerEl.getAttribute("data-dismiss-target");
                var $dismissEl = document.querySelector(targetId);
                if ($dismissEl) new Dismiss($dismissEl, $triggerEl); else console.error('The dismiss element with id "'.concat(targetId, '" does not exist. Please check the data-dismiss-target attribute.'));
            }));
        }
        if (typeof window !== "undefined") {
            window.Dismiss = Dismiss;
            window.initDismisses = initDismisses;
        }
        var dropdown_assign = void 0 && (void 0).__assign || function() {
            dropdown_assign = Object.assign || function(t) {
                for (var s, i = 1, n = arguments.length; i < n; i++) {
                    s = arguments[i];
                    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
                }
                return t;
            };
            return dropdown_assign.apply(this, arguments);
        };
        var __spreadArray = void 0 && (void 0).__spreadArray || function(to, from, pack) {
            if (pack || arguments.length === 2) for (var ar, i = 0, l = from.length; i < l; i++) if (ar || !(i in from)) {
                if (!ar) ar = Array.prototype.slice.call(from, 0, i);
                ar[i] = from[i];
            }
            return to.concat(ar || Array.prototype.slice.call(from));
        };
        var dropdown_Default = {
            placement: "bottom",
            triggerType: "click",
            offsetSkidding: 0,
            offsetDistance: 10,
            delay: 300,
            ignoreClickOutsideClass: false,
            onShow: function() {},
            onHide: function() {},
            onToggle: function() {}
        };
        var dropdown_DefaultInstanceOptions = {
            id: null,
            override: true
        };
        var Dropdown = function() {
            function Dropdown(targetElement, triggerElement, options, instanceOptions) {
                if (targetElement === void 0) targetElement = null;
                if (triggerElement === void 0) triggerElement = null;
                if (options === void 0) options = dropdown_Default;
                if (instanceOptions === void 0) instanceOptions = dropdown_DefaultInstanceOptions;
                this._instanceId = instanceOptions.id ? instanceOptions.id : targetElement.id;
                this._targetEl = targetElement;
                this._triggerEl = triggerElement;
                this._options = dropdown_assign(dropdown_assign({}, dropdown_Default), options);
                this._popperInstance = null;
                this._visible = false;
                this._initialized = false;
                this.init();
                dom_instances.addInstance("Dropdown", this, this._instanceId, instanceOptions.override);
            }
            Dropdown.prototype.init = function() {
                if (this._triggerEl && this._targetEl && !this._initialized) {
                    this._popperInstance = this._createPopperInstance();
                    this._setupEventListeners();
                    this._initialized = true;
                }
            };
            Dropdown.prototype.destroy = function() {
                var _this = this;
                var triggerEvents = this._getTriggerEvents();
                if (this._options.triggerType === "click") triggerEvents.showEvents.forEach((function(ev) {
                    _this._triggerEl.removeEventListener(ev, _this._clickHandler);
                }));
                if (this._options.triggerType === "hover") {
                    triggerEvents.showEvents.forEach((function(ev) {
                        _this._triggerEl.removeEventListener(ev, _this._hoverShowTriggerElHandler);
                        _this._targetEl.removeEventListener(ev, _this._hoverShowTargetElHandler);
                    }));
                    triggerEvents.hideEvents.forEach((function(ev) {
                        _this._triggerEl.removeEventListener(ev, _this._hoverHideHandler);
                        _this._targetEl.removeEventListener(ev, _this._hoverHideHandler);
                    }));
                }
                this._popperInstance.destroy();
                this._initialized = false;
            };
            Dropdown.prototype.removeInstance = function() {
                dom_instances.removeInstance("Dropdown", this._instanceId);
            };
            Dropdown.prototype.destroyAndRemoveInstance = function() {
                this.destroy();
                this.removeInstance();
            };
            Dropdown.prototype._setupEventListeners = function() {
                var _this = this;
                var triggerEvents = this._getTriggerEvents();
                this._clickHandler = function() {
                    _this.toggle();
                };
                if (this._options.triggerType === "click") triggerEvents.showEvents.forEach((function(ev) {
                    _this._triggerEl.addEventListener(ev, _this._clickHandler);
                }));
                this._hoverShowTriggerElHandler = function(ev) {
                    if (ev.type === "click") _this.toggle(); else setTimeout((function() {
                        _this.show();
                    }), _this._options.delay);
                };
                this._hoverShowTargetElHandler = function() {
                    _this.show();
                };
                this._hoverHideHandler = function() {
                    setTimeout((function() {
                        if (!_this._targetEl.matches(":hover")) _this.hide();
                    }), _this._options.delay);
                };
                if (this._options.triggerType === "hover") {
                    triggerEvents.showEvents.forEach((function(ev) {
                        _this._triggerEl.addEventListener(ev, _this._hoverShowTriggerElHandler);
                        _this._targetEl.addEventListener(ev, _this._hoverShowTargetElHandler);
                    }));
                    triggerEvents.hideEvents.forEach((function(ev) {
                        _this._triggerEl.addEventListener(ev, _this._hoverHideHandler);
                        _this._targetEl.addEventListener(ev, _this._hoverHideHandler);
                    }));
                }
            };
            Dropdown.prototype._createPopperInstance = function() {
                return popper_createPopper(this._triggerEl, this._targetEl, {
                    placement: this._options.placement,
                    modifiers: [ {
                        name: "offset",
                        options: {
                            offset: [ this._options.offsetSkidding, this._options.offsetDistance ]
                        }
                    } ]
                });
            };
            Dropdown.prototype._setupClickOutsideListener = function() {
                var _this = this;
                this._clickOutsideEventListener = function(ev) {
                    _this._handleClickOutside(ev, _this._targetEl);
                };
                document.body.addEventListener("click", this._clickOutsideEventListener, true);
            };
            Dropdown.prototype._removeClickOutsideListener = function() {
                document.body.removeEventListener("click", this._clickOutsideEventListener, true);
            };
            Dropdown.prototype._handleClickOutside = function(ev, targetEl) {
                var clickedEl = ev.target;
                var ignoreClickOutsideClass = this._options.ignoreClickOutsideClass;
                var isIgnored = false;
                if (ignoreClickOutsideClass) {
                    var ignoredClickOutsideEls = document.querySelectorAll(".".concat(ignoreClickOutsideClass));
                    ignoredClickOutsideEls.forEach((function(el) {
                        if (el.contains(clickedEl)) {
                            isIgnored = true;
                            return;
                        }
                    }));
                }
                if (clickedEl !== targetEl && !targetEl.contains(clickedEl) && !this._triggerEl.contains(clickedEl) && !isIgnored && this.isVisible()) this.hide();
            };
            Dropdown.prototype._getTriggerEvents = function() {
                switch (this._options.triggerType) {
                  case "hover":
                    return {
                        showEvents: [ "mouseenter", "click" ],
                        hideEvents: [ "mouseleave" ]
                    };

                  case "click":
                    return {
                        showEvents: [ "click" ],
                        hideEvents: []
                    };

                  case "none":
                    return {
                        showEvents: [],
                        hideEvents: []
                    };

                  default:
                    return {
                        showEvents: [ "click" ],
                        hideEvents: []
                    };
                }
            };
            Dropdown.prototype.toggle = function() {
                if (this.isVisible()) this.hide(); else this.show();
                this._options.onToggle(this);
            };
            Dropdown.prototype.isVisible = function() {
                return this._visible;
            };
            Dropdown.prototype.show = function() {
                this._targetEl.classList.remove("hidden");
                this._targetEl.classList.add("block");
                this._targetEl.removeAttribute("aria-hidden");
                this._popperInstance.setOptions((function(options) {
                    return dropdown_assign(dropdown_assign({}, options), {
                        modifiers: __spreadArray(__spreadArray([], options.modifiers, true), [ {
                            name: "eventListeners",
                            enabled: true
                        } ], false)
                    });
                }));
                this._setupClickOutsideListener();
                this._popperInstance.update();
                this._visible = true;
                this._options.onShow(this);
            };
            Dropdown.prototype.hide = function() {
                this._targetEl.classList.remove("block");
                this._targetEl.classList.add("hidden");
                this._targetEl.setAttribute("aria-hidden", "true");
                this._popperInstance.setOptions((function(options) {
                    return dropdown_assign(dropdown_assign({}, options), {
                        modifiers: __spreadArray(__spreadArray([], options.modifiers, true), [ {
                            name: "eventListeners",
                            enabled: false
                        } ], false)
                    });
                }));
                this._visible = false;
                this._removeClickOutsideListener();
                this._options.onHide(this);
            };
            Dropdown.prototype.updateOnShow = function(callback) {
                this._options.onShow = callback;
            };
            Dropdown.prototype.updateOnHide = function(callback) {
                this._options.onHide = callback;
            };
            Dropdown.prototype.updateOnToggle = function(callback) {
                this._options.onToggle = callback;
            };
            return Dropdown;
        }();
        function initDropdowns() {
            document.querySelectorAll("[data-dropdown-toggle]").forEach((function($triggerEl) {
                var dropdownId = $triggerEl.getAttribute("data-dropdown-toggle");
                var $dropdownEl = document.getElementById(dropdownId);
                if ($dropdownEl) {
                    var placement = $triggerEl.getAttribute("data-dropdown-placement");
                    var offsetSkidding = $triggerEl.getAttribute("data-dropdown-offset-skidding");
                    var offsetDistance = $triggerEl.getAttribute("data-dropdown-offset-distance");
                    var triggerType = $triggerEl.getAttribute("data-dropdown-trigger");
                    var delay = $triggerEl.getAttribute("data-dropdown-delay");
                    var ignoreClickOutsideClass = $triggerEl.getAttribute("data-dropdown-ignore-click-outside-class");
                    new Dropdown($dropdownEl, $triggerEl, {
                        placement: placement ? placement : dropdown_Default.placement,
                        triggerType: triggerType ? triggerType : dropdown_Default.triggerType,
                        offsetSkidding: offsetSkidding ? parseInt(offsetSkidding) : dropdown_Default.offsetSkidding,
                        offsetDistance: offsetDistance ? parseInt(offsetDistance) : dropdown_Default.offsetDistance,
                        delay: delay ? parseInt(delay) : dropdown_Default.delay,
                        ignoreClickOutsideClass: ignoreClickOutsideClass ? ignoreClickOutsideClass : dropdown_Default.ignoreClickOutsideClass
                    });
                } else console.error('The dropdown element with id "'.concat(dropdownId, '" does not exist. Please check the data-dropdown-toggle attribute.'));
            }));
        }
        if (typeof window !== "undefined") {
            window.Dropdown = Dropdown;
            window.initDropdowns = initDropdowns;
        }
        var modal_assign = void 0 && (void 0).__assign || function() {
            modal_assign = Object.assign || function(t) {
                for (var s, i = 1, n = arguments.length; i < n; i++) {
                    s = arguments[i];
                    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
                }
                return t;
            };
            return modal_assign.apply(this, arguments);
        };
        var modal_Default = {
            placement: "center",
            backdropClasses: "bg-gray-900/50 dark:bg-gray-900/80 fixed inset-0 z-40",
            backdrop: "dynamic",
            closable: true,
            onHide: function() {},
            onShow: function() {},
            onToggle: function() {}
        };
        var modal_DefaultInstanceOptions = {
            id: null,
            override: true
        };
        var Modal = function() {
            function Modal(targetEl, options, instanceOptions) {
                if (targetEl === void 0) targetEl = null;
                if (options === void 0) options = modal_Default;
                if (instanceOptions === void 0) instanceOptions = modal_DefaultInstanceOptions;
                this._eventListenerInstances = [];
                this._instanceId = instanceOptions.id ? instanceOptions.id : targetEl.id;
                this._targetEl = targetEl;
                this._options = modal_assign(modal_assign({}, modal_Default), options);
                this._isHidden = true;
                this._backdropEl = null;
                this._initialized = false;
                this.init();
                dom_instances.addInstance("Modal", this, this._instanceId, instanceOptions.override);
            }
            Modal.prototype.init = function() {
                var _this = this;
                if (this._targetEl && !this._initialized) {
                    this._getPlacementClasses().map((function(c) {
                        _this._targetEl.classList.add(c);
                    }));
                    this._initialized = true;
                }
            };
            Modal.prototype.destroy = function() {
                if (this._initialized) {
                    this.removeAllEventListenerInstances();
                    this._destroyBackdropEl();
                    this._initialized = false;
                }
            };
            Modal.prototype.removeInstance = function() {
                dom_instances.removeInstance("Modal", this._instanceId);
            };
            Modal.prototype.destroyAndRemoveInstance = function() {
                this.destroy();
                this.removeInstance();
            };
            Modal.prototype._createBackdrop = function() {
                var _a;
                if (this._isHidden) {
                    var backdropEl = document.createElement("div");
                    (_a = backdropEl.classList).add.apply(_a, this._options.backdropClasses.split(" "));
                    document.querySelector("body").append(backdropEl);
                    this._backdropEl = backdropEl;
                }
            };
            Modal.prototype._destroyBackdropEl = function() {
                if (!this._isHidden && this._backdropEl) {
                    this._backdropEl.remove();
                    this._backdropEl = null;
                }
            };
            Modal.prototype._setupModalCloseEventListeners = function() {
                var _this = this;
                if (this._options.backdrop === "dynamic") {
                    this._clickOutsideEventListener = function(ev) {
                        _this._handleOutsideClick(ev.target);
                    };
                    this._targetEl.addEventListener("click", this._clickOutsideEventListener, true);
                }
                this._keydownEventListener = function(ev) {
                    if (ev.key === "Escape") _this.hide();
                };
                document.body.addEventListener("keydown", this._keydownEventListener, true);
            };
            Modal.prototype._removeModalCloseEventListeners = function() {
                if (this._options.backdrop === "dynamic") this._targetEl.removeEventListener("click", this._clickOutsideEventListener, true);
                document.body.removeEventListener("keydown", this._keydownEventListener, true);
            };
            Modal.prototype._handleOutsideClick = function(target) {
                if (target === this._targetEl || target === this._backdropEl && this.isVisible()) this.hide();
            };
            Modal.prototype._getPlacementClasses = function() {
                switch (this._options.placement) {
                  case "top-left":
                    return [ "justify-start", "items-start" ];

                  case "top-center":
                    return [ "justify-center", "items-start" ];

                  case "top-right":
                    return [ "justify-end", "items-start" ];

                  case "center-left":
                    return [ "justify-start", "items-center" ];

                  case "center":
                    return [ "justify-center", "items-center" ];

                  case "center-right":
                    return [ "justify-end", "items-center" ];

                  case "bottom-left":
                    return [ "justify-start", "items-end" ];

                  case "bottom-center":
                    return [ "justify-center", "items-end" ];

                  case "bottom-right":
                    return [ "justify-end", "items-end" ];

                  default:
                    return [ "justify-center", "items-center" ];
                }
            };
            Modal.prototype.toggle = function() {
                if (this._isHidden) this.show(); else this.hide();
                this._options.onToggle(this);
            };
            Modal.prototype.show = function() {
                if (this.isHidden) {
                    this._targetEl.classList.add("flex");
                    this._targetEl.classList.remove("hidden");
                    this._targetEl.setAttribute("aria-modal", "true");
                    this._targetEl.setAttribute("role", "dialog");
                    this._targetEl.removeAttribute("aria-hidden");
                    this._createBackdrop();
                    this._isHidden = false;
                    if (this._options.closable) this._setupModalCloseEventListeners();
                    document.body.classList.add("overflow-hidden");
                    this._options.onShow(this);
                }
            };
            Modal.prototype.hide = function() {
                if (this.isVisible) {
                    this._targetEl.classList.add("hidden");
                    this._targetEl.classList.remove("flex");
                    this._targetEl.setAttribute("aria-hidden", "true");
                    this._targetEl.removeAttribute("aria-modal");
                    this._targetEl.removeAttribute("role");
                    this._destroyBackdropEl();
                    this._isHidden = true;
                    document.body.classList.remove("overflow-hidden");
                    if (this._options.closable) this._removeModalCloseEventListeners();
                    this._options.onHide(this);
                }
            };
            Modal.prototype.isVisible = function() {
                return !this._isHidden;
            };
            Modal.prototype.isHidden = function() {
                return this._isHidden;
            };
            Modal.prototype.addEventListenerInstance = function(element, type, handler) {
                this._eventListenerInstances.push({
                    element,
                    type,
                    handler
                });
            };
            Modal.prototype.removeAllEventListenerInstances = function() {
                this._eventListenerInstances.map((function(eventListenerInstance) {
                    eventListenerInstance.element.removeEventListener(eventListenerInstance.type, eventListenerInstance.handler);
                }));
                this._eventListenerInstances = [];
            };
            Modal.prototype.getAllEventListenerInstances = function() {
                return this._eventListenerInstances;
            };
            Modal.prototype.updateOnShow = function(callback) {
                this._options.onShow = callback;
            };
            Modal.prototype.updateOnHide = function(callback) {
                this._options.onHide = callback;
            };
            Modal.prototype.updateOnToggle = function(callback) {
                this._options.onToggle = callback;
            };
            return Modal;
        }();
        function initModals() {
            document.querySelectorAll("[data-modal-target]").forEach((function($triggerEl) {
                var modalId = $triggerEl.getAttribute("data-modal-target");
                var $modalEl = document.getElementById(modalId);
                if ($modalEl) {
                    var placement = $modalEl.getAttribute("data-modal-placement");
                    var backdrop = $modalEl.getAttribute("data-modal-backdrop");
                    new Modal($modalEl, {
                        placement: placement ? placement : modal_Default.placement,
                        backdrop: backdrop ? backdrop : modal_Default.backdrop
                    });
                } else console.error("Modal with id ".concat(modalId, " does not exist. Are you sure that the data-modal-target attribute points to the correct modal id?."));
            }));
            document.querySelectorAll("[data-modal-toggle]").forEach((function($triggerEl) {
                var modalId = $triggerEl.getAttribute("data-modal-toggle");
                var $modalEl = document.getElementById(modalId);
                if ($modalEl) {
                    var modal_1 = dom_instances.getInstance("Modal", modalId);
                    if (modal_1) {
                        var toggleModal = function() {
                            modal_1.toggle();
                        };
                        $triggerEl.addEventListener("click", toggleModal);
                        modal_1.addEventListenerInstance($triggerEl, "click", toggleModal);
                    } else console.error("Modal with id ".concat(modalId, " has not been initialized. Please initialize it using the data-modal-target attribute."));
                } else console.error("Modal with id ".concat(modalId, " does not exist. Are you sure that the data-modal-toggle attribute points to the correct modal id?"));
            }));
            document.querySelectorAll("[data-modal-show]").forEach((function($triggerEl) {
                var modalId = $triggerEl.getAttribute("data-modal-show");
                var $modalEl = document.getElementById(modalId);
                if ($modalEl) {
                    var modal_2 = dom_instances.getInstance("Modal", modalId);
                    if (modal_2) {
                        var showModal = function() {
                            modal_2.show();
                        };
                        $triggerEl.addEventListener("click", showModal);
                        modal_2.addEventListenerInstance($triggerEl, "click", showModal);
                    } else console.error("Modal with id ".concat(modalId, " has not been initialized. Please initialize it using the data-modal-target attribute."));
                } else console.error("Modal with id ".concat(modalId, " does not exist. Are you sure that the data-modal-show attribute points to the correct modal id?"));
            }));
            document.querySelectorAll("[data-modal-hide]").forEach((function($triggerEl) {
                var modalId = $triggerEl.getAttribute("data-modal-hide");
                var $modalEl = document.getElementById(modalId);
                if ($modalEl) {
                    var modal_3 = dom_instances.getInstance("Modal", modalId);
                    if (modal_3) {
                        var hideModal = function() {
                            modal_3.hide();
                        };
                        $triggerEl.addEventListener("click", hideModal);
                        modal_3.addEventListenerInstance($triggerEl, "click", hideModal);
                    } else console.error("Modal with id ".concat(modalId, " has not been initialized. Please initialize it using the data-modal-target attribute."));
                } else console.error("Modal with id ".concat(modalId, " does not exist. Are you sure that the data-modal-hide attribute points to the correct modal id?"));
            }));
        }
        if (typeof window !== "undefined") {
            window.Modal = Modal;
            window.initModals = initModals;
        }
        var drawer_assign = void 0 && (void 0).__assign || function() {
            drawer_assign = Object.assign || function(t) {
                for (var s, i = 1, n = arguments.length; i < n; i++) {
                    s = arguments[i];
                    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
                }
                return t;
            };
            return drawer_assign.apply(this, arguments);
        };
        var drawer_Default = {
            placement: "left",
            bodyScrolling: false,
            backdrop: true,
            edge: false,
            edgeOffset: "bottom-[60px]",
            backdropClasses: "bg-gray-900/50 dark:bg-gray-900/80 fixed inset-0 z-30",
            onShow: function() {},
            onHide: function() {},
            onToggle: function() {}
        };
        var drawer_DefaultInstanceOptions = {
            id: null,
            override: true
        };
        var Drawer = function() {
            function Drawer(targetEl, options, instanceOptions) {
                if (targetEl === void 0) targetEl = null;
                if (options === void 0) options = drawer_Default;
                if (instanceOptions === void 0) instanceOptions = drawer_DefaultInstanceOptions;
                this._eventListenerInstances = [];
                this._instanceId = instanceOptions.id ? instanceOptions.id : targetEl.id;
                this._targetEl = targetEl;
                this._options = drawer_assign(drawer_assign({}, drawer_Default), options);
                this._visible = false;
                this._initialized = false;
                this.init();
                dom_instances.addInstance("Drawer", this, this._instanceId, instanceOptions.override);
            }
            Drawer.prototype.init = function() {
                var _this = this;
                if (this._targetEl && !this._initialized) {
                    this._targetEl.setAttribute("aria-hidden", "true");
                    this._targetEl.classList.add("transition-transform");
                    this._getPlacementClasses(this._options.placement).base.map((function(c) {
                        _this._targetEl.classList.add(c);
                    }));
                    this._handleEscapeKey = function(event) {
                        if (event.key === "Escape") if (_this.isVisible()) _this.hide();
                    };
                    document.addEventListener("keydown", this._handleEscapeKey);
                    this._initialized = true;
                }
            };
            Drawer.prototype.destroy = function() {
                if (this._initialized) {
                    this.removeAllEventListenerInstances();
                    this._destroyBackdropEl();
                    document.removeEventListener("keydown", this._handleEscapeKey);
                    this._initialized = false;
                }
            };
            Drawer.prototype.removeInstance = function() {
                dom_instances.removeInstance("Drawer", this._instanceId);
            };
            Drawer.prototype.destroyAndRemoveInstance = function() {
                this.destroy();
                this.removeInstance();
            };
            Drawer.prototype.hide = function() {
                var _this = this;
                if (this._options.edge) {
                    this._getPlacementClasses(this._options.placement + "-edge").active.map((function(c) {
                        _this._targetEl.classList.remove(c);
                    }));
                    this._getPlacementClasses(this._options.placement + "-edge").inactive.map((function(c) {
                        _this._targetEl.classList.add(c);
                    }));
                } else {
                    this._getPlacementClasses(this._options.placement).active.map((function(c) {
                        _this._targetEl.classList.remove(c);
                    }));
                    this._getPlacementClasses(this._options.placement).inactive.map((function(c) {
                        _this._targetEl.classList.add(c);
                    }));
                }
                this._targetEl.setAttribute("aria-hidden", "true");
                this._targetEl.removeAttribute("aria-modal");
                this._targetEl.removeAttribute("role");
                if (!this._options.bodyScrolling) document.body.classList.remove("overflow-hidden");
                if (this._options.backdrop) this._destroyBackdropEl();
                this._visible = false;
                this._options.onHide(this);
            };
            Drawer.prototype.show = function() {
                var _this = this;
                if (this._options.edge) {
                    this._getPlacementClasses(this._options.placement + "-edge").active.map((function(c) {
                        _this._targetEl.classList.add(c);
                    }));
                    this._getPlacementClasses(this._options.placement + "-edge").inactive.map((function(c) {
                        _this._targetEl.classList.remove(c);
                    }));
                } else {
                    this._getPlacementClasses(this._options.placement).active.map((function(c) {
                        _this._targetEl.classList.add(c);
                    }));
                    this._getPlacementClasses(this._options.placement).inactive.map((function(c) {
                        _this._targetEl.classList.remove(c);
                    }));
                }
                this._targetEl.setAttribute("aria-modal", "true");
                this._targetEl.setAttribute("role", "dialog");
                this._targetEl.removeAttribute("aria-hidden");
                if (!this._options.bodyScrolling) document.body.classList.add("overflow-hidden");
                if (this._options.backdrop) this._createBackdrop();
                this._visible = true;
                this._options.onShow(this);
            };
            Drawer.prototype.toggle = function() {
                if (this.isVisible()) this.hide(); else this.show();
            };
            Drawer.prototype._createBackdrop = function() {
                var _a;
                var _this = this;
                if (!this._visible) {
                    var backdropEl = document.createElement("div");
                    backdropEl.setAttribute("drawer-backdrop", "");
                    (_a = backdropEl.classList).add.apply(_a, this._options.backdropClasses.split(" "));
                    document.querySelector("body").append(backdropEl);
                    backdropEl.addEventListener("click", (function() {
                        _this.hide();
                    }));
                }
            };
            Drawer.prototype._destroyBackdropEl = function() {
                if (this._visible && document.querySelector("[drawer-backdrop]") !== null) document.querySelector("[drawer-backdrop]").remove();
            };
            Drawer.prototype._getPlacementClasses = function(placement) {
                switch (placement) {
                  case "top":
                    return {
                        base: [ "top-0", "left-0", "right-0" ],
                        active: [ "transform-none" ],
                        inactive: [ "-translate-y-full" ]
                    };

                  case "right":
                    return {
                        base: [ "right-0", "top-0" ],
                        active: [ "transform-none" ],
                        inactive: [ "translate-x-full" ]
                    };

                  case "bottom":
                    return {
                        base: [ "bottom-0", "left-0", "right-0" ],
                        active: [ "transform-none" ],
                        inactive: [ "translate-y-full" ]
                    };

                  case "left":
                    return {
                        base: [ "left-0", "top-0" ],
                        active: [ "transform-none" ],
                        inactive: [ "-translate-x-full" ]
                    };

                  case "bottom-edge":
                    return {
                        base: [ "left-0", "top-0" ],
                        active: [ "transform-none" ],
                        inactive: [ "translate-y-full", this._options.edgeOffset ]
                    };

                  default:
                    return {
                        base: [ "left-0", "top-0" ],
                        active: [ "transform-none" ],
                        inactive: [ "-translate-x-full" ]
                    };
                }
            };
            Drawer.prototype.isHidden = function() {
                return !this._visible;
            };
            Drawer.prototype.isVisible = function() {
                return this._visible;
            };
            Drawer.prototype.addEventListenerInstance = function(element, type, handler) {
                this._eventListenerInstances.push({
                    element,
                    type,
                    handler
                });
            };
            Drawer.prototype.removeAllEventListenerInstances = function() {
                this._eventListenerInstances.map((function(eventListenerInstance) {
                    eventListenerInstance.element.removeEventListener(eventListenerInstance.type, eventListenerInstance.handler);
                }));
                this._eventListenerInstances = [];
            };
            Drawer.prototype.getAllEventListenerInstances = function() {
                return this._eventListenerInstances;
            };
            Drawer.prototype.updateOnShow = function(callback) {
                this._options.onShow = callback;
            };
            Drawer.prototype.updateOnHide = function(callback) {
                this._options.onHide = callback;
            };
            Drawer.prototype.updateOnToggle = function(callback) {
                this._options.onToggle = callback;
            };
            return Drawer;
        }();
        function initDrawers() {
            document.querySelectorAll("[data-drawer-target]").forEach((function($triggerEl) {
                var drawerId = $triggerEl.getAttribute("data-drawer-target");
                var $drawerEl = document.getElementById(drawerId);
                if ($drawerEl) {
                    var placement = $triggerEl.getAttribute("data-drawer-placement");
                    var bodyScrolling = $triggerEl.getAttribute("data-drawer-body-scrolling");
                    var backdrop = $triggerEl.getAttribute("data-drawer-backdrop");
                    var edge = $triggerEl.getAttribute("data-drawer-edge");
                    var edgeOffset = $triggerEl.getAttribute("data-drawer-edge-offset");
                    new Drawer($drawerEl, {
                        placement: placement ? placement : drawer_Default.placement,
                        bodyScrolling: bodyScrolling ? bodyScrolling === "true" ? true : false : drawer_Default.bodyScrolling,
                        backdrop: backdrop ? backdrop === "true" ? true : false : drawer_Default.backdrop,
                        edge: edge ? edge === "true" ? true : false : drawer_Default.edge,
                        edgeOffset: edgeOffset ? edgeOffset : drawer_Default.edgeOffset
                    });
                } else console.error("Drawer with id ".concat(drawerId, " not found. Are you sure that the data-drawer-target attribute points to the correct drawer id?"));
            }));
            document.querySelectorAll("[data-drawer-toggle]").forEach((function($triggerEl) {
                var drawerId = $triggerEl.getAttribute("data-drawer-toggle");
                var $drawerEl = document.getElementById(drawerId);
                if ($drawerEl) {
                    var drawer_1 = dom_instances.getInstance("Drawer", drawerId);
                    if (drawer_1) {
                        var toggleDrawer = function() {
                            drawer_1.toggle();
                        };
                        $triggerEl.addEventListener("click", toggleDrawer);
                        drawer_1.addEventListenerInstance($triggerEl, "click", toggleDrawer);
                    } else console.error("Drawer with id ".concat(drawerId, " has not been initialized. Please initialize it using the data-drawer-target attribute."));
                } else console.error("Drawer with id ".concat(drawerId, " not found. Are you sure that the data-drawer-target attribute points to the correct drawer id?"));
            }));
            document.querySelectorAll("[data-drawer-dismiss], [data-drawer-hide]").forEach((function($triggerEl) {
                var drawerId = $triggerEl.getAttribute("data-drawer-dismiss") ? $triggerEl.getAttribute("data-drawer-dismiss") : $triggerEl.getAttribute("data-drawer-hide");
                var $drawerEl = document.getElementById(drawerId);
                if ($drawerEl) {
                    var drawer_2 = dom_instances.getInstance("Drawer", drawerId);
                    if (drawer_2) {
                        var hideDrawer = function() {
                            drawer_2.hide();
                        };
                        $triggerEl.addEventListener("click", hideDrawer);
                        drawer_2.addEventListenerInstance($triggerEl, "click", hideDrawer);
                    } else console.error("Drawer with id ".concat(drawerId, " has not been initialized. Please initialize it using the data-drawer-target attribute."));
                } else console.error("Drawer with id ".concat(drawerId, " not found. Are you sure that the data-drawer-target attribute points to the correct drawer id"));
            }));
            document.querySelectorAll("[data-drawer-show]").forEach((function($triggerEl) {
                var drawerId = $triggerEl.getAttribute("data-drawer-show");
                var $drawerEl = document.getElementById(drawerId);
                if ($drawerEl) {
                    var drawer_3 = dom_instances.getInstance("Drawer", drawerId);
                    if (drawer_3) {
                        var showDrawer = function() {
                            drawer_3.show();
                        };
                        $triggerEl.addEventListener("click", showDrawer);
                        drawer_3.addEventListenerInstance($triggerEl, "click", showDrawer);
                    } else console.error("Drawer with id ".concat(drawerId, " has not been initialized. Please initialize it using the data-drawer-target attribute."));
                } else console.error("Drawer with id ".concat(drawerId, " not found. Are you sure that the data-drawer-target attribute points to the correct drawer id?"));
            }));
        }
        if (typeof window !== "undefined") {
            window.Drawer = Drawer;
            window.initDrawers = initDrawers;
        }
        var tabs_assign = void 0 && (void 0).__assign || function() {
            tabs_assign = Object.assign || function(t) {
                for (var s, i = 1, n = arguments.length; i < n; i++) {
                    s = arguments[i];
                    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
                }
                return t;
            };
            return tabs_assign.apply(this, arguments);
        };
        var tabs_Default = {
            defaultTabId: null,
            activeClasses: "text-blue-600 hover:text-blue-600 dark:text-blue-500 dark:hover:text-blue-500 border-blue-600 dark:border-blue-500",
            inactiveClasses: "dark:border-transparent text-gray-500 hover:text-gray-600 dark:text-gray-400 border-gray-100 hover:border-gray-300 dark:border-gray-700 dark:hover:text-gray-300",
            onShow: function() {}
        };
        var tabs_DefaultInstanceOptions = {
            id: null,
            override: true
        };
        var Tabs = function() {
            function Tabs(tabsEl, items, options, instanceOptions) {
                if (tabsEl === void 0) tabsEl = null;
                if (items === void 0) items = [];
                if (options === void 0) options = tabs_Default;
                if (instanceOptions === void 0) instanceOptions = tabs_DefaultInstanceOptions;
                this._instanceId = instanceOptions.id ? instanceOptions.id : tabsEl.id;
                this._tabsEl = tabsEl;
                this._items = items;
                this._activeTab = options ? this.getTab(options.defaultTabId) : null;
                this._options = tabs_assign(tabs_assign({}, tabs_Default), options);
                this._initialized = false;
                this.init();
                dom_instances.addInstance("Tabs", this, this._instanceId, instanceOptions.override);
            }
            Tabs.prototype.init = function() {
                var _this = this;
                if (this._items.length && !this._initialized) {
                    if (!this._activeTab) this.setActiveTab(this._items[0]);
                    this.show(this._activeTab.id, true);
                    this._items.map((function(tab) {
                        tab.triggerEl.addEventListener("click", (function(event) {
                            event.preventDefault();
                            _this.show(tab.id);
                        }));
                    }));
                }
            };
            Tabs.prototype.destroy = function() {
                if (this._initialized) this._initialized = false;
            };
            Tabs.prototype.removeInstance = function() {
                this.destroy();
                dom_instances.removeInstance("Tabs", this._instanceId);
            };
            Tabs.prototype.destroyAndRemoveInstance = function() {
                this.destroy();
                this.removeInstance();
            };
            Tabs.prototype.getActiveTab = function() {
                return this._activeTab;
            };
            Tabs.prototype.setActiveTab = function(tab) {
                this._activeTab = tab;
            };
            Tabs.prototype.getTab = function(id) {
                return this._items.filter((function(t) {
                    return t.id === id;
                }))[0];
            };
            Tabs.prototype.show = function(id, forceShow) {
                var _a, _b;
                var _this = this;
                if (forceShow === void 0) forceShow = false;
                var tab = this.getTab(id);
                if (tab === this._activeTab && !forceShow) return;
                this._items.map((function(t) {
                    var _a, _b;
                    if (t !== tab) {
                        (_a = t.triggerEl.classList).remove.apply(_a, _this._options.activeClasses.split(" "));
                        (_b = t.triggerEl.classList).add.apply(_b, _this._options.inactiveClasses.split(" "));
                        t.targetEl.classList.add("hidden");
                        t.triggerEl.setAttribute("aria-selected", "false");
                    }
                }));
                (_a = tab.triggerEl.classList).add.apply(_a, this._options.activeClasses.split(" "));
                (_b = tab.triggerEl.classList).remove.apply(_b, this._options.inactiveClasses.split(" "));
                tab.triggerEl.setAttribute("aria-selected", "true");
                tab.targetEl.classList.remove("hidden");
                this.setActiveTab(tab);
                this._options.onShow(this, tab);
            };
            Tabs.prototype.updateOnShow = function(callback) {
                this._options.onShow = callback;
            };
            return Tabs;
        }();
        function initTabs() {
            document.querySelectorAll("[data-tabs-toggle]").forEach((function($parentEl) {
                var tabItems = [];
                var activeClasses = $parentEl.getAttribute("data-tabs-active-classes");
                var inactiveClasses = $parentEl.getAttribute("data-tabs-inactive-classes");
                var defaultTabId = null;
                $parentEl.querySelectorAll('[role="tab"]').forEach((function($triggerEl) {
                    var isActive = $triggerEl.getAttribute("aria-selected") === "true";
                    var tab = {
                        id: $triggerEl.getAttribute("data-tabs-target"),
                        triggerEl: $triggerEl,
                        targetEl: document.querySelector($triggerEl.getAttribute("data-tabs-target"))
                    };
                    tabItems.push(tab);
                    if (isActive) defaultTabId = tab.id;
                }));
                new Tabs($parentEl, tabItems, {
                    defaultTabId,
                    activeClasses: activeClasses ? activeClasses : tabs_Default.activeClasses,
                    inactiveClasses: inactiveClasses ? inactiveClasses : tabs_Default.inactiveClasses
                });
            }));
        }
        if (typeof window !== "undefined") {
            window.Tabs = Tabs;
            window.initTabs = initTabs;
        }
        var tooltip_assign = void 0 && (void 0).__assign || function() {
            tooltip_assign = Object.assign || function(t) {
                for (var s, i = 1, n = arguments.length; i < n; i++) {
                    s = arguments[i];
                    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
                }
                return t;
            };
            return tooltip_assign.apply(this, arguments);
        };
        var tooltip_spreadArray = void 0 && (void 0).__spreadArray || function(to, from, pack) {
            if (pack || arguments.length === 2) for (var ar, i = 0, l = from.length; i < l; i++) if (ar || !(i in from)) {
                if (!ar) ar = Array.prototype.slice.call(from, 0, i);
                ar[i] = from[i];
            }
            return to.concat(ar || Array.prototype.slice.call(from));
        };
        var tooltip_Default = {
            placement: "top",
            triggerType: "hover",
            onShow: function() {},
            onHide: function() {},
            onToggle: function() {}
        };
        var tooltip_DefaultInstanceOptions = {
            id: null,
            override: true
        };
        var Tooltip = function() {
            function Tooltip(targetEl, triggerEl, options, instanceOptions) {
                if (targetEl === void 0) targetEl = null;
                if (triggerEl === void 0) triggerEl = null;
                if (options === void 0) options = tooltip_Default;
                if (instanceOptions === void 0) instanceOptions = tooltip_DefaultInstanceOptions;
                this._instanceId = instanceOptions.id ? instanceOptions.id : targetEl.id;
                this._targetEl = targetEl;
                this._triggerEl = triggerEl;
                this._options = tooltip_assign(tooltip_assign({}, tooltip_Default), options);
                this._popperInstance = null;
                this._visible = false;
                this._initialized = false;
                this.init();
                dom_instances.addInstance("Tooltip", this, this._instanceId, instanceOptions.override);
            }
            Tooltip.prototype.init = function() {
                if (this._triggerEl && this._targetEl && !this._initialized) {
                    this._setupEventListeners();
                    this._popperInstance = this._createPopperInstance();
                    this._initialized = true;
                }
            };
            Tooltip.prototype.destroy = function() {
                var _this = this;
                if (this._initialized) {
                    var triggerEvents = this._getTriggerEvents();
                    triggerEvents.showEvents.forEach((function(ev) {
                        _this._triggerEl.removeEventListener(ev, _this._showHandler);
                    }));
                    triggerEvents.hideEvents.forEach((function(ev) {
                        _this._triggerEl.removeEventListener(ev, _this._hideHandler);
                    }));
                    this._removeKeydownListener();
                    this._removeClickOutsideListener();
                    if (this._popperInstance) this._popperInstance.destroy();
                    this._initialized = false;
                }
            };
            Tooltip.prototype.removeInstance = function() {
                dom_instances.removeInstance("Tooltip", this._instanceId);
            };
            Tooltip.prototype.destroyAndRemoveInstance = function() {
                this.destroy();
                this.removeInstance();
            };
            Tooltip.prototype._setupEventListeners = function() {
                var _this = this;
                var triggerEvents = this._getTriggerEvents();
                this._showHandler = function() {
                    _this.show();
                };
                this._hideHandler = function() {
                    _this.hide();
                };
                triggerEvents.showEvents.forEach((function(ev) {
                    _this._triggerEl.addEventListener(ev, _this._showHandler);
                }));
                triggerEvents.hideEvents.forEach((function(ev) {
                    _this._triggerEl.addEventListener(ev, _this._hideHandler);
                }));
            };
            Tooltip.prototype._createPopperInstance = function() {
                return popper_createPopper(this._triggerEl, this._targetEl, {
                    placement: this._options.placement,
                    modifiers: [ {
                        name: "offset",
                        options: {
                            offset: [ 0, 8 ]
                        }
                    } ]
                });
            };
            Tooltip.prototype._getTriggerEvents = function() {
                switch (this._options.triggerType) {
                  case "hover":
                    return {
                        showEvents: [ "mouseenter", "focus" ],
                        hideEvents: [ "mouseleave", "blur" ]
                    };

                  case "click":
                    return {
                        showEvents: [ "click", "focus" ],
                        hideEvents: [ "focusout", "blur" ]
                    };

                  case "none":
                    return {
                        showEvents: [],
                        hideEvents: []
                    };

                  default:
                    return {
                        showEvents: [ "mouseenter", "focus" ],
                        hideEvents: [ "mouseleave", "blur" ]
                    };
                }
            };
            Tooltip.prototype._setupKeydownListener = function() {
                var _this = this;
                this._keydownEventListener = function(ev) {
                    if (ev.key === "Escape") _this.hide();
                };
                document.body.addEventListener("keydown", this._keydownEventListener, true);
            };
            Tooltip.prototype._removeKeydownListener = function() {
                document.body.removeEventListener("keydown", this._keydownEventListener, true);
            };
            Tooltip.prototype._setupClickOutsideListener = function() {
                var _this = this;
                this._clickOutsideEventListener = function(ev) {
                    _this._handleClickOutside(ev, _this._targetEl);
                };
                document.body.addEventListener("click", this._clickOutsideEventListener, true);
            };
            Tooltip.prototype._removeClickOutsideListener = function() {
                document.body.removeEventListener("click", this._clickOutsideEventListener, true);
            };
            Tooltip.prototype._handleClickOutside = function(ev, targetEl) {
                var clickedEl = ev.target;
                if (clickedEl !== targetEl && !targetEl.contains(clickedEl) && !this._triggerEl.contains(clickedEl) && this.isVisible()) this.hide();
            };
            Tooltip.prototype.isVisible = function() {
                return this._visible;
            };
            Tooltip.prototype.toggle = function() {
                if (this.isVisible()) this.hide(); else this.show();
            };
            Tooltip.prototype.show = function() {
                this._targetEl.classList.remove("opacity-0", "invisible");
                this._targetEl.classList.add("opacity-100", "visible");
                this._popperInstance.setOptions((function(options) {
                    return tooltip_assign(tooltip_assign({}, options), {
                        modifiers: tooltip_spreadArray(tooltip_spreadArray([], options.modifiers, true), [ {
                            name: "eventListeners",
                            enabled: true
                        } ], false)
                    });
                }));
                this._setupClickOutsideListener();
                this._setupKeydownListener();
                this._popperInstance.update();
                this._visible = true;
                this._options.onShow(this);
            };
            Tooltip.prototype.hide = function() {
                this._targetEl.classList.remove("opacity-100", "visible");
                this._targetEl.classList.add("opacity-0", "invisible");
                this._popperInstance.setOptions((function(options) {
                    return tooltip_assign(tooltip_assign({}, options), {
                        modifiers: tooltip_spreadArray(tooltip_spreadArray([], options.modifiers, true), [ {
                            name: "eventListeners",
                            enabled: false
                        } ], false)
                    });
                }));
                this._removeClickOutsideListener();
                this._removeKeydownListener();
                this._visible = false;
                this._options.onHide(this);
            };
            Tooltip.prototype.updateOnShow = function(callback) {
                this._options.onShow = callback;
            };
            Tooltip.prototype.updateOnHide = function(callback) {
                this._options.onHide = callback;
            };
            Tooltip.prototype.updateOnToggle = function(callback) {
                this._options.onToggle = callback;
            };
            return Tooltip;
        }();
        function initTooltips() {
            document.querySelectorAll("[data-tooltip-target]").forEach((function($triggerEl) {
                var tooltipId = $triggerEl.getAttribute("data-tooltip-target");
                var $tooltipEl = document.getElementById(tooltipId);
                if ($tooltipEl) {
                    var triggerType = $triggerEl.getAttribute("data-tooltip-trigger");
                    var placement = $triggerEl.getAttribute("data-tooltip-placement");
                    new Tooltip($tooltipEl, $triggerEl, {
                        placement: placement ? placement : tooltip_Default.placement,
                        triggerType: triggerType ? triggerType : tooltip_Default.triggerType
                    });
                } else console.error('The tooltip element with id "'.concat(tooltipId, '" does not exist. Please check the data-tooltip-target attribute.'));
            }));
        }
        if (typeof window !== "undefined") {
            window.Tooltip = Tooltip;
            window.initTooltips = initTooltips;
        }
        var popover_assign = void 0 && (void 0).__assign || function() {
            popover_assign = Object.assign || function(t) {
                for (var s, i = 1, n = arguments.length; i < n; i++) {
                    s = arguments[i];
                    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
                }
                return t;
            };
            return popover_assign.apply(this, arguments);
        };
        var popover_spreadArray = void 0 && (void 0).__spreadArray || function(to, from, pack) {
            if (pack || arguments.length === 2) for (var ar, i = 0, l = from.length; i < l; i++) if (ar || !(i in from)) {
                if (!ar) ar = Array.prototype.slice.call(from, 0, i);
                ar[i] = from[i];
            }
            return to.concat(ar || Array.prototype.slice.call(from));
        };
        var popover_Default = {
            placement: "top",
            offset: 10,
            triggerType: "hover",
            onShow: function() {},
            onHide: function() {},
            onToggle: function() {}
        };
        var popover_DefaultInstanceOptions = {
            id: null,
            override: true
        };
        var Popover = function() {
            function Popover(targetEl, triggerEl, options, instanceOptions) {
                if (targetEl === void 0) targetEl = null;
                if (triggerEl === void 0) triggerEl = null;
                if (options === void 0) options = popover_Default;
                if (instanceOptions === void 0) instanceOptions = popover_DefaultInstanceOptions;
                this._instanceId = instanceOptions.id ? instanceOptions.id : targetEl.id;
                this._targetEl = targetEl;
                this._triggerEl = triggerEl;
                this._options = popover_assign(popover_assign({}, popover_Default), options);
                this._popperInstance = null;
                this._visible = false;
                this._initialized = false;
                this.init();
                dom_instances.addInstance("Popover", this, instanceOptions.id ? instanceOptions.id : this._targetEl.id, instanceOptions.override);
            }
            Popover.prototype.init = function() {
                if (this._triggerEl && this._targetEl && !this._initialized) {
                    this._setupEventListeners();
                    this._popperInstance = this._createPopperInstance();
                    this._initialized = true;
                }
            };
            Popover.prototype.destroy = function() {
                var _this = this;
                if (this._initialized) {
                    var triggerEvents = this._getTriggerEvents();
                    triggerEvents.showEvents.forEach((function(ev) {
                        _this._triggerEl.removeEventListener(ev, _this._showHandler);
                        _this._targetEl.removeEventListener(ev, _this._showHandler);
                    }));
                    triggerEvents.hideEvents.forEach((function(ev) {
                        _this._triggerEl.removeEventListener(ev, _this._hideHandler);
                        _this._targetEl.removeEventListener(ev, _this._hideHandler);
                    }));
                    this._removeKeydownListener();
                    this._removeClickOutsideListener();
                    if (this._popperInstance) this._popperInstance.destroy();
                    this._initialized = false;
                }
            };
            Popover.prototype.removeInstance = function() {
                dom_instances.removeInstance("Popover", this._instanceId);
            };
            Popover.prototype.destroyAndRemoveInstance = function() {
                this.destroy();
                this.removeInstance();
            };
            Popover.prototype._setupEventListeners = function() {
                var _this = this;
                var triggerEvents = this._getTriggerEvents();
                this._showHandler = function() {
                    _this.show();
                };
                this._hideHandler = function() {
                    setTimeout((function() {
                        if (!_this._targetEl.matches(":hover")) _this.hide();
                    }), 100);
                };
                triggerEvents.showEvents.forEach((function(ev) {
                    _this._triggerEl.addEventListener(ev, _this._showHandler);
                    _this._targetEl.addEventListener(ev, _this._showHandler);
                }));
                triggerEvents.hideEvents.forEach((function(ev) {
                    _this._triggerEl.addEventListener(ev, _this._hideHandler);
                    _this._targetEl.addEventListener(ev, _this._hideHandler);
                }));
            };
            Popover.prototype._createPopperInstance = function() {
                return popper_createPopper(this._triggerEl, this._targetEl, {
                    placement: this._options.placement,
                    modifiers: [ {
                        name: "offset",
                        options: {
                            offset: [ 0, this._options.offset ]
                        }
                    } ]
                });
            };
            Popover.prototype._getTriggerEvents = function() {
                switch (this._options.triggerType) {
                  case "hover":
                    return {
                        showEvents: [ "mouseenter", "focus" ],
                        hideEvents: [ "mouseleave", "blur" ]
                    };

                  case "click":
                    return {
                        showEvents: [ "click", "focus" ],
                        hideEvents: [ "focusout", "blur" ]
                    };

                  case "none":
                    return {
                        showEvents: [],
                        hideEvents: []
                    };

                  default:
                    return {
                        showEvents: [ "mouseenter", "focus" ],
                        hideEvents: [ "mouseleave", "blur" ]
                    };
                }
            };
            Popover.prototype._setupKeydownListener = function() {
                var _this = this;
                this._keydownEventListener = function(ev) {
                    if (ev.key === "Escape") _this.hide();
                };
                document.body.addEventListener("keydown", this._keydownEventListener, true);
            };
            Popover.prototype._removeKeydownListener = function() {
                document.body.removeEventListener("keydown", this._keydownEventListener, true);
            };
            Popover.prototype._setupClickOutsideListener = function() {
                var _this = this;
                this._clickOutsideEventListener = function(ev) {
                    _this._handleClickOutside(ev, _this._targetEl);
                };
                document.body.addEventListener("click", this._clickOutsideEventListener, true);
            };
            Popover.prototype._removeClickOutsideListener = function() {
                document.body.removeEventListener("click", this._clickOutsideEventListener, true);
            };
            Popover.prototype._handleClickOutside = function(ev, targetEl) {
                var clickedEl = ev.target;
                if (clickedEl !== targetEl && !targetEl.contains(clickedEl) && !this._triggerEl.contains(clickedEl) && this.isVisible()) this.hide();
            };
            Popover.prototype.isVisible = function() {
                return this._visible;
            };
            Popover.prototype.toggle = function() {
                if (this.isVisible()) this.hide(); else this.show();
                this._options.onToggle(this);
            };
            Popover.prototype.show = function() {
                this._targetEl.classList.remove("opacity-0", "invisible");
                this._targetEl.classList.add("opacity-100", "visible");
                this._popperInstance.setOptions((function(options) {
                    return popover_assign(popover_assign({}, options), {
                        modifiers: popover_spreadArray(popover_spreadArray([], options.modifiers, true), [ {
                            name: "eventListeners",
                            enabled: true
                        } ], false)
                    });
                }));
                this._setupClickOutsideListener();
                this._setupKeydownListener();
                this._popperInstance.update();
                this._visible = true;
                this._options.onShow(this);
            };
            Popover.prototype.hide = function() {
                this._targetEl.classList.remove("opacity-100", "visible");
                this._targetEl.classList.add("opacity-0", "invisible");
                this._popperInstance.setOptions((function(options) {
                    return popover_assign(popover_assign({}, options), {
                        modifiers: popover_spreadArray(popover_spreadArray([], options.modifiers, true), [ {
                            name: "eventListeners",
                            enabled: false
                        } ], false)
                    });
                }));
                this._removeClickOutsideListener();
                this._removeKeydownListener();
                this._visible = false;
                this._options.onHide(this);
            };
            Popover.prototype.updateOnShow = function(callback) {
                this._options.onShow = callback;
            };
            Popover.prototype.updateOnHide = function(callback) {
                this._options.onHide = callback;
            };
            Popover.prototype.updateOnToggle = function(callback) {
                this._options.onToggle = callback;
            };
            return Popover;
        }();
        function initPopovers() {
            document.querySelectorAll("[data-popover-target]").forEach((function($triggerEl) {
                var popoverID = $triggerEl.getAttribute("data-popover-target");
                var $popoverEl = document.getElementById(popoverID);
                if ($popoverEl) {
                    var triggerType = $triggerEl.getAttribute("data-popover-trigger");
                    var placement = $triggerEl.getAttribute("data-popover-placement");
                    var offset = $triggerEl.getAttribute("data-popover-offset");
                    new Popover($popoverEl, $triggerEl, {
                        placement: placement ? placement : popover_Default.placement,
                        offset: offset ? parseInt(offset) : popover_Default.offset,
                        triggerType: triggerType ? triggerType : popover_Default.triggerType
                    });
                } else console.error('The popover element with id "'.concat(popoverID, '" does not exist. Please check the data-popover-target attribute.'));
            }));
        }
        if (typeof window !== "undefined") {
            window.Popover = Popover;
            window.initPopovers = initPopovers;
        }
        var dial_assign = void 0 && (void 0).__assign || function() {
            dial_assign = Object.assign || function(t) {
                for (var s, i = 1, n = arguments.length; i < n; i++) {
                    s = arguments[i];
                    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
                }
                return t;
            };
            return dial_assign.apply(this, arguments);
        };
        var dial_Default = {
            triggerType: "hover",
            onShow: function() {},
            onHide: function() {},
            onToggle: function() {}
        };
        var dial_DefaultInstanceOptions = {
            id: null,
            override: true
        };
        var Dial = function() {
            function Dial(parentEl, triggerEl, targetEl, options, instanceOptions) {
                if (parentEl === void 0) parentEl = null;
                if (triggerEl === void 0) triggerEl = null;
                if (targetEl === void 0) targetEl = null;
                if (options === void 0) options = dial_Default;
                if (instanceOptions === void 0) instanceOptions = dial_DefaultInstanceOptions;
                this._instanceId = instanceOptions.id ? instanceOptions.id : targetEl.id;
                this._parentEl = parentEl;
                this._triggerEl = triggerEl;
                this._targetEl = targetEl;
                this._options = dial_assign(dial_assign({}, dial_Default), options);
                this._visible = false;
                this._initialized = false;
                this.init();
                dom_instances.addInstance("Dial", this, this._instanceId, instanceOptions.override);
            }
            Dial.prototype.init = function() {
                var _this = this;
                if (this._triggerEl && this._targetEl && !this._initialized) {
                    var triggerEventTypes = this._getTriggerEventTypes(this._options.triggerType);
                    this._showEventHandler = function() {
                        _this.show();
                    };
                    triggerEventTypes.showEvents.forEach((function(ev) {
                        _this._triggerEl.addEventListener(ev, _this._showEventHandler);
                        _this._targetEl.addEventListener(ev, _this._showEventHandler);
                    }));
                    this._hideEventHandler = function() {
                        if (!_this._parentEl.matches(":hover")) _this.hide();
                    };
                    triggerEventTypes.hideEvents.forEach((function(ev) {
                        _this._parentEl.addEventListener(ev, _this._hideEventHandler);
                    }));
                    this._initialized = true;
                }
            };
            Dial.prototype.destroy = function() {
                var _this = this;
                if (this._initialized) {
                    var triggerEventTypes = this._getTriggerEventTypes(this._options.triggerType);
                    triggerEventTypes.showEvents.forEach((function(ev) {
                        _this._triggerEl.removeEventListener(ev, _this._showEventHandler);
                        _this._targetEl.removeEventListener(ev, _this._showEventHandler);
                    }));
                    triggerEventTypes.hideEvents.forEach((function(ev) {
                        _this._parentEl.removeEventListener(ev, _this._hideEventHandler);
                    }));
                    this._initialized = false;
                }
            };
            Dial.prototype.removeInstance = function() {
                dom_instances.removeInstance("Dial", this._instanceId);
            };
            Dial.prototype.destroyAndRemoveInstance = function() {
                this.destroy();
                this.removeInstance();
            };
            Dial.prototype.hide = function() {
                this._targetEl.classList.add("hidden");
                if (this._triggerEl) this._triggerEl.setAttribute("aria-expanded", "false");
                this._visible = false;
                this._options.onHide(this);
            };
            Dial.prototype.show = function() {
                this._targetEl.classList.remove("hidden");
                if (this._triggerEl) this._triggerEl.setAttribute("aria-expanded", "true");
                this._visible = true;
                this._options.onShow(this);
            };
            Dial.prototype.toggle = function() {
                if (this._visible) this.hide(); else this.show();
            };
            Dial.prototype.isHidden = function() {
                return !this._visible;
            };
            Dial.prototype.isVisible = function() {
                return this._visible;
            };
            Dial.prototype._getTriggerEventTypes = function(triggerType) {
                switch (triggerType) {
                  case "hover":
                    return {
                        showEvents: [ "mouseenter", "focus" ],
                        hideEvents: [ "mouseleave", "blur" ]
                    };

                  case "click":
                    return {
                        showEvents: [ "click", "focus" ],
                        hideEvents: [ "focusout", "blur" ]
                    };

                  case "none":
                    return {
                        showEvents: [],
                        hideEvents: []
                    };

                  default:
                    return {
                        showEvents: [ "mouseenter", "focus" ],
                        hideEvents: [ "mouseleave", "blur" ]
                    };
                }
            };
            Dial.prototype.updateOnShow = function(callback) {
                this._options.onShow = callback;
            };
            Dial.prototype.updateOnHide = function(callback) {
                this._options.onHide = callback;
            };
            Dial.prototype.updateOnToggle = function(callback) {
                this._options.onToggle = callback;
            };
            return Dial;
        }();
        function initDials() {
            document.querySelectorAll("[data-dial-init]").forEach((function($parentEl) {
                var $triggerEl = $parentEl.querySelector("[data-dial-toggle]");
                if ($triggerEl) {
                    var dialId = $triggerEl.getAttribute("data-dial-toggle");
                    var $dialEl = document.getElementById(dialId);
                    if ($dialEl) {
                        var triggerType = $triggerEl.getAttribute("data-dial-trigger");
                        new Dial($parentEl, $triggerEl, $dialEl, {
                            triggerType: triggerType ? triggerType : dial_Default.triggerType
                        });
                    } else console.error("Dial with id ".concat(dialId, " does not exist. Are you sure that the data-dial-toggle attribute points to the correct modal id?"));
                } else console.error("Dial with id ".concat($parentEl.id, " does not have a trigger element. Are you sure that the data-dial-toggle attribute exists?"));
            }));
        }
        if (typeof window !== "undefined") {
            window.Dial = Dial;
            window.initDials = initDials;
        }
        var input_counter_assign = void 0 && (void 0).__assign || function() {
            input_counter_assign = Object.assign || function(t) {
                for (var s, i = 1, n = arguments.length; i < n; i++) {
                    s = arguments[i];
                    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
                }
                return t;
            };
            return input_counter_assign.apply(this, arguments);
        };
        var input_counter_Default = {
            minValue: null,
            maxValue: null,
            onIncrement: function() {},
            onDecrement: function() {}
        };
        var input_counter_DefaultInstanceOptions = {
            id: null,
            override: true
        };
        var InputCounter = function() {
            function InputCounter(targetEl, incrementEl, decrementEl, options, instanceOptions) {
                if (targetEl === void 0) targetEl = null;
                if (incrementEl === void 0) incrementEl = null;
                if (decrementEl === void 0) decrementEl = null;
                if (options === void 0) options = input_counter_Default;
                if (instanceOptions === void 0) instanceOptions = input_counter_DefaultInstanceOptions;
                this._instanceId = instanceOptions.id ? instanceOptions.id : targetEl.id;
                this._targetEl = targetEl;
                this._incrementEl = incrementEl;
                this._decrementEl = decrementEl;
                this._options = input_counter_assign(input_counter_assign({}, input_counter_Default), options);
                this._initialized = false;
                this.init();
                dom_instances.addInstance("InputCounter", this, this._instanceId, instanceOptions.override);
            }
            InputCounter.prototype.init = function() {
                var _this = this;
                if (this._targetEl && !this._initialized) {
                    this._inputHandler = function(event) {
                        var target = event.target;
                        if (!/^\d*$/.test(target.value)) target.value = target.value.replace(/[^\d]/g, "");
                        if (_this._options.maxValue !== null && parseInt(target.value) > _this._options.maxValue) target.value = _this._options.maxValue.toString();
                        if (_this._options.minValue !== null && parseInt(target.value) < _this._options.minValue) target.value = _this._options.minValue.toString();
                    };
                    this._incrementClickHandler = function() {
                        _this.increment();
                    };
                    this._decrementClickHandler = function() {
                        _this.decrement();
                    };
                    this._targetEl.addEventListener("input", this._inputHandler);
                    if (this._incrementEl) this._incrementEl.addEventListener("click", this._incrementClickHandler);
                    if (this._decrementEl) this._decrementEl.addEventListener("click", this._decrementClickHandler);
                    this._initialized = true;
                }
            };
            InputCounter.prototype.destroy = function() {
                if (this._targetEl && this._initialized) {
                    this._targetEl.removeEventListener("input", this._inputHandler);
                    if (this._incrementEl) this._incrementEl.removeEventListener("click", this._incrementClickHandler);
                    if (this._decrementEl) this._decrementEl.removeEventListener("click", this._decrementClickHandler);
                    this._initialized = false;
                }
            };
            InputCounter.prototype.removeInstance = function() {
                dom_instances.removeInstance("InputCounter", this._instanceId);
            };
            InputCounter.prototype.destroyAndRemoveInstance = function() {
                this.destroy();
                this.removeInstance();
            };
            InputCounter.prototype.getCurrentValue = function() {
                return parseInt(this._targetEl.value) || 0;
            };
            InputCounter.prototype.increment = function() {
                if (this._options.maxValue !== null && this.getCurrentValue() >= this._options.maxValue) return;
                this._targetEl.value = (this.getCurrentValue() + 1).toString();
                this._options.onIncrement(this);
            };
            InputCounter.prototype.decrement = function() {
                if (this._options.minValue !== null && this.getCurrentValue() <= this._options.minValue) return;
                this._targetEl.value = (this.getCurrentValue() - 1).toString();
                this._options.onDecrement(this);
            };
            InputCounter.prototype.updateOnIncrement = function(callback) {
                this._options.onIncrement = callback;
            };
            InputCounter.prototype.updateOnDecrement = function(callback) {
                this._options.onDecrement = callback;
            };
            return InputCounter;
        }();
        function initInputCounters() {
            document.querySelectorAll("[data-input-counter]").forEach((function($targetEl) {
                var targetId = $targetEl.id;
                var $incrementEl = document.querySelector('[data-input-counter-increment="' + targetId + '"]');
                var $decrementEl = document.querySelector('[data-input-counter-decrement="' + targetId + '"]');
                var minValue = $targetEl.getAttribute("data-input-counter-min");
                var maxValue = $targetEl.getAttribute("data-input-counter-max");
                if ($targetEl) {
                    if (!dom_instances.instanceExists("InputCounter", $targetEl.getAttribute("id"))) new InputCounter($targetEl, $incrementEl ? $incrementEl : null, $decrementEl ? $decrementEl : null, {
                        minValue: minValue ? parseInt(minValue) : null,
                        maxValue: maxValue ? parseInt(maxValue) : null
                    });
                } else console.error('The target element with id "'.concat(targetId, '" does not exist. Please check the data-input-counter attribute.'));
            }));
        }
        if (typeof window !== "undefined") {
            window.InputCounter = InputCounter;
            window.initInputCounters = initInputCounters;
        }
        var clipboard_assign = void 0 && (void 0).__assign || function() {
            clipboard_assign = Object.assign || function(t) {
                for (var s, i = 1, n = arguments.length; i < n; i++) {
                    s = arguments[i];
                    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
                }
                return t;
            };
            return clipboard_assign.apply(this, arguments);
        };
        var clipboard_Default = {
            htmlEntities: false,
            contentType: "input",
            onCopy: function() {}
        };
        var clipboard_DefaultInstanceOptions = {
            id: null,
            override: true
        };
        var CopyClipboard = function() {
            function CopyClipboard(triggerEl, targetEl, options, instanceOptions) {
                if (triggerEl === void 0) triggerEl = null;
                if (targetEl === void 0) targetEl = null;
                if (options === void 0) options = clipboard_Default;
                if (instanceOptions === void 0) instanceOptions = clipboard_DefaultInstanceOptions;
                this._instanceId = instanceOptions.id ? instanceOptions.id : targetEl.id;
                this._triggerEl = triggerEl;
                this._targetEl = targetEl;
                this._options = clipboard_assign(clipboard_assign({}, clipboard_Default), options);
                this._initialized = false;
                this.init();
                dom_instances.addInstance("CopyClipboard", this, this._instanceId, instanceOptions.override);
            }
            CopyClipboard.prototype.init = function() {
                var _this = this;
                if (this._targetEl && this._triggerEl && !this._initialized) {
                    this._triggerElClickHandler = function() {
                        _this.copy();
                    };
                    if (this._triggerEl) this._triggerEl.addEventListener("click", this._triggerElClickHandler);
                    this._initialized = true;
                }
            };
            CopyClipboard.prototype.destroy = function() {
                if (this._triggerEl && this._targetEl && this._initialized) {
                    if (this._triggerEl) this._triggerEl.removeEventListener("click", this._triggerElClickHandler);
                    this._initialized = false;
                }
            };
            CopyClipboard.prototype.removeInstance = function() {
                dom_instances.removeInstance("CopyClipboard", this._instanceId);
            };
            CopyClipboard.prototype.destroyAndRemoveInstance = function() {
                this.destroy();
                this.removeInstance();
            };
            CopyClipboard.prototype.getTargetValue = function() {
                if (this._options.contentType === "input") return this._targetEl.value;
                if (this._options.contentType === "innerHTML") return this._targetEl.innerHTML;
                if (this._options.contentType === "textContent") return this._targetEl.textContent.replace(/\s+/g, " ").trim();
            };
            CopyClipboard.prototype.copy = function() {
                var textToCopy = this.getTargetValue();
                if (this._options.htmlEntities) textToCopy = this.decodeHTML(textToCopy);
                var tempTextArea = document.createElement("textarea");
                tempTextArea.value = textToCopy;
                document.body.appendChild(tempTextArea);
                tempTextArea.select();
                document.execCommand("copy");
                document.body.removeChild(tempTextArea);
                this._options.onCopy(this);
                return textToCopy;
            };
            CopyClipboard.prototype.decodeHTML = function(html) {
                var textarea = document.createElement("textarea");
                textarea.innerHTML = html;
                return textarea.textContent;
            };
            CopyClipboard.prototype.updateOnCopyCallback = function(callback) {
                this._options.onCopy = callback;
            };
            return CopyClipboard;
        }();
        function initCopyClipboards() {
            document.querySelectorAll("[data-copy-to-clipboard-target]").forEach((function($triggerEl) {
                var targetId = $triggerEl.getAttribute("data-copy-to-clipboard-target");
                var $targetEl = document.getElementById(targetId);
                var contentType = $triggerEl.getAttribute("data-copy-to-clipboard-content-type");
                var htmlEntities = $triggerEl.getAttribute("data-copy-to-clipboard-html-entities");
                if ($targetEl) {
                    if (!dom_instances.instanceExists("CopyClipboard", $targetEl.getAttribute("id"))) new CopyClipboard($triggerEl, $targetEl, {
                        htmlEntities: htmlEntities && htmlEntities === "true" ? true : clipboard_Default.htmlEntities,
                        contentType: contentType ? contentType : clipboard_Default.contentType
                    });
                } else console.error('The target element with id "'.concat(targetId, '" does not exist. Please check the data-copy-to-clipboard-target attribute.'));
            }));
        }
        if (typeof window !== "undefined") {
            window.CopyClipboard = CopyClipboard;
            window.initClipboards = initCopyClipboards;
        }
        function _arrayLikeToArray(r, a) {
            (null == a || a > r.length) && (a = r.length);
            for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e];
            return n;
        }
        function _arrayWithHoles(r) {
            if (Array.isArray(r)) return r;
        }
        function _arrayWithoutHoles(r) {
            if (Array.isArray(r)) return _arrayLikeToArray(r);
        }
        function _assertThisInitialized(e) {
            if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            return e;
        }
        function _callSuper(t, o, e) {
            return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e));
        }
        function _classCallCheck(a, n) {
            if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function");
        }
        function _defineProperties(e, r) {
            for (var t = 0; t < r.length; t++) {
                var o = r[t];
                o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), 
                Object.defineProperty(e, _toPropertyKey(o.key), o);
            }
        }
        function _createClass(e, r, t) {
            return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", {
                writable: !1
            }), e;
        }
        function _get() {
            return _get = "undefined" != typeof Reflect && Reflect.get ? Reflect.get.bind() : function(e, t, r) {
                var p = _superPropBase(e, t);
                if (p) {
                    var n = Object.getOwnPropertyDescriptor(p, t);
                    return n.get ? n.get.call(arguments.length < 3 ? e : r) : n.value;
                }
            }, _get.apply(null, arguments);
        }
        function _getPrototypeOf(t) {
            return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(t) {
                return t.__proto__ || Object.getPrototypeOf(t);
            }, _getPrototypeOf(t);
        }
        function _inherits(t, e) {
            if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
            t.prototype = Object.create(e && e.prototype, {
                constructor: {
                    value: t,
                    writable: !0,
                    configurable: !0
                }
            }), Object.defineProperty(t, "prototype", {
                writable: !1
            }), e && _setPrototypeOf(t, e);
        }
        function _isNativeReflectConstruct() {
            try {
                var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], (function() {})));
            } catch (t) {}
            return (_isNativeReflectConstruct = function() {
                return !!t;
            })();
        }
        function _iterableToArray(r) {
            if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r);
        }
        function _iterableToArrayLimit(r, l) {
            var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
            if (null != t) {
                var e, n, i, u, a = [], f = !0, o = !1;
                try {
                    if (i = (t = t.call(r)).next, 0 === l) {
                        if (Object(t) !== t) return;
                        f = !1;
                    } else for (;!(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0) ;
                } catch (r) {
                    o = !0, n = r;
                } finally {
                    try {
                        if (!f && null != t.return && (u = t.return(), Object(u) !== u)) return;
                    } finally {
                        if (o) throw n;
                    }
                }
                return a;
            }
        }
        function _nonIterableRest() {
            throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
        }
        function _nonIterableSpread() {
            throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
        }
        function _possibleConstructorReturn(t, e) {
            if (e && ("object" == typeof e || "function" == typeof e)) return e;
            if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined");
            return _assertThisInitialized(t);
        }
        function _setPrototypeOf(t, e) {
            return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(t, e) {
                return t.__proto__ = e, t;
            }, _setPrototypeOf(t, e);
        }
        function _slicedToArray(r, e) {
            return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest();
        }
        function _superPropBase(t, o) {
            for (;!{}.hasOwnProperty.call(t, o) && null !== (t = _getPrototypeOf(t)); ) ;
            return t;
        }
        function _toConsumableArray(r) {
            return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread();
        }
        function _toPrimitive(t, r) {
            if ("object" != typeof t || !t) return t;
            var e = t[Symbol.toPrimitive];
            if (void 0 !== e) {
                var i = e.call(t, r || "default");
                if ("object" != typeof i) return i;
                throw new TypeError("@@toPrimitive must return a primitive value.");
            }
            return ("string" === r ? String : Number)(t);
        }
        function _toPropertyKey(t) {
            var i = _toPrimitive(t, "string");
            return "symbol" == typeof i ? i : i + "";
        }
        function _typeof(o) {
            "@babel/helpers - typeof";
            return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o) {
                return typeof o;
            } : function(o) {
                return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o;
            }, _typeof(o);
        }
        function _unsupportedIterableToArray(r, a) {
            if (r) {
                if ("string" == typeof r) return _arrayLikeToArray(r, a);
                var t = {}.toString.call(r).slice(8, -1);
                return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0;
            }
        }
        function hasProperty(obj, prop) {
            return Object.prototype.hasOwnProperty.call(obj, prop);
        }
        function lastItemOf(arr) {
            return arr[arr.length - 1];
        }
        function pushUnique(arr) {
            for (var _len = arguments.length, items = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) items[_key - 1] = arguments[_key];
            items.forEach((function(item) {
                if (arr.includes(item)) return;
                arr.push(item);
            }));
            return arr;
        }
        function stringToArray(str, separator) {
            return str ? str.split(separator) : [];
        }
        function isInRange(testVal, min, max) {
            var minOK = min === void 0 || testVal >= min;
            var maxOK = max === void 0 || testVal <= max;
            return minOK && maxOK;
        }
        function limitToRange(val, min, max) {
            if (val < min) return min;
            if (val > max) return max;
            return val;
        }
        function createTagRepeat(tagName, repeat) {
            var attributes = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
            var index = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0;
            var html = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : "";
            var openTagSrc = Object.keys(attributes).reduce((function(src, attr) {
                var val = attributes[attr];
                if (typeof val === "function") val = val(index);
                return "".concat(src, " ").concat(attr, '="').concat(val, '"');
            }), tagName);
            html += "<".concat(openTagSrc, "></").concat(tagName, ">");
            var next = index + 1;
            return next < repeat ? createTagRepeat(tagName, repeat, attributes, next, html) : html;
        }
        function optimizeTemplateHTML(html) {
            return html.replace(/>\s+/g, ">").replace(/\s+</, "<");
        }
        function stripTime(timeValue) {
            return new Date(timeValue).setHours(0, 0, 0, 0);
        }
        function today() {
            return (new Date).setHours(0, 0, 0, 0);
        }
        function dateValue() {
            switch (arguments.length) {
              case 0:
                return today();

              case 1:
                return stripTime(arguments.length <= 0 ? void 0 : arguments[0]);
            }
            var newDate = new Date(0);
            newDate.setFullYear.apply(newDate, arguments);
            return newDate.setHours(0, 0, 0, 0);
        }
        function addDays(date, amount) {
            var newDate = new Date(date);
            return newDate.setDate(newDate.getDate() + amount);
        }
        function addWeeks(date, amount) {
            return addDays(date, amount * 7);
        }
        function addMonths(date, amount) {
            var newDate = new Date(date);
            var monthsToSet = newDate.getMonth() + amount;
            var expectedMonth = monthsToSet % 12;
            if (expectedMonth < 0) expectedMonth += 12;
            var time = newDate.setMonth(monthsToSet);
            return newDate.getMonth() !== expectedMonth ? newDate.setDate(0) : time;
        }
        function addYears(date, amount) {
            var newDate = new Date(date);
            var expectedMonth = newDate.getMonth();
            var time = newDate.setFullYear(newDate.getFullYear() + amount);
            return expectedMonth === 1 && newDate.getMonth() === 2 ? newDate.setDate(0) : time;
        }
        function dayDiff(day, from) {
            return (day - from + 7) % 7;
        }
        function dayOfTheWeekOf(baseDate, dayOfWeek) {
            var weekStart = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
            var baseDay = new Date(baseDate).getDay();
            return addDays(baseDate, dayDiff(dayOfWeek, weekStart) - dayDiff(baseDay, weekStart));
        }
        function getWeek(date) {
            var thuOfTheWeek = dayOfTheWeekOf(date, 4, 1);
            var firstThu = dayOfTheWeekOf(new Date(thuOfTheWeek).setMonth(0, 4), 4, 1);
            return Math.round((thuOfTheWeek - firstThu) / 6048e5) + 1;
        }
        function startOfYearPeriod(date, years) {
            var year = new Date(date).getFullYear();
            return Math.floor(year / years) * years;
        }
        var reFormatTokens = /dd?|DD?|mm?|MM?|yy?(?:yy)?/;
        var reNonDateParts = /[\s!-/:-@[-`{-~年月日]+/;
        var knownFormats = {};
        var parseFns = {
            y: function y(date, year) {
                return new Date(date).setFullYear(parseInt(year, 10));
            },
            m: function m(date, month, locale) {
                var newDate = new Date(date);
                var monthIndex = parseInt(month, 10) - 1;
                if (isNaN(monthIndex)) {
                    if (!month) return NaN;
                    var monthName = month.toLowerCase();
                    var compareNames = function compareNames(name) {
                        return name.toLowerCase().startsWith(monthName);
                    };
                    monthIndex = locale.monthsShort.findIndex(compareNames);
                    if (monthIndex < 0) monthIndex = locale.months.findIndex(compareNames);
                    if (monthIndex < 0) return NaN;
                }
                newDate.setMonth(monthIndex);
                return newDate.getMonth() !== normalizeMonth(monthIndex) ? newDate.setDate(0) : newDate.getTime();
            },
            d: function d(date, day) {
                return new Date(date).setDate(parseInt(day, 10));
            }
        };
        var formatFns = {
            d: function d(date) {
                return date.getDate();
            },
            dd: function dd(date) {
                return padZero(date.getDate(), 2);
            },
            D: function D(date, locale) {
                return locale.daysShort[date.getDay()];
            },
            DD: function DD(date, locale) {
                return locale.days[date.getDay()];
            },
            m: function m(date) {
                return date.getMonth() + 1;
            },
            mm: function mm(date) {
                return padZero(date.getMonth() + 1, 2);
            },
            M: function M(date, locale) {
                return locale.monthsShort[date.getMonth()];
            },
            MM: function MM(date, locale) {
                return locale.months[date.getMonth()];
            },
            y: function y(date) {
                return date.getFullYear();
            },
            yy: function yy(date) {
                return padZero(date.getFullYear(), 2).slice(-2);
            },
            yyyy: function yyyy(date) {
                return padZero(date.getFullYear(), 4);
            }
        };
        function normalizeMonth(monthIndex) {
            return monthIndex > -1 ? monthIndex % 12 : normalizeMonth(monthIndex + 12);
        }
        function padZero(num, length) {
            return num.toString().padStart(length, "0");
        }
        function parseFormatString(format) {
            if (typeof format !== "string") throw new Error("Invalid date format.");
            if (format in knownFormats) return knownFormats[format];
            var separators = format.split(reFormatTokens);
            var parts = format.match(new RegExp(reFormatTokens, "g"));
            if (separators.length === 0 || !parts) throw new Error("Invalid date format.");
            var partFormatters = parts.map((function(token) {
                return formatFns[token];
            }));
            var partParserKeys = Object.keys(parseFns).reduce((function(keys, key) {
                var token = parts.find((function(part) {
                    return part[0] !== "D" && part[0].toLowerCase() === key;
                }));
                if (token) keys.push(key);
                return keys;
            }), []);
            return knownFormats[format] = {
                parser: function parser(dateStr, locale) {
                    var dateParts = dateStr.split(reNonDateParts).reduce((function(dtParts, part, index) {
                        if (part.length > 0 && parts[index]) {
                            var token = parts[index][0];
                            if (token === "M") dtParts.m = part; else if (token !== "D") dtParts[token] = part;
                        }
                        return dtParts;
                    }), {});
                    return partParserKeys.reduce((function(origDate, key) {
                        var newDate = parseFns[key](origDate, dateParts[key], locale);
                        return isNaN(newDate) ? origDate : newDate;
                    }), today());
                },
                formatter: function formatter(date, locale) {
                    var dateStr = partFormatters.reduce((function(str, fn, index) {
                        return str += "".concat(separators[index]).concat(fn(date, locale));
                    }), "");
                    return dateStr += lastItemOf(separators);
                }
            };
        }
        function parseDate(dateStr, format, locale) {
            if (dateStr instanceof Date || typeof dateStr === "number") {
                var date = stripTime(dateStr);
                return isNaN(date) ? void 0 : date;
            }
            if (!dateStr) return;
            if (dateStr === "today") return today();
            if (format && format.toValue) {
                var _date = format.toValue(dateStr, format, locale);
                return isNaN(_date) ? void 0 : stripTime(_date);
            }
            return parseFormatString(format).parser(dateStr, locale);
        }
        function formatDate(date, format, locale) {
            if (isNaN(date) || !date && date !== 0) return "";
            var dateObj = typeof date === "number" ? new Date(date) : date;
            if (format.toDisplay) return format.toDisplay(dateObj, format, locale);
            return parseFormatString(format).formatter(dateObj, locale);
        }
        var listenerRegistry = new WeakMap;
        var _EventTarget$prototyp = EventTarget.prototype, addEventListener = _EventTarget$prototyp.addEventListener, removeEventListener = _EventTarget$prototyp.removeEventListener;
        function registerListeners(keyObj, listeners) {
            var registered = listenerRegistry.get(keyObj);
            if (!registered) {
                registered = [];
                listenerRegistry.set(keyObj, registered);
            }
            listeners.forEach((function(listener) {
                addEventListener.call.apply(addEventListener, _toConsumableArray(listener));
                registered.push(listener);
            }));
        }
        function unregisterListeners(keyObj) {
            var listeners = listenerRegistry.get(keyObj);
            if (!listeners) return;
            listeners.forEach((function(listener) {
                removeEventListener.call.apply(removeEventListener, _toConsumableArray(listener));
            }));
            listenerRegistry["delete"](keyObj);
        }
        if (!Event.prototype.composedPath) {
            var getComposedPath = function getComposedPath(node) {
                var path = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
                path.push(node);
                var parent;
                if (node.parentNode) parent = node.parentNode; else if (node.host) parent = node.host; else if (node.defaultView) parent = node.defaultView;
                return parent ? getComposedPath(parent, path) : path;
            };
            Event.prototype.composedPath = function() {
                return getComposedPath(this.target);
            };
        }
        function findFromPath(path, criteria, currentTarget) {
            var index = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0;
            var el = path[index];
            if (criteria(el)) return el; else if (el === currentTarget || !el.parentElement) return;
            return findFromPath(path, criteria, currentTarget, index + 1);
        }
        function findElementInEventPath(ev, selector) {
            var criteria = typeof selector === "function" ? selector : function(el) {
                return el.matches(selector);
            };
            return findFromPath(ev.composedPath(), criteria, ev.currentTarget);
        }
        var locales = {
            en: {
                days: [ "Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday" ],
                daysShort: [ "Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat" ],
                daysMin: [ "Su", "Mo", "Tu", "We", "Th", "Fr", "Sa" ],
                months: [ "January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December" ],
                monthsShort: [ "Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec" ],
                today: "Today",
                clear: "Clear",
                titleFormat: "MM y"
            }
        };
        var defaultOptions = {
            autohide: false,
            beforeShowDay: null,
            beforeShowDecade: null,
            beforeShowMonth: null,
            beforeShowYear: null,
            calendarWeeks: false,
            clearBtn: false,
            dateDelimiter: ",",
            datesDisabled: [],
            daysOfWeekDisabled: [],
            daysOfWeekHighlighted: [],
            defaultViewDate: void 0,
            disableTouchKeyboard: false,
            format: "mm/dd/yyyy",
            language: "en",
            maxDate: null,
            maxNumberOfDates: 1,
            maxView: 3,
            minDate: null,
            nextArrow: '<svg class="w-4 h-4 rtl:rotate-180 text-gray-800 dark:text-white" aria-hidden="true" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 14 10"><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M1 5h12m0 0L9 1m4 4L9 9"/></svg>',
            orientation: "auto",
            pickLevel: 0,
            prevArrow: '<svg class="w-4 h-4 rtl:rotate-180 text-gray-800 dark:text-white" aria-hidden="true" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 14 10"><path stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 5H1m0 0 4 4M1 5l4-4"/></svg>',
            showDaysOfWeek: true,
            showOnClick: true,
            showOnFocus: true,
            startView: 0,
            title: "",
            todayBtn: false,
            todayBtnMode: 0,
            todayHighlight: false,
            updateOnBlur: true,
            weekStart: 0
        };
        var range = document.createRange();
        function parseHTML(html) {
            return range.createContextualFragment(html);
        }
        function hideElement(el) {
            if (el.style.display === "none") return;
            if (el.style.display) el.dataset.styleDisplay = el.style.display;
            el.style.display = "none";
        }
        function showElement(el) {
            if (el.style.display !== "none") return;
            if (el.dataset.styleDisplay) {
                el.style.display = el.dataset.styleDisplay;
                delete el.dataset.styleDisplay;
            } else el.style.display = "";
        }
        function emptyChildNodes(el) {
            if (el.firstChild) {
                el.removeChild(el.firstChild);
                emptyChildNodes(el);
            }
        }
        function replaceChildNodes(el, newChildNodes) {
            emptyChildNodes(el);
            if (newChildNodes instanceof DocumentFragment) el.appendChild(newChildNodes); else if (typeof newChildNodes === "string") el.appendChild(parseHTML(newChildNodes)); else if (typeof newChildNodes.forEach === "function") newChildNodes.forEach((function(node) {
                el.appendChild(node);
            }));
        }
        var defaultLang = defaultOptions.language, defaultFormat = defaultOptions.format, defaultWeekStart = defaultOptions.weekStart;
        function sanitizeDOW(dow, day) {
            return dow.length < 6 && day >= 0 && day < 7 ? pushUnique(dow, day) : dow;
        }
        function calcEndOfWeek(startOfWeek) {
            return (startOfWeek + 6) % 7;
        }
        function validateDate(value, format, locale, origValue) {
            var date = parseDate(value, format, locale);
            return date !== void 0 ? date : origValue;
        }
        function validateViewId(value, origValue) {
            var max = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 3;
            var viewId = parseInt(value, 10);
            return viewId >= 0 && viewId <= max ? viewId : origValue;
        }
        function processOptions(options, datepicker) {
            var inOpts = Object.assign({}, options);
            var config = {};
            var locales = datepicker.constructor.locales;
            var _ref = datepicker.config || {}, format = _ref.format, language = _ref.language, locale = _ref.locale, maxDate = _ref.maxDate, maxView = _ref.maxView, minDate = _ref.minDate, pickLevel = _ref.pickLevel, startView = _ref.startView, weekStart = _ref.weekStart;
            if (inOpts.language) {
                var lang;
                if (inOpts.language !== language) if (locales[inOpts.language]) lang = inOpts.language; else {
                    lang = inOpts.language.split("-")[0];
                    if (locales[lang] === void 0) lang = false;
                }
                delete inOpts.language;
                if (lang) {
                    language = config.language = lang;
                    var origLocale = locale || locales[defaultLang];
                    locale = Object.assign({
                        format: defaultFormat,
                        weekStart: defaultWeekStart
                    }, locales[defaultLang]);
                    if (language !== defaultLang) Object.assign(locale, locales[language]);
                    config.locale = locale;
                    if (format === origLocale.format) format = config.format = locale.format;
                    if (weekStart === origLocale.weekStart) {
                        weekStart = config.weekStart = locale.weekStart;
                        config.weekEnd = calcEndOfWeek(locale.weekStart);
                    }
                }
            }
            if (inOpts.format) {
                var hasToDisplay = typeof inOpts.format.toDisplay === "function";
                var hasToValue = typeof inOpts.format.toValue === "function";
                var validFormatString = reFormatTokens.test(inOpts.format);
                if (hasToDisplay && hasToValue || validFormatString) format = config.format = inOpts.format;
                delete inOpts.format;
            }
            var minDt = minDate;
            var maxDt = maxDate;
            if (inOpts.minDate !== void 0) {
                minDt = inOpts.minDate === null ? dateValue(0, 0, 1) : validateDate(inOpts.minDate, format, locale, minDt);
                delete inOpts.minDate;
            }
            if (inOpts.maxDate !== void 0) {
                maxDt = inOpts.maxDate === null ? void 0 : validateDate(inOpts.maxDate, format, locale, maxDt);
                delete inOpts.maxDate;
            }
            if (maxDt < minDt) {
                minDate = config.minDate = maxDt;
                maxDate = config.maxDate = minDt;
            } else {
                if (minDate !== minDt) minDate = config.minDate = minDt;
                if (maxDate !== maxDt) maxDate = config.maxDate = maxDt;
            }
            if (inOpts.datesDisabled) {
                config.datesDisabled = inOpts.datesDisabled.reduce((function(dates, dt) {
                    var date = parseDate(dt, format, locale);
                    return date !== void 0 ? pushUnique(dates, date) : dates;
                }), []);
                delete inOpts.datesDisabled;
            }
            if (inOpts.defaultViewDate !== void 0) {
                var viewDate = parseDate(inOpts.defaultViewDate, format, locale);
                if (viewDate !== void 0) config.defaultViewDate = viewDate;
                delete inOpts.defaultViewDate;
            }
            if (inOpts.weekStart !== void 0) {
                var wkStart = Number(inOpts.weekStart) % 7;
                if (!isNaN(wkStart)) {
                    weekStart = config.weekStart = wkStart;
                    config.weekEnd = calcEndOfWeek(wkStart);
                }
                delete inOpts.weekStart;
            }
            if (inOpts.daysOfWeekDisabled) {
                config.daysOfWeekDisabled = inOpts.daysOfWeekDisabled.reduce(sanitizeDOW, []);
                delete inOpts.daysOfWeekDisabled;
            }
            if (inOpts.daysOfWeekHighlighted) {
                config.daysOfWeekHighlighted = inOpts.daysOfWeekHighlighted.reduce(sanitizeDOW, []);
                delete inOpts.daysOfWeekHighlighted;
            }
            if (inOpts.maxNumberOfDates !== void 0) {
                var maxNumberOfDates = parseInt(inOpts.maxNumberOfDates, 10);
                if (maxNumberOfDates >= 0) {
                    config.maxNumberOfDates = maxNumberOfDates;
                    config.multidate = maxNumberOfDates !== 1;
                }
                delete inOpts.maxNumberOfDates;
            }
            if (inOpts.dateDelimiter) {
                config.dateDelimiter = String(inOpts.dateDelimiter);
                delete inOpts.dateDelimiter;
            }
            var newPickLevel = pickLevel;
            if (inOpts.pickLevel !== void 0) {
                newPickLevel = validateViewId(inOpts.pickLevel, 2);
                delete inOpts.pickLevel;
            }
            if (newPickLevel !== pickLevel) pickLevel = config.pickLevel = newPickLevel;
            var newMaxView = maxView;
            if (inOpts.maxView !== void 0) {
                newMaxView = validateViewId(inOpts.maxView, maxView);
                delete inOpts.maxView;
            }
            newMaxView = pickLevel > newMaxView ? pickLevel : newMaxView;
            if (newMaxView !== maxView) maxView = config.maxView = newMaxView;
            var newStartView = startView;
            if (inOpts.startView !== void 0) {
                newStartView = validateViewId(inOpts.startView, newStartView);
                delete inOpts.startView;
            }
            if (newStartView < pickLevel) newStartView = pickLevel; else if (newStartView > maxView) newStartView = maxView;
            if (newStartView !== startView) config.startView = newStartView;
            if (inOpts.prevArrow) {
                var prevArrow = parseHTML(inOpts.prevArrow);
                if (prevArrow.childNodes.length > 0) config.prevArrow = prevArrow.childNodes;
                delete inOpts.prevArrow;
            }
            if (inOpts.nextArrow) {
                var nextArrow = parseHTML(inOpts.nextArrow);
                if (nextArrow.childNodes.length > 0) config.nextArrow = nextArrow.childNodes;
                delete inOpts.nextArrow;
            }
            if (inOpts.disableTouchKeyboard !== void 0) {
                config.disableTouchKeyboard = "ontouchstart" in document && !!inOpts.disableTouchKeyboard;
                delete inOpts.disableTouchKeyboard;
            }
            if (inOpts.orientation) {
                var orientation = inOpts.orientation.toLowerCase().split(/\s+/g);
                config.orientation = {
                    x: orientation.find((function(x) {
                        return x === "left" || x === "right";
                    })) || "auto",
                    y: orientation.find((function(y) {
                        return y === "top" || y === "bottom";
                    })) || "auto"
                };
                delete inOpts.orientation;
            }
            if (inOpts.todayBtnMode !== void 0) {
                switch (inOpts.todayBtnMode) {
                  case 0:
                  case 1:
                    config.todayBtnMode = inOpts.todayBtnMode;
                }
                delete inOpts.todayBtnMode;
            }
            Object.keys(inOpts).forEach((function(key) {
                if (inOpts[key] !== void 0 && hasProperty(defaultOptions, key)) config[key] = inOpts[key];
            }));
            return config;
        }
        var pickerTemplate = optimizeTemplateHTML('<div class="datepicker hidden">\n  <div class="datepicker-picker inline-block rounded-lg bg-white dark:bg-gray-700 shadow-lg p-4">\n    <div class="datepicker-header">\n      <div class="datepicker-title bg-white dark:bg-gray-700 dark:text-white px-2 py-3 text-center font-semibold"></div>\n      <div class="datepicker-controls flex justify-between mb-2">\n        <button type="button" class="bg-white dark:bg-gray-700 rounded-lg text-gray-500 dark:text-white hover:bg-gray-100 dark:hover:bg-gray-600 hover:text-gray-900 dark:hover:text-white text-lg p-2.5 focus:outline-none focus:ring-2 focus:ring-gray-200 prev-btn"></button>\n        <button type="button" class="text-sm rounded-lg text-gray-900 dark:text-white bg-white dark:bg-gray-700 font-semibold py-2.5 px-5 hover:bg-gray-100 dark:hover:bg-gray-600 focus:outline-none focus:ring-2 focus:ring-gray-200 view-switch"></button>\n        <button type="button" class="bg-white dark:bg-gray-700 rounded-lg text-gray-500 dark:text-white hover:bg-gray-100 dark:hover:bg-gray-600 hover:text-gray-900 dark:hover:text-white text-lg p-2.5 focus:outline-none focus:ring-2 focus:ring-gray-200 next-btn"></button>\n      </div>\n    </div>\n    <div class="datepicker-main p-1"></div>\n    <div class="datepicker-footer">\n      <div class="datepicker-controls flex space-x-2 rtl:space-x-reverse mt-2">\n        <button type="button" class="%buttonClass% today-btn text-white bg-blue-700 !bg-primary-700 dark:bg-blue-600 dark:!bg-primary-600 hover:bg-blue-800 hover:!bg-primary-800 dark:hover:bg-blue-700 dark:hover:!bg-primary-700 focus:ring-4 focus:ring-blue-300 focus:!ring-primary-300 font-medium rounded-lg text-sm px-5 py-2 text-center w-1/2"></button>\n        <button type="button" class="%buttonClass% clear-btn text-gray-900 dark:text-white bg-white dark:bg-gray-700 border border-gray-300 dark:border-gray-600 hover:bg-gray-100 dark:hover:bg-gray-600 focus:ring-4 focus:ring-blue-300 focus:!ring-primary-300 font-medium rounded-lg text-sm px-5 py-2 text-center w-1/2"></button>\n      </div>\n    </div>\n  </div>\n</div>');
        var daysTemplate = optimizeTemplateHTML('<div class="days">\n  <div class="days-of-week grid grid-cols-7 mb-1">'.concat(createTagRepeat("span", 7, {
            class: "dow block flex-1 leading-9 border-0 rounded-lg cursor-default text-center text-gray-900 font-semibold text-sm"
        }), '</div>\n  <div class="datepicker-grid w-64 grid grid-cols-7">').concat(createTagRepeat("span", 42, {
            class: "block flex-1 leading-9 border-0 rounded-lg cursor-default text-center text-gray-900 font-semibold text-sm h-6 leading-6 text-sm font-medium text-gray-500 dark:text-gray-400"
        }), "</div>\n</div>"));
        var calendarWeeksTemplate = optimizeTemplateHTML('<div class="calendar-weeks">\n  <div class="days-of-week flex"><span class="dow h-6 leading-6 text-sm font-medium text-gray-500 dark:text-gray-400"></span></div>\n  <div class="weeks">'.concat(createTagRepeat("span", 6, {
            class: "week block flex-1 leading-9 border-0 rounded-lg cursor-default text-center text-gray-900 font-semibold text-sm"
        }), "</div>\n</div>"));
        var View = function() {
            function View(picker, config) {
                _classCallCheck(this, View);
                Object.assign(this, config, {
                    picker,
                    element: parseHTML('<div class="datepicker-view flex"></div>').firstChild,
                    selected: []
                });
                this.init(this.picker.datepicker.config);
            }
            return _createClass(View, [ {
                key: "init",
                value: function init(options) {
                    if (options.pickLevel !== void 0) this.isMinView = this.id === options.pickLevel;
                    this.setOptions(options);
                    this.updateFocus();
                    this.updateSelection();
                }
            }, {
                key: "performBeforeHook",
                value: function performBeforeHook(el, current, timeValue) {
                    var result = this.beforeShow(new Date(timeValue));
                    switch (_typeof(result)) {
                      case "boolean":
                        result = {
                            enabled: result
                        };
                        break;

                      case "string":
                        result = {
                            classes: result
                        };
                    }
                    if (result) {
                        if (result.enabled === false) {
                            el.classList.add("disabled");
                            pushUnique(this.disabled, current);
                        }
                        if (result.classes) {
                            var _el$classList;
                            var extraClasses = result.classes.split(/\s+/);
                            (_el$classList = el.classList).add.apply(_el$classList, _toConsumableArray(extraClasses));
                            if (extraClasses.includes("disabled")) pushUnique(this.disabled, current);
                        }
                        if (result.content) replaceChildNodes(el, result.content);
                    }
                }
            } ]);
        }();
        var DaysView = function(_View) {
            function DaysView(picker) {
                _classCallCheck(this, DaysView);
                return _callSuper(this, DaysView, [ picker, {
                    id: 0,
                    name: "days",
                    cellClass: "day"
                } ]);
            }
            _inherits(DaysView, _View);
            return _createClass(DaysView, [ {
                key: "init",
                value: function init(options) {
                    var onConstruction = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
                    if (onConstruction) {
                        var inner = parseHTML(daysTemplate).firstChild;
                        this.dow = inner.firstChild;
                        this.grid = inner.lastChild;
                        this.element.appendChild(inner);
                    }
                    _get(_getPrototypeOf(DaysView.prototype), "init", this).call(this, options);
                }
            }, {
                key: "setOptions",
                value: function setOptions(options) {
                    var _this = this;
                    var updateDOW;
                    if (hasProperty(options, "minDate")) this.minDate = options.minDate;
                    if (hasProperty(options, "maxDate")) this.maxDate = options.maxDate;
                    if (options.datesDisabled) this.datesDisabled = options.datesDisabled;
                    if (options.daysOfWeekDisabled) {
                        this.daysOfWeekDisabled = options.daysOfWeekDisabled;
                        updateDOW = true;
                    }
                    if (options.daysOfWeekHighlighted) this.daysOfWeekHighlighted = options.daysOfWeekHighlighted;
                    if (options.todayHighlight !== void 0) this.todayHighlight = options.todayHighlight;
                    if (options.weekStart !== void 0) {
                        this.weekStart = options.weekStart;
                        this.weekEnd = options.weekEnd;
                        updateDOW = true;
                    }
                    if (options.locale) {
                        var locale = this.locale = options.locale;
                        this.dayNames = locale.daysMin;
                        this.switchLabelFormat = locale.titleFormat;
                        updateDOW = true;
                    }
                    if (options.beforeShowDay !== void 0) this.beforeShow = typeof options.beforeShowDay === "function" ? options.beforeShowDay : void 0;
                    if (options.calendarWeeks !== void 0) if (options.calendarWeeks && !this.calendarWeeks) {
                        var weeksElem = parseHTML(calendarWeeksTemplate).firstChild;
                        this.calendarWeeks = {
                            element: weeksElem,
                            dow: weeksElem.firstChild,
                            weeks: weeksElem.lastChild
                        };
                        this.element.insertBefore(weeksElem, this.element.firstChild);
                    } else if (this.calendarWeeks && !options.calendarWeeks) {
                        this.element.removeChild(this.calendarWeeks.element);
                        this.calendarWeeks = null;
                    }
                    if (options.showDaysOfWeek !== void 0) if (options.showDaysOfWeek) {
                        showElement(this.dow);
                        if (this.calendarWeeks) showElement(this.calendarWeeks.dow);
                    } else {
                        hideElement(this.dow);
                        if (this.calendarWeeks) hideElement(this.calendarWeeks.dow);
                    }
                    if (updateDOW) Array.from(this.dow.children).forEach((function(el, index) {
                        var dow = (_this.weekStart + index) % 7;
                        el.textContent = _this.dayNames[dow];
                        el.className = _this.daysOfWeekDisabled.includes(dow) ? "dow disabled text-center h-6 leading-6 text-sm font-medium text-gray-500 dark:text-gray-400 cursor-not-allowed" : "dow text-center h-6 leading-6 text-sm font-medium text-gray-500 dark:text-gray-400";
                    }));
                }
            }, {
                key: "updateFocus",
                value: function updateFocus() {
                    var viewDate = new Date(this.picker.viewDate);
                    var viewYear = viewDate.getFullYear();
                    var viewMonth = viewDate.getMonth();
                    var firstOfMonth = dateValue(viewYear, viewMonth, 1);
                    var start = dayOfTheWeekOf(firstOfMonth, this.weekStart, this.weekStart);
                    this.first = firstOfMonth;
                    this.last = dateValue(viewYear, viewMonth + 1, 0);
                    this.start = start;
                    this.focused = this.picker.viewDate;
                }
            }, {
                key: "updateSelection",
                value: function updateSelection() {
                    var _this$picker$datepick = this.picker.datepicker, dates = _this$picker$datepick.dates, rangepicker = _this$picker$datepick.rangepicker;
                    this.selected = dates;
                    if (rangepicker) this.range = rangepicker.dates;
                }
            }, {
                key: "render",
                value: function render() {
                    var _this2 = this;
                    this.today = this.todayHighlight ? today() : void 0;
                    this.disabled = _toConsumableArray(this.datesDisabled);
                    var switchLabel = formatDate(this.focused, this.switchLabelFormat, this.locale);
                    this.picker.setViewSwitchLabel(switchLabel);
                    this.picker.setPrevBtnDisabled(this.first <= this.minDate);
                    this.picker.setNextBtnDisabled(this.last >= this.maxDate);
                    if (this.calendarWeeks) {
                        var startOfWeek = dayOfTheWeekOf(this.first, 1, 1);
                        Array.from(this.calendarWeeks.weeks.children).forEach((function(el, index) {
                            el.textContent = getWeek(addWeeks(startOfWeek, index));
                        }));
                    }
                    Array.from(this.grid.children).forEach((function(el, index) {
                        var classList = el.classList;
                        var current = addDays(_this2.start, index);
                        var date = new Date(current);
                        var day = date.getDay();
                        el.className = "datepicker-cell hover:bg-gray-100 dark:hover:bg-gray-600 block flex-1 leading-9 border-0 rounded-lg cursor-pointer text-center text-gray-900 dark:text-white font-semibold text-sm ".concat(_this2.cellClass);
                        el.dataset.date = current;
                        el.textContent = date.getDate();
                        if (current < _this2.first) classList.add("prev", "text-gray-500", "dark:text-white"); else if (current > _this2.last) classList.add("next", "text-gray-500", "dark:text-white");
                        if (_this2.today === current) classList.add("today", "bg-gray-100", "dark:bg-gray-600");
                        if (current < _this2.minDate || current > _this2.maxDate || _this2.disabled.includes(current)) {
                            classList.add("disabled", "cursor-not-allowed", "text-gray-400", "dark:text-gray-500");
                            classList.remove("hover:bg-gray-100", "dark:hover:bg-gray-600", "text-gray-900", "dark:text-white", "cursor-pointer");
                        }
                        if (_this2.daysOfWeekDisabled.includes(day)) {
                            classList.add("disabled", "cursor-not-allowed", "text-gray-400", "dark:text-gray-500");
                            classList.remove("hover:bg-gray-100", "dark:hover:bg-gray-600", "text-gray-900", "dark:text-white", "cursor-pointer");
                            pushUnique(_this2.disabled, current);
                        }
                        if (_this2.daysOfWeekHighlighted.includes(day)) classList.add("highlighted");
                        if (_this2.range) {
                            var _this2$range = _slicedToArray(_this2.range, 2), rangeStart = _this2$range[0], rangeEnd = _this2$range[1];
                            if (current > rangeStart && current < rangeEnd) {
                                classList.add("range", "bg-gray-200", "dark:bg-gray-600");
                                classList.remove("rounded-lg", "rounded-l-lg", "rounded-r-lg");
                            }
                            if (current === rangeStart) {
                                classList.add("range-start", "bg-gray-100", "dark:bg-gray-600", "rounded-l-lg");
                                classList.remove("rounded-lg", "rounded-r-lg");
                            }
                            if (current === rangeEnd) {
                                classList.add("range-end", "bg-gray-100", "dark:bg-gray-600", "rounded-r-lg");
                                classList.remove("rounded-lg", "rounded-l-lg");
                            }
                        }
                        if (_this2.selected.includes(current)) {
                            classList.add("selected", "bg-blue-700", "!bg-primary-700", "text-white", "dark:bg-blue-600", "dark:!bg-primary-600", "dark:text-white");
                            classList.remove("text-gray-900", "text-gray-500", "hover:bg-gray-100", "dark:text-white", "dark:hover:bg-gray-600", "dark:bg-gray-600", "bg-gray-100", "bg-gray-200");
                        }
                        if (current === _this2.focused) classList.add("focused");
                        if (_this2.beforeShow) _this2.performBeforeHook(el, current, current);
                    }));
                }
            }, {
                key: "refresh",
                value: function refresh() {
                    var _this3 = this;
                    var _ref = this.range || [], _ref2 = _slicedToArray(_ref, 2), rangeStart = _ref2[0], rangeEnd = _ref2[1];
                    this.grid.querySelectorAll(".range, .range-start, .range-end, .selected, .focused").forEach((function(el) {
                        el.classList.remove("range", "range-start", "range-end", "selected", "bg-blue-700", "!bg-primary-700", "text-white", "dark:bg-blue-600", "dark:!bg-primary-600", "dark:text-white", "focused");
                        el.classList.add("text-gray-900", "rounded-lg", "dark:text-white");
                    }));
                    Array.from(this.grid.children).forEach((function(el) {
                        var current = Number(el.dataset.date);
                        var classList = el.classList;
                        classList.remove("bg-gray-200", "dark:bg-gray-600", "rounded-l-lg", "rounded-r-lg");
                        if (current > rangeStart && current < rangeEnd) {
                            classList.add("range", "bg-gray-200", "dark:bg-gray-600");
                            classList.remove("rounded-lg");
                        }
                        if (current === rangeStart) {
                            classList.add("range-start", "bg-gray-200", "dark:bg-gray-600", "rounded-l-lg");
                            classList.remove("rounded-lg");
                        }
                        if (current === rangeEnd) {
                            classList.add("range-end", "bg-gray-200", "dark:bg-gray-600", "rounded-r-lg");
                            classList.remove("rounded-lg");
                        }
                        if (_this3.selected.includes(current)) {
                            classList.add("selected", "bg-blue-700", "!bg-primary-700", "text-white", "dark:bg-blue-600", "dark:!bg-primary-600", "dark:text-white");
                            classList.remove("text-gray-900", "hover:bg-gray-100", "dark:text-white", "dark:hover:bg-gray-600", "bg-gray-100", "bg-gray-200", "dark:bg-gray-600");
                        }
                        if (current === _this3.focused) classList.add("focused");
                    }));
                }
            }, {
                key: "refreshFocus",
                value: function refreshFocus() {
                    var index = Math.round((this.focused - this.start) / 864e5);
                    this.grid.querySelectorAll(".focused").forEach((function(el) {
                        el.classList.remove("focused");
                    }));
                    this.grid.children[index].classList.add("focused");
                }
            } ]);
        }(View);
        function computeMonthRange(range, thisYear) {
            if (!range || !range[0] || !range[1]) return;
            var _range = _slicedToArray(range, 2), _range$ = _slicedToArray(_range[0], 2), startY = _range$[0], startM = _range$[1], _range$2 = _slicedToArray(_range[1], 2), endY = _range$2[0], endM = _range$2[1];
            if (startY > thisYear || endY < thisYear) return;
            return [ startY === thisYear ? startM : -1, endY === thisYear ? endM : 12 ];
        }
        var MonthsView = function(_View) {
            function MonthsView(picker) {
                _classCallCheck(this, MonthsView);
                return _callSuper(this, MonthsView, [ picker, {
                    id: 1,
                    name: "months",
                    cellClass: "month"
                } ]);
            }
            _inherits(MonthsView, _View);
            return _createClass(MonthsView, [ {
                key: "init",
                value: function init(options) {
                    var onConstruction = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
                    if (onConstruction) {
                        this.grid = this.element;
                        this.element.classList.add("months", "datepicker-grid", "w-64", "grid", "grid-cols-4");
                        this.grid.appendChild(parseHTML(createTagRepeat("span", 12, {
                            "data-month": function dataMonth(ix) {
                                return ix;
                            }
                        })));
                    }
                    _get(_getPrototypeOf(MonthsView.prototype), "init", this).call(this, options);
                }
            }, {
                key: "setOptions",
                value: function setOptions(options) {
                    if (options.locale) this.monthNames = options.locale.monthsShort;
                    if (hasProperty(options, "minDate")) if (options.minDate === void 0) this.minYear = this.minMonth = this.minDate = void 0; else {
                        var minDateObj = new Date(options.minDate);
                        this.minYear = minDateObj.getFullYear();
                        this.minMonth = minDateObj.getMonth();
                        this.minDate = minDateObj.setDate(1);
                    }
                    if (hasProperty(options, "maxDate")) if (options.maxDate === void 0) this.maxYear = this.maxMonth = this.maxDate = void 0; else {
                        var maxDateObj = new Date(options.maxDate);
                        this.maxYear = maxDateObj.getFullYear();
                        this.maxMonth = maxDateObj.getMonth();
                        this.maxDate = dateValue(this.maxYear, this.maxMonth + 1, 0);
                    }
                    if (options.beforeShowMonth !== void 0) this.beforeShow = typeof options.beforeShowMonth === "function" ? options.beforeShowMonth : void 0;
                }
            }, {
                key: "updateFocus",
                value: function updateFocus() {
                    var viewDate = new Date(this.picker.viewDate);
                    this.year = viewDate.getFullYear();
                    this.focused = viewDate.getMonth();
                }
            }, {
                key: "updateSelection",
                value: function updateSelection() {
                    var _this$picker$datepick = this.picker.datepicker, dates = _this$picker$datepick.dates, rangepicker = _this$picker$datepick.rangepicker;
                    this.selected = dates.reduce((function(selected, timeValue) {
                        var date = new Date(timeValue);
                        var year = date.getFullYear();
                        var month = date.getMonth();
                        if (selected[year] === void 0) selected[year] = [ month ]; else pushUnique(selected[year], month);
                        return selected;
                    }), {});
                    if (rangepicker && rangepicker.dates) this.range = rangepicker.dates.map((function(timeValue) {
                        var date = new Date(timeValue);
                        return isNaN(date) ? void 0 : [ date.getFullYear(), date.getMonth() ];
                    }));
                }
            }, {
                key: "render",
                value: function render() {
                    var _this = this;
                    this.disabled = [];
                    this.picker.setViewSwitchLabel(this.year);
                    this.picker.setPrevBtnDisabled(this.year <= this.minYear);
                    this.picker.setNextBtnDisabled(this.year >= this.maxYear);
                    var selected = this.selected[this.year] || [];
                    var yrOutOfRange = this.year < this.minYear || this.year > this.maxYear;
                    var isMinYear = this.year === this.minYear;
                    var isMaxYear = this.year === this.maxYear;
                    var range = computeMonthRange(this.range, this.year);
                    Array.from(this.grid.children).forEach((function(el, index) {
                        var classList = el.classList;
                        var date = dateValue(_this.year, index, 1);
                        el.className = "datepicker-cell hover:bg-gray-100 dark:hover:bg-gray-600 block flex-1 leading-9 border-0 rounded-lg cursor-pointer text-center text-gray-900 dark:text-white font-semibold text-sm ".concat(_this.cellClass);
                        if (_this.isMinView) el.dataset.date = date;
                        el.textContent = _this.monthNames[index];
                        if (yrOutOfRange || isMinYear && index < _this.minMonth || isMaxYear && index > _this.maxMonth) classList.add("disabled");
                        if (range) {
                            var _range2 = _slicedToArray(range, 2), rangeStart = _range2[0], rangeEnd = _range2[1];
                            if (index > rangeStart && index < rangeEnd) classList.add("range");
                            if (index === rangeStart) classList.add("range-start");
                            if (index === rangeEnd) classList.add("range-end");
                        }
                        if (selected.includes(index)) {
                            classList.add("selected", "bg-blue-700", "!bg-primary-700", "text-white", "dark:bg-blue-600", "dark:!bg-primary-600", "dark:text-white");
                            classList.remove("text-gray-900", "hover:bg-gray-100", "dark:text-white", "dark:hover:bg-gray-600");
                        }
                        if (index === _this.focused) classList.add("focused");
                        if (_this.beforeShow) _this.performBeforeHook(el, index, date);
                    }));
                }
            }, {
                key: "refresh",
                value: function refresh() {
                    var _this2 = this;
                    var selected = this.selected[this.year] || [];
                    var _ref = computeMonthRange(this.range, this.year) || [], _ref2 = _slicedToArray(_ref, 2), rangeStart = _ref2[0], rangeEnd = _ref2[1];
                    this.grid.querySelectorAll(".range, .range-start, .range-end, .selected, .focused").forEach((function(el) {
                        el.classList.remove("range", "range-start", "range-end", "selected", "bg-blue-700", "!bg-primary-700", "dark:bg-blue-600", "dark:!bg-primary-700", "dark:text-white", "text-white", "focused");
                        el.classList.add("text-gray-900", "hover:bg-gray-100", "dark:text-white", "dark:hover:bg-gray-600");
                    }));
                    Array.from(this.grid.children).forEach((function(el, index) {
                        var classList = el.classList;
                        if (index > rangeStart && index < rangeEnd) classList.add("range");
                        if (index === rangeStart) classList.add("range-start");
                        if (index === rangeEnd) classList.add("range-end");
                        if (selected.includes(index)) {
                            classList.add("selected", "bg-blue-700", "!bg-primary-700", "text-white", "dark:bg-blue-600", "dark:!bg-primary-600", "dark:text-white");
                            classList.remove("text-gray-900", "hover:bg-gray-100", "dark:text-white", "dark:hover:bg-gray-600");
                        }
                        if (index === _this2.focused) classList.add("focused");
                    }));
                }
            }, {
                key: "refreshFocus",
                value: function refreshFocus() {
                    this.grid.querySelectorAll(".focused").forEach((function(el) {
                        el.classList.remove("focused");
                    }));
                    this.grid.children[this.focused].classList.add("focused");
                }
            } ]);
        }(View);
        function toTitleCase(word) {
            return _toConsumableArray(word).reduce((function(str, ch, ix) {
                return str += ix ? ch : ch.toUpperCase();
            }), "");
        }
        var YearsView = function(_View) {
            function YearsView(picker, config) {
                _classCallCheck(this, YearsView);
                return _callSuper(this, YearsView, [ picker, config ]);
            }
            _inherits(YearsView, _View);
            return _createClass(YearsView, [ {
                key: "init",
                value: function init(options) {
                    var onConstruction = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
                    if (onConstruction) {
                        this.navStep = this.step * 10;
                        this.beforeShowOption = "beforeShow".concat(toTitleCase(this.cellClass));
                        this.grid = this.element;
                        this.element.classList.add(this.name, "datepicker-grid", "w-64", "grid", "grid-cols-4");
                        this.grid.appendChild(parseHTML(createTagRepeat("span", 12)));
                    }
                    _get(_getPrototypeOf(YearsView.prototype), "init", this).call(this, options);
                }
            }, {
                key: "setOptions",
                value: function setOptions(options) {
                    if (hasProperty(options, "minDate")) if (options.minDate === void 0) this.minYear = this.minDate = void 0; else {
                        this.minYear = startOfYearPeriod(options.minDate, this.step);
                        this.minDate = dateValue(this.minYear, 0, 1);
                    }
                    if (hasProperty(options, "maxDate")) if (options.maxDate === void 0) this.maxYear = this.maxDate = void 0; else {
                        this.maxYear = startOfYearPeriod(options.maxDate, this.step);
                        this.maxDate = dateValue(this.maxYear, 11, 31);
                    }
                    if (options[this.beforeShowOption] !== void 0) {
                        var beforeShow = options[this.beforeShowOption];
                        this.beforeShow = typeof beforeShow === "function" ? beforeShow : void 0;
                    }
                }
            }, {
                key: "updateFocus",
                value: function updateFocus() {
                    var viewDate = new Date(this.picker.viewDate);
                    var first = startOfYearPeriod(viewDate, this.navStep);
                    var last = first + 9 * this.step;
                    this.first = first;
                    this.last = last;
                    this.start = first - this.step;
                    this.focused = startOfYearPeriod(viewDate, this.step);
                }
            }, {
                key: "updateSelection",
                value: function updateSelection() {
                    var _this = this;
                    var _this$picker$datepick = this.picker.datepicker, dates = _this$picker$datepick.dates, rangepicker = _this$picker$datepick.rangepicker;
                    this.selected = dates.reduce((function(years, timeValue) {
                        return pushUnique(years, startOfYearPeriod(timeValue, _this.step));
                    }), []);
                    if (rangepicker && rangepicker.dates) this.range = rangepicker.dates.map((function(timeValue) {
                        if (timeValue !== void 0) return startOfYearPeriod(timeValue, _this.step);
                    }));
                }
            }, {
                key: "render",
                value: function render() {
                    var _this2 = this;
                    this.disabled = [];
                    this.picker.setViewSwitchLabel("".concat(this.first, "-").concat(this.last));
                    this.picker.setPrevBtnDisabled(this.first <= this.minYear);
                    this.picker.setNextBtnDisabled(this.last >= this.maxYear);
                    Array.from(this.grid.children).forEach((function(el, index) {
                        var classList = el.classList;
                        var current = _this2.start + index * _this2.step;
                        var date = dateValue(current, 0, 1);
                        el.className = "datepicker-cell hover:bg-gray-100 dark:hover:bg-gray-600 block flex-1 leading-9 border-0 rounded-lg cursor-pointer text-center text-gray-900 dark:text-white font-semibold text-sm ".concat(_this2.cellClass);
                        if (_this2.isMinView) el.dataset.date = date;
                        el.textContent = el.dataset.year = current;
                        if (index === 0) classList.add("prev"); else if (index === 11) classList.add("next");
                        if (current < _this2.minYear || current > _this2.maxYear) classList.add("disabled");
                        if (_this2.range) {
                            var _this2$range = _slicedToArray(_this2.range, 2), rangeStart = _this2$range[0], rangeEnd = _this2$range[1];
                            if (current > rangeStart && current < rangeEnd) classList.add("range");
                            if (current === rangeStart) classList.add("range-start");
                            if (current === rangeEnd) classList.add("range-end");
                        }
                        if (_this2.selected.includes(current)) {
                            classList.add("selected", "bg-blue-700", "!bg-primary-700", "text-white", "dark:bg-blue-600", "dark:!bg-primary-600", "dark:text-white");
                            classList.remove("text-gray-900", "hover:bg-gray-100", "dark:text-white", "dark:hover:bg-gray-600");
                        }
                        if (current === _this2.focused) classList.add("focused");
                        if (_this2.beforeShow) _this2.performBeforeHook(el, current, date);
                    }));
                }
            }, {
                key: "refresh",
                value: function refresh() {
                    var _this3 = this;
                    var _ref = this.range || [], _ref2 = _slicedToArray(_ref, 2), rangeStart = _ref2[0], rangeEnd = _ref2[1];
                    this.grid.querySelectorAll(".range, .range-start, .range-end, .selected, .focused").forEach((function(el) {
                        el.classList.remove("range", "range-start", "range-end", "selected", "bg-blue-700", "!bg-primary-700", "text-white", "dark:bg-blue-600", "dark!bg-primary-600", "dark:text-white", "focused");
                    }));
                    Array.from(this.grid.children).forEach((function(el) {
                        var current = Number(el.textContent);
                        var classList = el.classList;
                        if (current > rangeStart && current < rangeEnd) classList.add("range");
                        if (current === rangeStart) classList.add("range-start");
                        if (current === rangeEnd) classList.add("range-end");
                        if (_this3.selected.includes(current)) {
                            classList.add("selected", "bg-blue-700", "!bg-primary-700", "text-white", "dark:bg-blue-600", "dark:!bg-primary-600", "dark:text-white");
                            classList.remove("text-gray-900", "hover:bg-gray-100", "dark:text-white", "dark:hover:bg-gray-600");
                        }
                        if (current === _this3.focused) classList.add("focused");
                    }));
                }
            }, {
                key: "refreshFocus",
                value: function refreshFocus() {
                    var index = Math.round((this.focused - this.start) / this.step);
                    this.grid.querySelectorAll(".focused").forEach((function(el) {
                        el.classList.remove("focused");
                    }));
                    this.grid.children[index].classList.add("focused");
                }
            } ]);
        }(View);
        function triggerDatepickerEvent(datepicker, type) {
            var detail = {
                date: datepicker.getDate(),
                viewDate: new Date(datepicker.picker.viewDate),
                viewId: datepicker.picker.currentView.id,
                datepicker
            };
            datepicker.element.dispatchEvent(new CustomEvent(type, {
                detail
            }));
        }
        function goToPrevOrNext(datepicker, direction) {
            var _datepicker$config = datepicker.config, minDate = _datepicker$config.minDate, maxDate = _datepicker$config.maxDate;
            var _datepicker$picker = datepicker.picker, currentView = _datepicker$picker.currentView, viewDate = _datepicker$picker.viewDate;
            var newViewDate;
            switch (currentView.id) {
              case 0:
                newViewDate = addMonths(viewDate, direction);
                break;

              case 1:
                newViewDate = addYears(viewDate, direction);
                break;

              default:
                newViewDate = addYears(viewDate, direction * currentView.navStep);
            }
            newViewDate = limitToRange(newViewDate, minDate, maxDate);
            datepicker.picker.changeFocus(newViewDate).render();
        }
        function switchView(datepicker) {
            var viewId = datepicker.picker.currentView.id;
            if (viewId === datepicker.config.maxView) return;
            datepicker.picker.changeView(viewId + 1).render();
        }
        function unfocus(datepicker) {
            if (datepicker.config.updateOnBlur) datepicker.update({
                autohide: true
            }); else {
                datepicker.refresh("input");
                datepicker.hide();
            }
        }
        function goToSelectedMonthOrYear(datepicker, selection) {
            var picker = datepicker.picker;
            var viewDate = new Date(picker.viewDate);
            var viewId = picker.currentView.id;
            var newDate = viewId === 1 ? addMonths(viewDate, selection - viewDate.getMonth()) : addYears(viewDate, selection - viewDate.getFullYear());
            picker.changeFocus(newDate).changeView(viewId - 1).render();
        }
        function onClickTodayBtn(datepicker) {
            var picker = datepicker.picker;
            var currentDate = today();
            if (datepicker.config.todayBtnMode === 1) {
                if (datepicker.config.autohide) {
                    datepicker.setDate(currentDate);
                    return;
                }
                datepicker.setDate(currentDate, {
                    render: false
                });
                picker.update();
            }
            if (picker.viewDate !== currentDate) picker.changeFocus(currentDate);
            picker.changeView(0).render();
        }
        function onClickClearBtn(datepicker) {
            datepicker.setDate({
                clear: true
            });
        }
        function onClickViewSwitch(datepicker) {
            switchView(datepicker);
        }
        function onClickPrevBtn(datepicker) {
            goToPrevOrNext(datepicker, -1);
        }
        function onClickNextBtn(datepicker) {
            goToPrevOrNext(datepicker, 1);
        }
        function onClickView(datepicker, ev) {
            var target = findElementInEventPath(ev, ".datepicker-cell");
            if (!target || target.classList.contains("disabled")) return;
            var _datepicker$picker$cu = datepicker.picker.currentView, id = _datepicker$picker$cu.id, isMinView = _datepicker$picker$cu.isMinView;
            if (isMinView) datepicker.setDate(Number(target.dataset.date)); else if (id === 1) goToSelectedMonthOrYear(datepicker, Number(target.dataset.month)); else goToSelectedMonthOrYear(datepicker, Number(target.dataset.year));
        }
        function onClickPicker(datepicker) {
            if (!datepicker.inline && !datepicker.config.disableTouchKeyboard) datepicker.inputField.focus();
        }
        function processPickerOptions(picker, options) {
            if (options.title !== void 0) if (options.title) {
                picker.controls.title.textContent = options.title;
                showElement(picker.controls.title);
            } else {
                picker.controls.title.textContent = "";
                hideElement(picker.controls.title);
            }
            if (options.prevArrow) {
                var prevBtn = picker.controls.prevBtn;
                emptyChildNodes(prevBtn);
                options.prevArrow.forEach((function(node) {
                    prevBtn.appendChild(node.cloneNode(true));
                }));
            }
            if (options.nextArrow) {
                var nextBtn = picker.controls.nextBtn;
                emptyChildNodes(nextBtn);
                options.nextArrow.forEach((function(node) {
                    nextBtn.appendChild(node.cloneNode(true));
                }));
            }
            if (options.locale) {
                picker.controls.todayBtn.textContent = options.locale.today;
                picker.controls.clearBtn.textContent = options.locale.clear;
            }
            if (options.todayBtn !== void 0) if (options.todayBtn) showElement(picker.controls.todayBtn); else hideElement(picker.controls.todayBtn);
            if (hasProperty(options, "minDate") || hasProperty(options, "maxDate")) {
                var _picker$datepicker$co = picker.datepicker.config, minDate = _picker$datepicker$co.minDate, maxDate = _picker$datepicker$co.maxDate;
                picker.controls.todayBtn.disabled = !isInRange(today(), minDate, maxDate);
            }
            if (options.clearBtn !== void 0) if (options.clearBtn) showElement(picker.controls.clearBtn); else hideElement(picker.controls.clearBtn);
        }
        function computeResetViewDate(datepicker) {
            var dates = datepicker.dates, config = datepicker.config;
            var viewDate = dates.length > 0 ? lastItemOf(dates) : config.defaultViewDate;
            return limitToRange(viewDate, config.minDate, config.maxDate);
        }
        function setViewDate(picker, newDate) {
            var oldViewDate = new Date(picker.viewDate);
            var newViewDate = new Date(newDate);
            var _picker$currentView = picker.currentView, id = _picker$currentView.id, year = _picker$currentView.year, first = _picker$currentView.first, last = _picker$currentView.last;
            var viewYear = newViewDate.getFullYear();
            picker.viewDate = newDate;
            if (viewYear !== oldViewDate.getFullYear()) triggerDatepickerEvent(picker.datepicker, "changeYear");
            if (newViewDate.getMonth() !== oldViewDate.getMonth()) triggerDatepickerEvent(picker.datepicker, "changeMonth");
            switch (id) {
              case 0:
                return newDate < first || newDate > last;

              case 1:
                return viewYear !== year;

              default:
                return viewYear < first || viewYear > last;
            }
        }
        function getTextDirection(el) {
            return window.getComputedStyle(el).direction;
        }
        var Picker = function() {
            function Picker(datepicker) {
                _classCallCheck(this, Picker);
                this.datepicker = datepicker;
                var template = pickerTemplate.replace(/%buttonClass%/g, datepicker.config.buttonClass);
                var element = this.element = parseHTML(template).firstChild;
                var _element$firstChild$c = _slicedToArray(element.firstChild.children, 3), header = _element$firstChild$c[0], main = _element$firstChild$c[1], footer = _element$firstChild$c[2];
                var title = header.firstElementChild;
                var _header$lastElementCh = _slicedToArray(header.lastElementChild.children, 3), prevBtn = _header$lastElementCh[0], viewSwitch = _header$lastElementCh[1], nextBtn = _header$lastElementCh[2];
                var _footer$firstChild$ch = _slicedToArray(footer.firstChild.children, 2), todayBtn = _footer$firstChild$ch[0], clearBtn = _footer$firstChild$ch[1];
                var controls = {
                    title,
                    prevBtn,
                    viewSwitch,
                    nextBtn,
                    todayBtn,
                    clearBtn
                };
                this.main = main;
                this.controls = controls;
                var elementClass = datepicker.inline ? "inline" : "dropdown";
                element.classList.add("datepicker-".concat(elementClass));
                elementClass === "dropdown" ? element.classList.add("dropdown", "absolute", "top-0", "left-0", "z-50", "pt-2") : null;
                processPickerOptions(this, datepicker.config);
                this.viewDate = computeResetViewDate(datepicker);
                registerListeners(datepicker, [ [ element, "click", onClickPicker.bind(null, datepicker), {
                    capture: true
                } ], [ main, "click", onClickView.bind(null, datepicker) ], [ controls.viewSwitch, "click", onClickViewSwitch.bind(null, datepicker) ], [ controls.prevBtn, "click", onClickPrevBtn.bind(null, datepicker) ], [ controls.nextBtn, "click", onClickNextBtn.bind(null, datepicker) ], [ controls.todayBtn, "click", onClickTodayBtn.bind(null, datepicker) ], [ controls.clearBtn, "click", onClickClearBtn.bind(null, datepicker) ] ]);
                this.views = [ new DaysView(this), new MonthsView(this), new YearsView(this, {
                    id: 2,
                    name: "years",
                    cellClass: "year",
                    step: 1
                }), new YearsView(this, {
                    id: 3,
                    name: "decades",
                    cellClass: "decade",
                    step: 10
                }) ];
                this.currentView = this.views[datepicker.config.startView];
                this.currentView.render();
                this.main.appendChild(this.currentView.element);
                datepicker.config.container.appendChild(this.element);
            }
            return _createClass(Picker, [ {
                key: "setOptions",
                value: function setOptions(options) {
                    processPickerOptions(this, options);
                    this.views.forEach((function(view) {
                        view.init(options, false);
                    }));
                    this.currentView.render();
                }
            }, {
                key: "detach",
                value: function detach() {
                    this.datepicker.config.container.removeChild(this.element);
                }
            }, {
                key: "show",
                value: function show() {
                    if (this.active) return;
                    this.element.classList.add("active", "block");
                    this.element.classList.remove("hidden");
                    this.active = true;
                    var datepicker = this.datepicker;
                    if (!datepicker.inline) {
                        var inputDirection = getTextDirection(datepicker.inputField);
                        if (inputDirection !== getTextDirection(datepicker.config.container)) this.element.dir = inputDirection; else if (this.element.dir) this.element.removeAttribute("dir");
                        this.place();
                        if (datepicker.config.disableTouchKeyboard) datepicker.inputField.blur();
                    }
                    triggerDatepickerEvent(datepicker, "show");
                }
            }, {
                key: "hide",
                value: function hide() {
                    if (!this.active) return;
                    this.datepicker.exitEditMode();
                    this.element.classList.remove("active", "block");
                    this.element.classList.add("active", "block", "hidden");
                    this.active = false;
                    triggerDatepickerEvent(this.datepicker, "hide");
                }
            }, {
                key: "place",
                value: function place() {
                    var _this$element = this.element, classList = _this$element.classList, style = _this$element.style;
                    var _this$datepicker = this.datepicker, config = _this$datepicker.config, inputField = _this$datepicker.inputField;
                    var container = config.container;
                    var _this$element$getBoun = this.element.getBoundingClientRect(), calendarWidth = _this$element$getBoun.width, calendarHeight = _this$element$getBoun.height;
                    var _container$getBoundin = container.getBoundingClientRect(), containerLeft = _container$getBoundin.left, containerTop = _container$getBoundin.top, containerWidth = _container$getBoundin.width;
                    var _inputField$getBoundi = inputField.getBoundingClientRect(), inputLeft = _inputField$getBoundi.left, inputTop = _inputField$getBoundi.top, inputWidth = _inputField$getBoundi.width, inputHeight = _inputField$getBoundi.height;
                    var _config$orientation = config.orientation, orientX = _config$orientation.x, orientY = _config$orientation.y;
                    var scrollTop;
                    var left;
                    var top;
                    if (container === document.body) {
                        scrollTop = window.scrollY;
                        left = inputLeft + window.scrollX;
                        top = inputTop + scrollTop;
                    } else {
                        scrollTop = container.scrollTop;
                        left = inputLeft - containerLeft;
                        top = inputTop - containerTop + scrollTop;
                    }
                    if (orientX === "auto") if (left < 0) {
                        orientX = "left";
                        left = 10;
                    } else if (left + calendarWidth > containerWidth) orientX = "right"; else orientX = getTextDirection(inputField) === "rtl" ? "right" : "left";
                    if (orientX === "right") left -= calendarWidth - inputWidth;
                    if (orientY === "auto") orientY = top - calendarHeight < scrollTop ? "bottom" : "top";
                    if (orientY === "top") top -= calendarHeight; else top += inputHeight;
                    classList.remove("datepicker-orient-top", "datepicker-orient-bottom", "datepicker-orient-right", "datepicker-orient-left");
                    classList.add("datepicker-orient-".concat(orientY), "datepicker-orient-".concat(orientX));
                    style.top = top ? "".concat(top, "px") : top;
                    style.left = left ? "".concat(left, "px") : left;
                }
            }, {
                key: "setViewSwitchLabel",
                value: function setViewSwitchLabel(labelText) {
                    this.controls.viewSwitch.textContent = labelText;
                }
            }, {
                key: "setPrevBtnDisabled",
                value: function setPrevBtnDisabled(disabled) {
                    this.controls.prevBtn.disabled = disabled;
                }
            }, {
                key: "setNextBtnDisabled",
                value: function setNextBtnDisabled(disabled) {
                    this.controls.nextBtn.disabled = disabled;
                }
            }, {
                key: "changeView",
                value: function changeView(viewId) {
                    var oldView = this.currentView;
                    var newView = this.views[viewId];
                    if (newView.id !== oldView.id) {
                        this.currentView = newView;
                        this._renderMethod = "render";
                        triggerDatepickerEvent(this.datepicker, "changeView");
                        this.main.replaceChild(newView.element, oldView.element);
                    }
                    return this;
                }
            }, {
                key: "changeFocus",
                value: function changeFocus(newViewDate) {
                    this._renderMethod = setViewDate(this, newViewDate) ? "render" : "refreshFocus";
                    this.views.forEach((function(view) {
                        view.updateFocus();
                    }));
                    return this;
                }
            }, {
                key: "update",
                value: function update() {
                    var newViewDate = computeResetViewDate(this.datepicker);
                    this._renderMethod = setViewDate(this, newViewDate) ? "render" : "refresh";
                    this.views.forEach((function(view) {
                        view.updateFocus();
                        view.updateSelection();
                    }));
                    return this;
                }
            }, {
                key: "render",
                value: function render() {
                    var quickRender = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
                    var renderMethod = quickRender && this._renderMethod || "render";
                    delete this._renderMethod;
                    this.currentView[renderMethod]();
                }
            } ]);
        }();
        function findNextAvailableOne(date, addFn, increase, testFn, min, max) {
            if (!isInRange(date, min, max)) return;
            if (testFn(date)) {
                var newDate = addFn(date, increase);
                return findNextAvailableOne(newDate, addFn, increase, testFn, min, max);
            }
            return date;
        }
        function moveByArrowKey(datepicker, ev, direction, vertical) {
            var picker = datepicker.picker;
            var currentView = picker.currentView;
            var step = currentView.step || 1;
            var viewDate = picker.viewDate;
            var addFn;
            var testFn;
            switch (currentView.id) {
              case 0:
                if (vertical) viewDate = addDays(viewDate, direction * 7); else if (ev.ctrlKey || ev.metaKey) viewDate = addYears(viewDate, direction); else viewDate = addDays(viewDate, direction);
                addFn = addDays;
                testFn = function testFn(date) {
                    return currentView.disabled.includes(date);
                };
                break;

              case 1:
                viewDate = addMonths(viewDate, vertical ? direction * 4 : direction);
                addFn = addMonths;
                testFn = function testFn(date) {
                    var dt = new Date(date);
                    var year = currentView.year, disabled = currentView.disabled;
                    return dt.getFullYear() === year && disabled.includes(dt.getMonth());
                };
                break;

              default:
                viewDate = addYears(viewDate, direction * (vertical ? 4 : 1) * step);
                addFn = addYears;
                testFn = function testFn(date) {
                    return currentView.disabled.includes(startOfYearPeriod(date, step));
                };
            }
            viewDate = findNextAvailableOne(viewDate, addFn, direction < 0 ? -step : step, testFn, currentView.minDate, currentView.maxDate);
            if (viewDate !== void 0) picker.changeFocus(viewDate).render();
        }
        function onKeydown(datepicker, ev) {
            if (ev.key === "Tab") {
                unfocus(datepicker);
                return;
            }
            var picker = datepicker.picker;
            var _picker$currentView = picker.currentView, id = _picker$currentView.id, isMinView = _picker$currentView.isMinView;
            if (!picker.active) switch (ev.key) {
              case "ArrowDown":
              case "Escape":
                picker.show();
                break;

              case "Enter":
                datepicker.update();
                break;

              default:
                return;
            } else if (datepicker.editMode) switch (ev.key) {
              case "Escape":
                picker.hide();
                break;

              case "Enter":
                datepicker.exitEditMode({
                    update: true,
                    autohide: datepicker.config.autohide
                });
                break;

              default:
                return;
            } else switch (ev.key) {
              case "Escape":
                picker.hide();
                break;

              case "ArrowLeft":
                if (ev.ctrlKey || ev.metaKey) goToPrevOrNext(datepicker, -1); else if (ev.shiftKey) {
                    datepicker.enterEditMode();
                    return;
                } else moveByArrowKey(datepicker, ev, -1, false);
                break;

              case "ArrowRight":
                if (ev.ctrlKey || ev.metaKey) goToPrevOrNext(datepicker, 1); else if (ev.shiftKey) {
                    datepicker.enterEditMode();
                    return;
                } else moveByArrowKey(datepicker, ev, 1, false);
                break;

              case "ArrowUp":
                if (ev.ctrlKey || ev.metaKey) switchView(datepicker); else if (ev.shiftKey) {
                    datepicker.enterEditMode();
                    return;
                } else moveByArrowKey(datepicker, ev, -1, true);
                break;

              case "ArrowDown":
                if (ev.shiftKey && !ev.ctrlKey && !ev.metaKey) {
                    datepicker.enterEditMode();
                    return;
                }
                moveByArrowKey(datepicker, ev, 1, true);
                break;

              case "Enter":
                if (isMinView) datepicker.setDate(picker.viewDate); else picker.changeView(id - 1).render();
                break;

              case "Backspace":
              case "Delete":
                datepicker.enterEditMode();
                return;

              default:
                if (ev.key.length === 1 && !ev.ctrlKey && !ev.metaKey) datepicker.enterEditMode();
                return;
            }
            ev.preventDefault();
            ev.stopPropagation();
        }
        function onFocus(datepicker) {
            if (datepicker.config.showOnFocus && !datepicker._showing) datepicker.show();
        }
        function onMousedown(datepicker, ev) {
            var el = ev.target;
            if (datepicker.picker.active || datepicker.config.showOnClick) {
                el._active = el === document.activeElement;
                el._clicking = setTimeout((function() {
                    delete el._active;
                    delete el._clicking;
                }), 2e3);
            }
        }
        function onClickInput(datepicker, ev) {
            var el = ev.target;
            if (!el._clicking) return;
            clearTimeout(el._clicking);
            delete el._clicking;
            if (el._active) datepicker.enterEditMode();
            delete el._active;
            if (datepicker.config.showOnClick) datepicker.show();
        }
        function onPaste(datepicker, ev) {
            if (ev.clipboardData.types.includes("text/plain")) datepicker.enterEditMode();
        }
        function onClickOutside(datepicker, ev) {
            var element = datepicker.element;
            if (element !== document.activeElement) return;
            var pickerElem = datepicker.picker.element;
            if (findElementInEventPath(ev, (function(el) {
                return el === element || el === pickerElem;
            }))) return;
            unfocus(datepicker);
        }
        function stringifyDates(dates, config) {
            return dates.map((function(dt) {
                return formatDate(dt, config.format, config.locale);
            })).join(config.dateDelimiter);
        }
        function processInputDates(datepicker, inputDates) {
            var clear = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
            var config = datepicker.config, origDates = datepicker.dates, rangepicker = datepicker.rangepicker;
            if (inputDates.length === 0) return clear ? [] : void 0;
            var rangeEnd = rangepicker && datepicker === rangepicker.datepickers[1];
            var newDates = inputDates.reduce((function(dates, dt) {
                var date = parseDate(dt, config.format, config.locale);
                if (date === void 0) return dates;
                if (config.pickLevel > 0) {
                    var _dt = new Date(date);
                    if (config.pickLevel === 1) date = rangeEnd ? _dt.setMonth(_dt.getMonth() + 1, 0) : _dt.setDate(1); else date = rangeEnd ? _dt.setFullYear(_dt.getFullYear() + 1, 0, 0) : _dt.setMonth(0, 1);
                }
                if (isInRange(date, config.minDate, config.maxDate) && !dates.includes(date) && !config.datesDisabled.includes(date) && !config.daysOfWeekDisabled.includes(new Date(date).getDay())) dates.push(date);
                return dates;
            }), []);
            if (newDates.length === 0) return;
            if (config.multidate && !clear) newDates = newDates.reduce((function(dates, date) {
                if (!origDates.includes(date)) dates.push(date);
                return dates;
            }), origDates.filter((function(date) {
                return !newDates.includes(date);
            })));
            return config.maxNumberOfDates && newDates.length > config.maxNumberOfDates ? newDates.slice(config.maxNumberOfDates * -1) : newDates;
        }
        function refreshUI(datepicker) {
            var mode = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 3;
            var quickRender = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;
            var config = datepicker.config, picker = datepicker.picker, inputField = datepicker.inputField;
            if (mode & 2) {
                var newView = picker.active ? config.pickLevel : config.startView;
                picker.update().changeView(newView).render(quickRender);
            }
            if (mode & 1 && inputField) inputField.value = stringifyDates(datepicker.dates, config);
        }
        function _setDate(datepicker, inputDates, options) {
            var clear = options.clear, render = options.render, autohide = options.autohide;
            if (render === void 0) render = true;
            if (!render) autohide = false; else if (autohide === void 0) autohide = datepicker.config.autohide;
            var newDates = processInputDates(datepicker, inputDates, clear);
            if (!newDates) return;
            if (newDates.toString() !== datepicker.dates.toString()) {
                datepicker.dates = newDates;
                refreshUI(datepicker, render ? 3 : 1);
                triggerDatepickerEvent(datepicker, "changeDate");
            } else refreshUI(datepicker, 1);
            if (autohide) datepicker.hide();
        }
        var main_esm_Datepicker = function() {
            function Datepicker(element) {
                var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
                var rangepicker = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : void 0;
                _classCallCheck(this, Datepicker);
                element.datepicker = this;
                this.element = element;
                var config = this.config = Object.assign({
                    buttonClass: options.buttonClass && String(options.buttonClass) || "button",
                    container: document.body,
                    defaultViewDate: today(),
                    maxDate: void 0,
                    minDate: void 0
                }, processOptions(defaultOptions, this));
                this._options = options;
                Object.assign(config, processOptions(options, this));
                var inline = this.inline = element.tagName !== "INPUT";
                var inputField;
                var initialDates;
                if (inline) {
                    config.container = element;
                    initialDates = stringToArray(element.dataset.date, config.dateDelimiter);
                    delete element.dataset.date;
                } else {
                    var container = options.container ? document.querySelector(options.container) : null;
                    if (container) config.container = container;
                    inputField = this.inputField = element;
                    inputField.classList.add("datepicker-input");
                    initialDates = stringToArray(inputField.value, config.dateDelimiter);
                }
                if (rangepicker) {
                    var index = rangepicker.inputs.indexOf(inputField);
                    var datepickers = rangepicker.datepickers;
                    if (index < 0 || index > 1 || !Array.isArray(datepickers)) throw Error("Invalid rangepicker object.");
                    datepickers[index] = this;
                    Object.defineProperty(this, "rangepicker", {
                        get: function get() {
                            return rangepicker;
                        }
                    });
                }
                this.dates = [];
                var inputDateValues = processInputDates(this, initialDates);
                if (inputDateValues && inputDateValues.length > 0) this.dates = inputDateValues;
                if (inputField) inputField.value = stringifyDates(this.dates, config);
                var picker = this.picker = new Picker(this);
                if (inline) this.show(); else {
                    var onMousedownDocument = onClickOutside.bind(null, this);
                    var listeners = [ [ inputField, "keydown", onKeydown.bind(null, this) ], [ inputField, "focus", onFocus.bind(null, this) ], [ inputField, "mousedown", onMousedown.bind(null, this) ], [ inputField, "click", onClickInput.bind(null, this) ], [ inputField, "paste", onPaste.bind(null, this) ], [ document, "mousedown", onMousedownDocument ], [ document, "touchstart", onMousedownDocument ], [ window, "resize", picker.place.bind(picker) ] ];
                    registerListeners(this, listeners);
                }
            }
            return _createClass(Datepicker, [ {
                key: "active",
                get: function get() {
                    return !!(this.picker && this.picker.active);
                }
            }, {
                key: "pickerElement",
                get: function get() {
                    return this.picker ? this.picker.element : void 0;
                }
            }, {
                key: "setOptions",
                value: function setOptions(options) {
                    var picker = this.picker;
                    var newOptions = processOptions(options, this);
                    Object.assign(this._options, options);
                    Object.assign(this.config, newOptions);
                    picker.setOptions(newOptions);
                    refreshUI(this, 3);
                }
            }, {
                key: "show",
                value: function show() {
                    if (this.inputField) {
                        if (this.inputField.disabled) return;
                        if (this.inputField !== document.activeElement) {
                            this._showing = true;
                            this.inputField.focus();
                            delete this._showing;
                        }
                    }
                    this.picker.show();
                }
            }, {
                key: "hide",
                value: function hide() {
                    if (this.inline) return;
                    this.picker.hide();
                    this.picker.update().changeView(this.config.startView).render();
                }
            }, {
                key: "destroy",
                value: function destroy() {
                    this.hide();
                    unregisterListeners(this);
                    this.picker.detach();
                    if (!this.inline) this.inputField.classList.remove("datepicker-input");
                    delete this.element.datepicker;
                    return this;
                }
            }, {
                key: "getDate",
                value: function getDate() {
                    var _this = this;
                    var format = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : void 0;
                    var callback = format ? function(date) {
                        return formatDate(date, format, _this.config.locale);
                    } : function(date) {
                        return new Date(date);
                    };
                    if (this.config.multidate) return this.dates.map(callback);
                    if (this.dates.length > 0) return callback(this.dates[0]);
                }
            }, {
                key: "setDate",
                value: function setDate() {
                    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
                    var dates = [].concat(args);
                    var opts = {};
                    var lastArg = lastItemOf(args);
                    if (_typeof(lastArg) === "object" && !Array.isArray(lastArg) && !(lastArg instanceof Date) && lastArg) Object.assign(opts, dates.pop());
                    var inputDates = Array.isArray(dates[0]) ? dates[0] : dates;
                    _setDate(this, inputDates, opts);
                }
            }, {
                key: "update",
                value: function update() {
                    var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : void 0;
                    if (this.inline) return;
                    var opts = {
                        clear: true,
                        autohide: !!(options && options.autohide)
                    };
                    var inputDates = stringToArray(this.inputField.value, this.config.dateDelimiter);
                    _setDate(this, inputDates, opts);
                }
            }, {
                key: "refresh",
                value: function refresh() {
                    var target = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : void 0;
                    var forceRender = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
                    if (target && typeof target !== "string") {
                        forceRender = target;
                        target = void 0;
                    }
                    var mode;
                    if (target === "picker") mode = 2; else if (target === "input") mode = 1; else mode = 3;
                    refreshUI(this, mode, !forceRender);
                }
            }, {
                key: "enterEditMode",
                value: function enterEditMode() {
                    if (this.inline || !this.picker.active || this.editMode) return;
                    this.editMode = true;
                    this.inputField.classList.add("in-edit", "border-blue-700", "!border-primary-700");
                }
            }, {
                key: "exitEditMode",
                value: function exitEditMode() {
                    var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : void 0;
                    if (this.inline || !this.editMode) return;
                    var opts = Object.assign({
                        update: false
                    }, options);
                    delete this.editMode;
                    this.inputField.classList.remove("in-edit", "border-blue-700", "!border-primary-700");
                    if (opts.update) this.update(opts);
                }
            } ], [ {
                key: "formatDate",
                value: function formatDate$1(date, format, lang) {
                    return formatDate(date, format, lang && locales[lang] || locales.en);
                }
            }, {
                key: "parseDate",
                value: function parseDate$1(dateStr, format, lang) {
                    return parseDate(dateStr, format, lang && locales[lang] || locales.en);
                }
            }, {
                key: "locales",
                get: function get() {
                    return locales;
                }
            } ]);
        }();
        function filterOptions(options) {
            var newOpts = Object.assign({}, options);
            delete newOpts.inputs;
            delete newOpts.allowOneSidedRange;
            delete newOpts.maxNumberOfDates;
            return newOpts;
        }
        function setupDatepicker(rangepicker, changeDateListener, el, options) {
            registerListeners(rangepicker, [ [ el, "changeDate", changeDateListener ] ]);
            new main_esm_Datepicker(el, options, rangepicker);
        }
        function onChangeDate(rangepicker, ev) {
            if (rangepicker._updating) return;
            rangepicker._updating = true;
            var target = ev.target;
            if (target.datepicker === void 0) return;
            var datepickers = rangepicker.datepickers;
            var setDateOptions = {
                render: false
            };
            var changedSide = rangepicker.inputs.indexOf(target);
            var otherSide = changedSide === 0 ? 1 : 0;
            var changedDate = datepickers[changedSide].dates[0];
            var otherDate = datepickers[otherSide].dates[0];
            if (changedDate !== void 0 && otherDate !== void 0) {
                if (changedSide === 0 && changedDate > otherDate) {
                    datepickers[0].setDate(otherDate, setDateOptions);
                    datepickers[1].setDate(changedDate, setDateOptions);
                } else if (changedSide === 1 && changedDate < otherDate) {
                    datepickers[0].setDate(changedDate, setDateOptions);
                    datepickers[1].setDate(otherDate, setDateOptions);
                }
            } else if (!rangepicker.allowOneSidedRange) if (changedDate !== void 0 || otherDate !== void 0) {
                setDateOptions.clear = true;
                datepickers[otherSide].setDate(datepickers[changedSide].dates, setDateOptions);
            }
            datepickers[0].picker.update().render();
            datepickers[1].picker.update().render();
            delete rangepicker._updating;
        }
        var DateRangePicker = function() {
            function DateRangePicker(element) {
                var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
                _classCallCheck(this, DateRangePicker);
                var inputs = Array.isArray(options.inputs) ? options.inputs : Array.from(element.querySelectorAll("input"));
                if (inputs.length < 2) return;
                element.rangepicker = this;
                this.element = element;
                this.inputs = inputs.slice(0, 2);
                this.allowOneSidedRange = !!options.allowOneSidedRange;
                var changeDateListener = onChangeDate.bind(null, this);
                var cleanOptions = filterOptions(options);
                var datepickers = [];
                Object.defineProperty(this, "datepickers", {
                    get: function get() {
                        return datepickers;
                    }
                });
                setupDatepicker(this, changeDateListener, this.inputs[0], cleanOptions);
                setupDatepicker(this, changeDateListener, this.inputs[1], cleanOptions);
                Object.freeze(datepickers);
                if (datepickers[0].dates.length > 0) onChangeDate(this, {
                    target: this.inputs[0]
                }); else if (datepickers[1].dates.length > 0) onChangeDate(this, {
                    target: this.inputs[1]
                });
            }
            return _createClass(DateRangePicker, [ {
                key: "dates",
                get: function get() {
                    return this.datepickers.length === 2 ? [ this.datepickers[0].dates[0], this.datepickers[1].dates[0] ] : void 0;
                }
            }, {
                key: "setOptions",
                value: function setOptions(options) {
                    this.allowOneSidedRange = !!options.allowOneSidedRange;
                    var cleanOptions = filterOptions(options);
                    this.datepickers[0].setOptions(cleanOptions);
                    this.datepickers[1].setOptions(cleanOptions);
                }
            }, {
                key: "destroy",
                value: function destroy() {
                    this.datepickers[0].destroy();
                    this.datepickers[1].destroy();
                    unregisterListeners(this);
                    delete this.element.rangepicker;
                }
            }, {
                key: "getDates",
                value: function getDates() {
                    var _this = this;
                    var format = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : void 0;
                    var callback = format ? function(date) {
                        return formatDate(date, format, _this.datepickers[0].config.locale);
                    } : function(date) {
                        return new Date(date);
                    };
                    return this.dates.map((function(date) {
                        return date === void 0 ? date : callback(date);
                    }));
                }
            }, {
                key: "setDates",
                value: function setDates(rangeStart, rangeEnd) {
                    var _this$datepickers = _slicedToArray(this.datepickers, 2), datepicker0 = _this$datepickers[0], datepicker1 = _this$datepickers[1];
                    var origDates = this.dates;
                    this._updating = true;
                    datepicker0.setDate(rangeStart);
                    datepicker1.setDate(rangeEnd);
                    delete this._updating;
                    if (datepicker1.dates[0] !== origDates[1]) onChangeDate(this, {
                        target: this.inputs[1]
                    }); else if (datepicker0.dates[0] !== origDates[0]) onChangeDate(this, {
                        target: this.inputs[0]
                    });
                }
            } ]);
        }();
        var datepicker_assign = void 0 && (void 0).__assign || function() {
            datepicker_assign = Object.assign || function(t) {
                for (var s, i = 1, n = arguments.length; i < n; i++) {
                    s = arguments[i];
                    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
                }
                return t;
            };
            return datepicker_assign.apply(this, arguments);
        };
        var datepicker_Default = {
            defaultDatepickerId: null,
            autohide: false,
            format: "mm/dd/yyyy",
            maxDate: null,
            minDate: null,
            orientation: "bottom",
            buttons: false,
            autoSelectToday: 0,
            title: null,
            language: "en",
            rangePicker: false,
            onShow: function() {},
            onHide: function() {}
        };
        var datepicker_DefaultInstanceOptions = {
            id: null,
            override: true
        };
        var Datepicker = function() {
            function Datepicker(datepickerEl, options, instanceOptions) {
                if (datepickerEl === void 0) datepickerEl = null;
                if (options === void 0) options = datepicker_Default;
                if (instanceOptions === void 0) instanceOptions = datepicker_DefaultInstanceOptions;
                this._instanceId = instanceOptions.id ? instanceOptions.id : datepickerEl.id;
                this._datepickerEl = datepickerEl;
                this._datepickerInstance = null;
                this._options = datepicker_assign(datepicker_assign({}, datepicker_Default), options);
                this._initialized = false;
                this.init();
                dom_instances.addInstance("Datepicker", this, this._instanceId, instanceOptions.override);
            }
            Datepicker.prototype.init = function() {
                if (this._datepickerEl && !this._initialized) {
                    if (this._options.rangePicker) this._datepickerInstance = new DateRangePicker(this._datepickerEl, this._getDatepickerOptions(this._options)); else this._datepickerInstance = new main_esm_Datepicker(this._datepickerEl, this._getDatepickerOptions(this._options));
                    this._initialized = true;
                }
            };
            Datepicker.prototype.destroy = function() {
                if (this._initialized) {
                    this._initialized = false;
                    this._datepickerInstance.destroy();
                }
            };
            Datepicker.prototype.removeInstance = function() {
                this.destroy();
                dom_instances.removeInstance("Datepicker", this._instanceId);
            };
            Datepicker.prototype.destroyAndRemoveInstance = function() {
                this.destroy();
                this.removeInstance();
            };
            Datepicker.prototype.getDatepickerInstance = function() {
                return this._datepickerInstance;
            };
            Datepicker.prototype.getDate = function() {
                if (this._options.rangePicker && this._datepickerInstance instanceof DateRangePicker) return this._datepickerInstance.getDates();
                if (!this._options.rangePicker && this._datepickerInstance instanceof main_esm_Datepicker) return this._datepickerInstance.getDate();
            };
            Datepicker.prototype.setDate = function(date) {
                if (this._options.rangePicker && this._datepickerInstance instanceof DateRangePicker) return this._datepickerInstance.setDates(date);
                if (!this._options.rangePicker && this._datepickerInstance instanceof main_esm_Datepicker) return this._datepickerInstance.setDate(date);
            };
            Datepicker.prototype.show = function() {
                this._datepickerInstance.show();
                this._options.onShow(this);
            };
            Datepicker.prototype.hide = function() {
                this._datepickerInstance.hide();
                this._options.onHide(this);
            };
            Datepicker.prototype._getDatepickerOptions = function(options) {
                var datepickerOptions = {};
                if (options.buttons) {
                    datepickerOptions.todayBtn = true;
                    datepickerOptions.clearBtn = true;
                    if (options.autoSelectToday) datepickerOptions.todayBtnMode = 1;
                }
                if (options.autohide) datepickerOptions.autohide = true;
                if (options.format) datepickerOptions.format = options.format;
                if (options.maxDate) datepickerOptions.maxDate = options.maxDate;
                if (options.minDate) datepickerOptions.minDate = options.minDate;
                if (options.orientation) datepickerOptions.orientation = options.orientation;
                if (options.title) datepickerOptions.title = options.title;
                if (options.language) datepickerOptions.language = options.language;
                return datepickerOptions;
            };
            Datepicker.prototype.updateOnShow = function(callback) {
                this._options.onShow = callback;
            };
            Datepicker.prototype.updateOnHide = function(callback) {
                this._options.onHide = callback;
            };
            return Datepicker;
        }();
        function initDatepickers() {
            document.querySelectorAll("[datepicker], [inline-datepicker], [date-rangepicker]").forEach((function($datepickerEl) {
                if ($datepickerEl) {
                    var buttons = $datepickerEl.hasAttribute("datepicker-buttons");
                    var autoselectToday = $datepickerEl.hasAttribute("datepicker-autoselect-today");
                    var autohide = $datepickerEl.hasAttribute("datepicker-autohide");
                    var format = $datepickerEl.getAttribute("datepicker-format");
                    var maxDate = $datepickerEl.getAttribute("datepicker-max-date");
                    var minDate = $datepickerEl.getAttribute("datepicker-min-date");
                    var orientation_1 = $datepickerEl.getAttribute("datepicker-orientation");
                    var title = $datepickerEl.getAttribute("datepicker-title");
                    var language = $datepickerEl.getAttribute("datepicker-language");
                    var rangePicker = $datepickerEl.hasAttribute("date-rangepicker");
                    new Datepicker($datepickerEl, {
                        buttons: buttons ? buttons : datepicker_Default.buttons,
                        autoSelectToday: autoselectToday ? autoselectToday : datepicker_Default.autoSelectToday,
                        autohide: autohide ? autohide : datepicker_Default.autohide,
                        format: format ? format : datepicker_Default.format,
                        maxDate: maxDate ? maxDate : datepicker_Default.maxDate,
                        minDate: minDate ? minDate : datepicker_Default.minDate,
                        orientation: orientation_1 ? orientation_1 : datepicker_Default.orientation,
                        title: title ? title : datepicker_Default.title,
                        language: language ? language : datepicker_Default.language,
                        rangePicker: rangePicker ? rangePicker : datepicker_Default.rangePicker
                    });
                } else console.error("The datepicker element does not exist. Please check the datepicker attribute.");
            }));
        }
        if (typeof window !== "undefined") {
            window.Datepicker = Datepicker;
            window.initDatepickers = initDatepickers;
        }
        function initFlowbite() {
            initAccordions();
            initCollapses();
            initCarousels();
            initDismisses();
            initDropdowns();
            initModals();
            initDrawers();
            initTabs();
            initTooltips();
            initPopovers();
            initDials();
            initInputCounters();
            initCopyClipboards();
            initDatepickers();
        }
        if (typeof window !== "undefined") window.initFlowbite = initFlowbite;
        var esm_events = new events("load", [ initAccordions, initCollapses, initCarousels, initDismisses, initDropdowns, initModals, initDrawers, initTabs, initTooltips, initPopovers, initDials, initInputCounters, initCopyClipboards, initDatepickers ]);
        esm_events.init();
        /*!
 * @kurkle/color v0.3.4
 * https://github.com/kurkle/color#readme
 * (c) 2024 Jukka Kurkela
 * Released under the MIT License
 */
        function color_esm_round(v) {
            return v + .5 | 0;
        }
        const lim = (v, l, h) => Math.max(Math.min(v, h), l);
        function p2b(v) {
            return lim(color_esm_round(v * 2.55), 0, 255);
        }
        function n2b(v) {
            return lim(color_esm_round(v * 255), 0, 255);
        }
        function b2n(v) {
            return lim(color_esm_round(v / 2.55) / 100, 0, 1);
        }
        function n2p(v) {
            return lim(color_esm_round(v * 100), 0, 100);
        }
        const map$1 = {
            0: 0,
            1: 1,
            2: 2,
            3: 3,
            4: 4,
            5: 5,
            6: 6,
            7: 7,
            8: 8,
            9: 9,
            A: 10,
            B: 11,
            C: 12,
            D: 13,
            E: 14,
            F: 15,
            a: 10,
            b: 11,
            c: 12,
            d: 13,
            e: 14,
            f: 15
        };
        const hex = [ ..."0123456789ABCDEF" ];
        const h1 = b => hex[b & 15];
        const h2 = b => hex[(b & 240) >> 4] + hex[b & 15];
        const eq = b => (b & 240) >> 4 === (b & 15);
        const isShort = v => eq(v.r) && eq(v.g) && eq(v.b) && eq(v.a);
        function hexParse(str) {
            var len = str.length;
            var ret;
            if (str[0] === "#") if (len === 4 || len === 5) ret = {
                r: 255 & map$1[str[1]] * 17,
                g: 255 & map$1[str[2]] * 17,
                b: 255 & map$1[str[3]] * 17,
                a: len === 5 ? map$1[str[4]] * 17 : 255
            }; else if (len === 7 || len === 9) ret = {
                r: map$1[str[1]] << 4 | map$1[str[2]],
                g: map$1[str[3]] << 4 | map$1[str[4]],
                b: map$1[str[5]] << 4 | map$1[str[6]],
                a: len === 9 ? map$1[str[7]] << 4 | map$1[str[8]] : 255
            };
            return ret;
        }
        const alpha = (a, f) => a < 255 ? f(a) : "";
        function hexString(v) {
            var f = isShort(v) ? h1 : h2;
            return v ? "#" + f(v.r) + f(v.g) + f(v.b) + alpha(v.a, f) : void 0;
        }
        const HUE_RE = /^(hsla?|hwb|hsv)\(\s*([-+.e\d]+)(?:deg)?[\s,]+([-+.e\d]+)%[\s,]+([-+.e\d]+)%(?:[\s,]+([-+.e\d]+)(%)?)?\s*\)$/;
        function hsl2rgbn(h, s, l) {
            const a = s * Math.min(l, 1 - l);
            const f = (n, k = (n + h / 30) % 12) => l - a * Math.max(Math.min(k - 3, 9 - k, 1), -1);
            return [ f(0), f(8), f(4) ];
        }
        function hsv2rgbn(h, s, v) {
            const f = (n, k = (n + h / 60) % 6) => v - v * s * Math.max(Math.min(k, 4 - k, 1), 0);
            return [ f(5), f(3), f(1) ];
        }
        function hwb2rgbn(h, w, b) {
            const rgb = hsl2rgbn(h, 1, .5);
            let i;
            if (w + b > 1) {
                i = 1 / (w + b);
                w *= i;
                b *= i;
            }
            for (i = 0; i < 3; i++) {
                rgb[i] *= 1 - w - b;
                rgb[i] += w;
            }
            return rgb;
        }
        function hueValue(r, g, b, d, max) {
            if (r === max) return (g - b) / d + (g < b ? 6 : 0);
            if (g === max) return (b - r) / d + 2;
            return (r - g) / d + 4;
        }
        function rgb2hsl(v) {
            const range = 255;
            const r = v.r / range;
            const g = v.g / range;
            const b = v.b / range;
            const max = Math.max(r, g, b);
            const min = Math.min(r, g, b);
            const l = (max + min) / 2;
            let h, s, d;
            if (max !== min) {
                d = max - min;
                s = l > .5 ? d / (2 - max - min) : d / (max + min);
                h = hueValue(r, g, b, d, max);
                h = h * 60 + .5;
            }
            return [ h | 0, s || 0, l ];
        }
        function calln(f, a, b, c) {
            return (Array.isArray(a) ? f(a[0], a[1], a[2]) : f(a, b, c)).map(n2b);
        }
        function hsl2rgb(h, s, l) {
            return calln(hsl2rgbn, h, s, l);
        }
        function hwb2rgb(h, w, b) {
            return calln(hwb2rgbn, h, w, b);
        }
        function hsv2rgb(h, s, v) {
            return calln(hsv2rgbn, h, s, v);
        }
        function hue(h) {
            return (h % 360 + 360) % 360;
        }
        function hueParse(str) {
            const m = HUE_RE.exec(str);
            let a = 255;
            let v;
            if (!m) return;
            if (m[5] !== v) a = m[6] ? p2b(+m[5]) : n2b(+m[5]);
            const h = hue(+m[2]);
            const p1 = +m[3] / 100;
            const p2 = +m[4] / 100;
            if (m[1] === "hwb") v = hwb2rgb(h, p1, p2); else if (m[1] === "hsv") v = hsv2rgb(h, p1, p2); else v = hsl2rgb(h, p1, p2);
            return {
                r: v[0],
                g: v[1],
                b: v[2],
                a
            };
        }
        function rotate(v, deg) {
            var h = rgb2hsl(v);
            h[0] = hue(h[0] + deg);
            h = hsl2rgb(h);
            v.r = h[0];
            v.g = h[1];
            v.b = h[2];
        }
        function hslString(v) {
            if (!v) return;
            const a = rgb2hsl(v);
            const h = a[0];
            const s = n2p(a[1]);
            const l = n2p(a[2]);
            return v.a < 255 ? `hsla(${h}, ${s}%, ${l}%, ${b2n(v.a)})` : `hsl(${h}, ${s}%, ${l}%)`;
        }
        const map = {
            x: "dark",
            Z: "light",
            Y: "re",
            X: "blu",
            W: "gr",
            V: "medium",
            U: "slate",
            A: "ee",
            T: "ol",
            S: "or",
            B: "ra",
            C: "lateg",
            D: "ights",
            R: "in",
            Q: "turquois",
            E: "hi",
            P: "ro",
            O: "al",
            N: "le",
            M: "de",
            L: "yello",
            F: "en",
            K: "ch",
            G: "arks",
            H: "ea",
            I: "ightg",
            J: "wh"
        };
        const names$1 = {
            OiceXe: "f0f8ff",
            antiquewEte: "faebd7",
            aqua: "ffff",
            aquamarRe: "7fffd4",
            azuY: "f0ffff",
            beige: "f5f5dc",
            bisque: "ffe4c4",
            black: "0",
            blanKedOmond: "ffebcd",
            Xe: "ff",
            XeviTet: "8a2be2",
            bPwn: "a52a2a",
            burlywood: "deb887",
            caMtXe: "5f9ea0",
            KartYuse: "7fff00",
            KocTate: "d2691e",
            cSO: "ff7f50",
            cSnflowerXe: "6495ed",
            cSnsilk: "fff8dc",
            crimson: "dc143c",
            cyan: "ffff",
            xXe: "8b",
            xcyan: "8b8b",
            xgTMnPd: "b8860b",
            xWay: "a9a9a9",
            xgYF: "6400",
            xgYy: "a9a9a9",
            xkhaki: "bdb76b",
            xmagFta: "8b008b",
            xTivegYF: "556b2f",
            xSange: "ff8c00",
            xScEd: "9932cc",
            xYd: "8b0000",
            xsOmon: "e9967a",
            xsHgYF: "8fbc8f",
            xUXe: "483d8b",
            xUWay: "2f4f4f",
            xUgYy: "2f4f4f",
            xQe: "ced1",
            xviTet: "9400d3",
            dAppRk: "ff1493",
            dApskyXe: "bfff",
            dimWay: "696969",
            dimgYy: "696969",
            dodgerXe: "1e90ff",
            fiYbrick: "b22222",
            flSOwEte: "fffaf0",
            foYstWAn: "228b22",
            fuKsia: "ff00ff",
            gaRsbSo: "dcdcdc",
            ghostwEte: "f8f8ff",
            gTd: "ffd700",
            gTMnPd: "daa520",
            Way: "808080",
            gYF: "8000",
            gYFLw: "adff2f",
            gYy: "808080",
            honeyMw: "f0fff0",
            hotpRk: "ff69b4",
            RdianYd: "cd5c5c",
            Rdigo: "4b0082",
            ivSy: "fffff0",
            khaki: "f0e68c",
            lavFMr: "e6e6fa",
            lavFMrXsh: "fff0f5",
            lawngYF: "7cfc00",
            NmoncEffon: "fffacd",
            ZXe: "add8e6",
            ZcSO: "f08080",
            Zcyan: "e0ffff",
            ZgTMnPdLw: "fafad2",
            ZWay: "d3d3d3",
            ZgYF: "90ee90",
            ZgYy: "d3d3d3",
            ZpRk: "ffb6c1",
            ZsOmon: "ffa07a",
            ZsHgYF: "20b2aa",
            ZskyXe: "87cefa",
            ZUWay: "778899",
            ZUgYy: "778899",
            ZstAlXe: "b0c4de",
            ZLw: "ffffe0",
            lime: "ff00",
            limegYF: "32cd32",
            lRF: "faf0e6",
            magFta: "ff00ff",
            maPon: "800000",
            VaquamarRe: "66cdaa",
            VXe: "cd",
            VScEd: "ba55d3",
            VpurpN: "9370db",
            VsHgYF: "3cb371",
            VUXe: "7b68ee",
            VsprRggYF: "fa9a",
            VQe: "48d1cc",
            VviTetYd: "c71585",
            midnightXe: "191970",
            mRtcYam: "f5fffa",
            mistyPse: "ffe4e1",
            moccasR: "ffe4b5",
            navajowEte: "ffdead",
            navy: "80",
            Tdlace: "fdf5e6",
            Tive: "808000",
            TivedBb: "6b8e23",
            Sange: "ffa500",
            SangeYd: "ff4500",
            ScEd: "da70d6",
            pOegTMnPd: "eee8aa",
            pOegYF: "98fb98",
            pOeQe: "afeeee",
            pOeviTetYd: "db7093",
            papayawEp: "ffefd5",
            pHKpuff: "ffdab9",
            peru: "cd853f",
            pRk: "ffc0cb",
            plum: "dda0dd",
            powMrXe: "b0e0e6",
            purpN: "800080",
            YbeccapurpN: "663399",
            Yd: "ff0000",
            Psybrown: "bc8f8f",
            PyOXe: "4169e1",
            saddNbPwn: "8b4513",
            sOmon: "fa8072",
            sandybPwn: "f4a460",
            sHgYF: "2e8b57",
            sHshell: "fff5ee",
            siFna: "a0522d",
            silver: "c0c0c0",
            skyXe: "87ceeb",
            UXe: "6a5acd",
            UWay: "708090",
            UgYy: "708090",
            snow: "fffafa",
            sprRggYF: "ff7f",
            stAlXe: "4682b4",
            tan: "d2b48c",
            teO: "8080",
            tEstN: "d8bfd8",
            tomato: "ff6347",
            Qe: "40e0d0",
            viTet: "ee82ee",
            JHt: "f5deb3",
            wEte: "ffffff",
            wEtesmoke: "f5f5f5",
            Lw: "ffff00",
            LwgYF: "9acd32"
        };
        function unpack() {
            const unpacked = {};
            const keys = Object.keys(names$1);
            const tkeys = Object.keys(map);
            let i, j, k, ok, nk;
            for (i = 0; i < keys.length; i++) {
                ok = nk = keys[i];
                for (j = 0; j < tkeys.length; j++) {
                    k = tkeys[j];
                    nk = nk.replace(k, map[k]);
                }
                k = parseInt(names$1[ok], 16);
                unpacked[nk] = [ k >> 16 & 255, k >> 8 & 255, k & 255 ];
            }
            return unpacked;
        }
        let names;
        function nameParse(str) {
            if (!names) {
                names = unpack();
                names.transparent = [ 0, 0, 0, 0 ];
            }
            const a = names[str.toLowerCase()];
            return a && {
                r: a[0],
                g: a[1],
                b: a[2],
                a: a.length === 4 ? a[3] : 255
            };
        }
        const RGB_RE = /^rgba?\(\s*([-+.\d]+)(%)?[\s,]+([-+.e\d]+)(%)?[\s,]+([-+.e\d]+)(%)?(?:[\s,/]+([-+.e\d]+)(%)?)?\s*\)$/;
        function rgbParse(str) {
            const m = RGB_RE.exec(str);
            let a = 255;
            let r, g, b;
            if (!m) return;
            if (m[7] !== r) {
                const v = +m[7];
                a = m[8] ? p2b(v) : lim(v * 255, 0, 255);
            }
            r = +m[1];
            g = +m[3];
            b = +m[5];
            r = 255 & (m[2] ? p2b(r) : lim(r, 0, 255));
            g = 255 & (m[4] ? p2b(g) : lim(g, 0, 255));
            b = 255 & (m[6] ? p2b(b) : lim(b, 0, 255));
            return {
                r,
                g,
                b,
                a
            };
        }
        function rgbString(v) {
            return v && (v.a < 255 ? `rgba(${v.r}, ${v.g}, ${v.b}, ${b2n(v.a)})` : `rgb(${v.r}, ${v.g}, ${v.b})`);
        }
        const to = v => v <= .0031308 ? v * 12.92 : Math.pow(v, 1 / 2.4) * 1.055 - .055;
        const from = v => v <= .04045 ? v / 12.92 : Math.pow((v + .055) / 1.055, 2.4);
        function interpolate(rgb1, rgb2, t) {
            const r = from(b2n(rgb1.r));
            const g = from(b2n(rgb1.g));
            const b = from(b2n(rgb1.b));
            return {
                r: n2b(to(r + t * (from(b2n(rgb2.r)) - r))),
                g: n2b(to(g + t * (from(b2n(rgb2.g)) - g))),
                b: n2b(to(b + t * (from(b2n(rgb2.b)) - b))),
                a: rgb1.a + t * (rgb2.a - rgb1.a)
            };
        }
        function modHSL(v, i, ratio) {
            if (v) {
                let tmp = rgb2hsl(v);
                tmp[i] = Math.max(0, Math.min(tmp[i] + tmp[i] * ratio, i === 0 ? 360 : 1));
                tmp = hsl2rgb(tmp);
                v.r = tmp[0];
                v.g = tmp[1];
                v.b = tmp[2];
            }
        }
        function clone(v, proto) {
            return v ? Object.assign(proto || {}, v) : v;
        }
        function fromObject(input) {
            var v = {
                r: 0,
                g: 0,
                b: 0,
                a: 255
            };
            if (Array.isArray(input)) {
                if (input.length >= 3) {
                    v = {
                        r: input[0],
                        g: input[1],
                        b: input[2],
                        a: 255
                    };
                    if (input.length > 3) v.a = n2b(input[3]);
                }
            } else {
                v = clone(input, {
                    r: 0,
                    g: 0,
                    b: 0,
                    a: 1
                });
                v.a = n2b(v.a);
            }
            return v;
        }
        function functionParse(str) {
            if (str.charAt(0) === "r") return rgbParse(str);
            return hueParse(str);
        }
        class Color {
            constructor(input) {
                if (input instanceof Color) return input;
                const type = typeof input;
                let v;
                if (type === "object") v = fromObject(input); else if (type === "string") v = hexParse(input) || nameParse(input) || functionParse(input);
                this._rgb = v;
                this._valid = !!v;
            }
            get valid() {
                return this._valid;
            }
            get rgb() {
                var v = clone(this._rgb);
                if (v) v.a = b2n(v.a);
                return v;
            }
            set rgb(obj) {
                this._rgb = fromObject(obj);
            }
            rgbString() {
                return this._valid ? rgbString(this._rgb) : void 0;
            }
            hexString() {
                return this._valid ? hexString(this._rgb) : void 0;
            }
            hslString() {
                return this._valid ? hslString(this._rgb) : void 0;
            }
            mix(color, weight) {
                if (color) {
                    const c1 = this.rgb;
                    const c2 = color.rgb;
                    let w2;
                    const p = weight === w2 ? .5 : weight;
                    const w = 2 * p - 1;
                    const a = c1.a - c2.a;
                    const w1 = ((w * a === -1 ? w : (w + a) / (1 + w * a)) + 1) / 2;
                    w2 = 1 - w1;
                    c1.r = 255 & w1 * c1.r + w2 * c2.r + .5;
                    c1.g = 255 & w1 * c1.g + w2 * c2.g + .5;
                    c1.b = 255 & w1 * c1.b + w2 * c2.b + .5;
                    c1.a = p * c1.a + (1 - p) * c2.a;
                    this.rgb = c1;
                }
                return this;
            }
            interpolate(color, t) {
                if (color) this._rgb = interpolate(this._rgb, color._rgb, t);
                return this;
            }
            clone() {
                return new Color(this.rgb);
            }
            alpha(a) {
                this._rgb.a = n2b(a);
                return this;
            }
            clearer(ratio) {
                const rgb = this._rgb;
                rgb.a *= 1 - ratio;
                return this;
            }
            greyscale() {
                const rgb = this._rgb;
                const val = color_esm_round(rgb.r * .3 + rgb.g * .59 + rgb.b * .11);
                rgb.r = rgb.g = rgb.b = val;
                return this;
            }
            opaquer(ratio) {
                const rgb = this._rgb;
                rgb.a *= 1 + ratio;
                return this;
            }
            negate() {
                const v = this._rgb;
                v.r = 255 - v.r;
                v.g = 255 - v.g;
                v.b = 255 - v.b;
                return this;
            }
            lighten(ratio) {
                modHSL(this._rgb, 2, ratio);
                return this;
            }
            darken(ratio) {
                modHSL(this._rgb, 2, -ratio);
                return this;
            }
            saturate(ratio) {
                modHSL(this._rgb, 1, ratio);
                return this;
            }
            desaturate(ratio) {
                modHSL(this._rgb, 1, -ratio);
                return this;
            }
            rotate(deg) {
                rotate(this._rgb, deg);
                return this;
            }
        }
        /*!
 * Chart.js v4.4.7
 * https://www.chartjs.org
 * (c) 2024 Chart.js Contributors
 * Released under the MIT License
 */
        function noop() {}
        const uid = (() => {
            let id = 0;
            return () => id++;
        })();
        function isNullOrUndef(value) {
            return value === null || value === void 0;
        }
        function isArray(value) {
            if (Array.isArray && Array.isArray(value)) return true;
            const type = Object.prototype.toString.call(value);
            if (type.slice(0, 7) === "[object" && type.slice(-6) === "Array]") return true;
            return false;
        }
        function helpers_segment_isObject(value) {
            return value !== null && Object.prototype.toString.call(value) === "[object Object]";
        }
        function isNumberFinite(value) {
            return (typeof value === "number" || value instanceof Number) && isFinite(+value);
        }
        function finiteOrDefault(value, defaultValue) {
            return isNumberFinite(value) ? value : defaultValue;
        }
        function valueOrDefault(value, defaultValue) {
            return typeof value === "undefined" ? defaultValue : value;
        }
        const toPercentage = (value, dimension) => typeof value === "string" && value.endsWith("%") ? parseFloat(value) / 100 : +value / dimension;
        const toDimension = (value, dimension) => typeof value === "string" && value.endsWith("%") ? parseFloat(value) / 100 * dimension : +value;
        function callback(fn, args, thisArg) {
            if (fn && typeof fn.call === "function") return fn.apply(thisArg, args);
        }
        function each(loopable, fn, thisArg, reverse) {
            let i, len, keys;
            if (isArray(loopable)) {
                len = loopable.length;
                if (reverse) for (i = len - 1; i >= 0; i--) fn.call(thisArg, loopable[i], i); else for (i = 0; i < len; i++) fn.call(thisArg, loopable[i], i);
            } else if (helpers_segment_isObject(loopable)) {
                keys = Object.keys(loopable);
                len = keys.length;
                for (i = 0; i < len; i++) fn.call(thisArg, loopable[keys[i]], keys[i]);
            }
        }
        function _elementsEqual(a0, a1) {
            let i, ilen, v0, v1;
            if (!a0 || !a1 || a0.length !== a1.length) return false;
            for (i = 0, ilen = a0.length; i < ilen; ++i) {
                v0 = a0[i];
                v1 = a1[i];
                if (v0.datasetIndex !== v1.datasetIndex || v0.index !== v1.index) return false;
            }
            return true;
        }
        function helpers_segment_clone(source) {
            if (isArray(source)) return source.map(helpers_segment_clone);
            if (helpers_segment_isObject(source)) {
                const target = Object.create(null);
                const keys = Object.keys(source);
                const klen = keys.length;
                let k = 0;
                for (;k < klen; ++k) target[keys[k]] = helpers_segment_clone(source[keys[k]]);
                return target;
            }
            return source;
        }
        function isValidKey(key) {
            return [ "__proto__", "prototype", "constructor" ].indexOf(key) === -1;
        }
        function _merger(key, target, source, options) {
            if (!isValidKey(key)) return;
            const tval = target[key];
            const sval = source[key];
            if (helpers_segment_isObject(tval) && helpers_segment_isObject(sval)) merge(tval, sval, options); else target[key] = helpers_segment_clone(sval);
        }
        function merge(target, source, options) {
            const sources = isArray(source) ? source : [ source ];
            const ilen = sources.length;
            if (!helpers_segment_isObject(target)) return target;
            options = options || {};
            const merger = options.merger || _merger;
            let current;
            for (let i = 0; i < ilen; ++i) {
                current = sources[i];
                if (!helpers_segment_isObject(current)) continue;
                const keys = Object.keys(current);
                for (let k = 0, klen = keys.length; k < klen; ++k) merger(keys[k], target, current, options);
            }
            return target;
        }
        function mergeIf(target, source) {
            return merge(target, source, {
                merger: _mergerIf
            });
        }
        function _mergerIf(key, target, source) {
            if (!isValidKey(key)) return;
            const tval = target[key];
            const sval = source[key];
            if (helpers_segment_isObject(tval) && helpers_segment_isObject(sval)) mergeIf(tval, sval); else if (!Object.prototype.hasOwnProperty.call(target, key)) target[key] = helpers_segment_clone(sval);
        }
        const keyResolvers = {
            "": v => v,
            x: o => o.x,
            y: o => o.y
        };
        function _splitKey(key) {
            const parts = key.split(".");
            const keys = [];
            let tmp = "";
            for (const part of parts) {
                tmp += part;
                if (tmp.endsWith("\\")) tmp = tmp.slice(0, -1) + "."; else {
                    keys.push(tmp);
                    tmp = "";
                }
            }
            return keys;
        }
        function _getKeyResolver(key) {
            const keys = _splitKey(key);
            return obj => {
                for (const k of keys) {
                    if (k === "") break;
                    obj = obj && obj[k];
                }
                return obj;
            };
        }
        function resolveObjectKey(obj, key) {
            const resolver = keyResolvers[key] || (keyResolvers[key] = _getKeyResolver(key));
            return resolver(obj);
        }
        function _capitalize(str) {
            return str.charAt(0).toUpperCase() + str.slice(1);
        }
        const defined = value => typeof value !== "undefined";
        const isFunction = value => typeof value === "function";
        const setsEqual = (a, b) => {
            if (a.size !== b.size) return false;
            for (const item of a) if (!b.has(item)) return false;
            return true;
        };
        function _isClickEvent(e) {
            return e.type === "mouseup" || e.type === "click" || e.type === "contextmenu";
        }
        const PI = Math.PI;
        const TAU = 2 * PI;
        const PITAU = TAU + PI;
        const INFINITY = Number.POSITIVE_INFINITY;
        const RAD_PER_DEG = PI / 180;
        const HALF_PI = PI / 2;
        const QUARTER_PI = PI / 4;
        const TWO_THIRDS_PI = PI * 2 / 3;
        const log10 = Math.log10;
        const sign = Math.sign;
        function almostEquals(x, y, epsilon) {
            return Math.abs(x - y) < epsilon;
        }
        function niceNum(range) {
            const roundedRange = Math.round(range);
            range = almostEquals(range, roundedRange, range / 1e3) ? roundedRange : range;
            const niceRange = Math.pow(10, Math.floor(log10(range)));
            const fraction = range / niceRange;
            const niceFraction = fraction <= 1 ? 1 : fraction <= 2 ? 2 : fraction <= 5 ? 5 : 10;
            return niceFraction * niceRange;
        }
        function _factorize(value) {
            const result = [];
            const sqrt = Math.sqrt(value);
            let i;
            for (i = 1; i < sqrt; i++) if (value % i === 0) {
                result.push(i);
                result.push(value / i);
            }
            if (sqrt === (sqrt | 0)) result.push(sqrt);
            result.sort(((a, b) => a - b)).pop();
            return result;
        }
        function isNumber(n) {
            return !isNaN(parseFloat(n)) && isFinite(n);
        }
        function almostWhole(x, epsilon) {
            const rounded = Math.round(x);
            return rounded - epsilon <= x && rounded + epsilon >= x;
        }
        function _setMinAndMaxByKey(array, target, property) {
            let i, ilen, value;
            for (i = 0, ilen = array.length; i < ilen; i++) {
                value = array[i][property];
                if (!isNaN(value)) {
                    target.min = Math.min(target.min, value);
                    target.max = Math.max(target.max, value);
                }
            }
        }
        function toRadians(degrees) {
            return degrees * (PI / 180);
        }
        function toDegrees(radians) {
            return radians * (180 / PI);
        }
        function _decimalPlaces(x) {
            if (!isNumberFinite(x)) return;
            let e = 1;
            let p = 0;
            while (Math.round(x * e) / e !== x) {
                e *= 10;
                p++;
            }
            return p;
        }
        function getAngleFromPoint(centrePoint, anglePoint) {
            const distanceFromXCenter = anglePoint.x - centrePoint.x;
            const distanceFromYCenter = anglePoint.y - centrePoint.y;
            const radialDistanceFromCenter = Math.sqrt(distanceFromXCenter * distanceFromXCenter + distanceFromYCenter * distanceFromYCenter);
            let angle = Math.atan2(distanceFromYCenter, distanceFromXCenter);
            if (angle < -.5 * PI) angle += TAU;
            return {
                angle,
                distance: radialDistanceFromCenter
            };
        }
        function distanceBetweenPoints(pt1, pt2) {
            return Math.sqrt(Math.pow(pt2.x - pt1.x, 2) + Math.pow(pt2.y - pt1.y, 2));
        }
        function _angleDiff(a, b) {
            return (a - b + PITAU) % TAU - PI;
        }
        function _normalizeAngle(a) {
            return (a % TAU + TAU) % TAU;
        }
        function _angleBetween(angle, start, end, sameAngleIsFullCircle) {
            const a = _normalizeAngle(angle);
            const s = _normalizeAngle(start);
            const e = _normalizeAngle(end);
            const angleToStart = _normalizeAngle(s - a);
            const angleToEnd = _normalizeAngle(e - a);
            const startToAngle = _normalizeAngle(a - s);
            const endToAngle = _normalizeAngle(a - e);
            return a === s || a === e || sameAngleIsFullCircle && s === e || angleToStart > angleToEnd && startToAngle < endToAngle;
        }
        function _limitValue(value, min, max) {
            return Math.max(min, Math.min(max, value));
        }
        function _int16Range(value) {
            return _limitValue(value, -32768, 32767);
        }
        function _isBetween(value, start, end, epsilon = 1e-6) {
            return value >= Math.min(start, end) - epsilon && value <= Math.max(start, end) + epsilon;
        }
        function _lookup(table, value, cmp) {
            cmp = cmp || (index => table[index] < value);
            let hi = table.length - 1;
            let lo = 0;
            let mid;
            while (hi - lo > 1) {
                mid = lo + hi >> 1;
                if (cmp(mid)) lo = mid; else hi = mid;
            }
            return {
                lo,
                hi
            };
        }
        const _lookupByKey = (table, key, value, last) => _lookup(table, value, last ? index => {
            const ti = table[index][key];
            return ti < value || ti === value && table[index + 1][key] === value;
        } : index => table[index][key] < value);
        const _rlookupByKey = (table, key, value) => _lookup(table, value, (index => table[index][key] >= value));
        function _filterBetween(values, min, max) {
            let start = 0;
            let end = values.length;
            while (start < end && values[start] < min) start++;
            while (end > start && values[end - 1] > max) end--;
            return start > 0 || end < values.length ? values.slice(start, end) : values;
        }
        const arrayEvents = [ "push", "pop", "shift", "splice", "unshift" ];
        function listenArrayEvents(array, listener) {
            if (array._chartjs) {
                array._chartjs.listeners.push(listener);
                return;
            }
            Object.defineProperty(array, "_chartjs", {
                configurable: true,
                enumerable: false,
                value: {
                    listeners: [ listener ]
                }
            });
            arrayEvents.forEach((key => {
                const method = "_onData" + _capitalize(key);
                const base = array[key];
                Object.defineProperty(array, key, {
                    configurable: true,
                    enumerable: false,
                    value(...args) {
                        const res = base.apply(this, args);
                        array._chartjs.listeners.forEach((object => {
                            if (typeof object[method] === "function") object[method](...args);
                        }));
                        return res;
                    }
                });
            }));
        }
        function unlistenArrayEvents(array, listener) {
            const stub = array._chartjs;
            if (!stub) return;
            const listeners = stub.listeners;
            const index = listeners.indexOf(listener);
            if (index !== -1) listeners.splice(index, 1);
            if (listeners.length > 0) return;
            arrayEvents.forEach((key => {
                delete array[key];
            }));
            delete array._chartjs;
        }
        function _arrayUnique(items) {
            const set = new Set(items);
            if (set.size === items.length) return items;
            return Array.from(set);
        }
        const requestAnimFrame = function() {
            if (typeof window === "undefined") return function(callback) {
                return callback();
            };
            return window.requestAnimationFrame;
        }();
        function throttled(fn, thisArg) {
            let argsToUse = [];
            let ticking = false;
            return function(...args) {
                argsToUse = args;
                if (!ticking) {
                    ticking = true;
                    requestAnimFrame.call(window, (() => {
                        ticking = false;
                        fn.apply(thisArg, argsToUse);
                    }));
                }
            };
        }
        function helpers_segment_debounce(fn, delay) {
            let timeout;
            return function(...args) {
                if (delay) {
                    clearTimeout(timeout);
                    timeout = setTimeout(fn, delay, args);
                } else fn.apply(this, args);
                return delay;
            };
        }
        const _toLeftRightCenter = align => align === "start" ? "left" : align === "end" ? "right" : "center";
        const _alignStartEnd = (align, start, end) => align === "start" ? start : align === "end" ? end : (start + end) / 2;
        const _textX = (align, left, right, rtl) => {
            const check = rtl ? "left" : "right";
            return align === check ? right : align === "center" ? (left + right) / 2 : left;
        };
        function _getStartAndCountOfVisiblePoints(meta, points, animationsDisabled) {
            const pointCount = points.length;
            let start = 0;
            let count = pointCount;
            if (meta._sorted) {
                const {iScale, _parsed} = meta;
                const axis = iScale.axis;
                const {min, max, minDefined, maxDefined} = iScale.getUserBounds();
                if (minDefined) start = _limitValue(Math.min(_lookupByKey(_parsed, axis, min).lo, animationsDisabled ? pointCount : _lookupByKey(points, axis, iScale.getPixelForValue(min)).lo), 0, pointCount - 1);
                if (maxDefined) count = _limitValue(Math.max(_lookupByKey(_parsed, iScale.axis, max, true).hi + 1, animationsDisabled ? 0 : _lookupByKey(points, axis, iScale.getPixelForValue(max), true).hi + 1), start, pointCount) - start; else count = pointCount - start;
            }
            return {
                start,
                count
            };
        }
        function _scaleRangesChanged(meta) {
            const {xScale, yScale, _scaleRanges} = meta;
            const newRanges = {
                xmin: xScale.min,
                xmax: xScale.max,
                ymin: yScale.min,
                ymax: yScale.max
            };
            if (!_scaleRanges) {
                meta._scaleRanges = newRanges;
                return true;
            }
            const changed = _scaleRanges.xmin !== xScale.min || _scaleRanges.xmax !== xScale.max || _scaleRanges.ymin !== yScale.min || _scaleRanges.ymax !== yScale.max;
            Object.assign(_scaleRanges, newRanges);
            return changed;
        }
        const atEdge = t => t === 0 || t === 1;
        const elasticIn = (t, s, p) => -Math.pow(2, 10 * (t -= 1)) * Math.sin((t - s) * TAU / p);
        const elasticOut = (t, s, p) => Math.pow(2, -10 * t) * Math.sin((t - s) * TAU / p) + 1;
        const effects = {
            linear: t => t,
            easeInQuad: t => t * t,
            easeOutQuad: t => -t * (t - 2),
            easeInOutQuad: t => (t /= .5) < 1 ? .5 * t * t : -.5 * (--t * (t - 2) - 1),
            easeInCubic: t => t * t * t,
            easeOutCubic: t => (t -= 1) * t * t + 1,
            easeInOutCubic: t => (t /= .5) < 1 ? .5 * t * t * t : .5 * ((t -= 2) * t * t + 2),
            easeInQuart: t => t * t * t * t,
            easeOutQuart: t => -((t -= 1) * t * t * t - 1),
            easeInOutQuart: t => (t /= .5) < 1 ? .5 * t * t * t * t : -.5 * ((t -= 2) * t * t * t - 2),
            easeInQuint: t => t * t * t * t * t,
            easeOutQuint: t => (t -= 1) * t * t * t * t + 1,
            easeInOutQuint: t => (t /= .5) < 1 ? .5 * t * t * t * t * t : .5 * ((t -= 2) * t * t * t * t + 2),
            easeInSine: t => -Math.cos(t * HALF_PI) + 1,
            easeOutSine: t => Math.sin(t * HALF_PI),
            easeInOutSine: t => -.5 * (Math.cos(PI * t) - 1),
            easeInExpo: t => t === 0 ? 0 : Math.pow(2, 10 * (t - 1)),
            easeOutExpo: t => t === 1 ? 1 : -Math.pow(2, -10 * t) + 1,
            easeInOutExpo: t => atEdge(t) ? t : t < .5 ? .5 * Math.pow(2, 10 * (t * 2 - 1)) : .5 * (-Math.pow(2, -10 * (t * 2 - 1)) + 2),
            easeInCirc: t => t >= 1 ? t : -(Math.sqrt(1 - t * t) - 1),
            easeOutCirc: t => Math.sqrt(1 - (t -= 1) * t),
            easeInOutCirc: t => (t /= .5) < 1 ? -.5 * (Math.sqrt(1 - t * t) - 1) : .5 * (Math.sqrt(1 - (t -= 2) * t) + 1),
            easeInElastic: t => atEdge(t) ? t : elasticIn(t, .075, .3),
            easeOutElastic: t => atEdge(t) ? t : elasticOut(t, .075, .3),
            easeInOutElastic(t) {
                const s = .1125;
                const p = .45;
                return atEdge(t) ? t : t < .5 ? .5 * elasticIn(t * 2, s, p) : .5 + .5 * elasticOut(t * 2 - 1, s, p);
            },
            easeInBack(t) {
                const s = 1.70158;
                return t * t * ((s + 1) * t - s);
            },
            easeOutBack(t) {
                const s = 1.70158;
                return (t -= 1) * t * ((s + 1) * t + s) + 1;
            },
            easeInOutBack(t) {
                let s = 1.70158;
                if ((t /= .5) < 1) return .5 * (t * t * (((s *= 1.525) + 1) * t - s));
                return .5 * ((t -= 2) * t * (((s *= 1.525) + 1) * t + s) + 2);
            },
            easeInBounce: t => 1 - effects.easeOutBounce(1 - t),
            easeOutBounce(t) {
                const m = 7.5625;
                const d = 2.75;
                if (t < 1 / d) return m * t * t;
                if (t < 2 / d) return m * (t -= 1.5 / d) * t + .75;
                if (t < 2.5 / d) return m * (t -= 2.25 / d) * t + .9375;
                return m * (t -= 2.625 / d) * t + .984375;
            },
            easeInOutBounce: t => t < .5 ? effects.easeInBounce(t * 2) * .5 : effects.easeOutBounce(t * 2 - 1) * .5 + .5
        };
        function isPatternOrGradient(value) {
            if (value && typeof value === "object") {
                const type = value.toString();
                return type === "[object CanvasPattern]" || type === "[object CanvasGradient]";
            }
            return false;
        }
        function color(value) {
            return isPatternOrGradient(value) ? value : new Color(value);
        }
        function getHoverColor(value) {
            return isPatternOrGradient(value) ? value : new Color(value).saturate(.5).darken(.1).hexString();
        }
        const numbers = [ "x", "y", "borderWidth", "radius", "tension" ];
        const colors = [ "color", "borderColor", "backgroundColor" ];
        function applyAnimationsDefaults(defaults) {
            defaults.set("animation", {
                delay: void 0,
                duration: 1e3,
                easing: "easeOutQuart",
                fn: void 0,
                from: void 0,
                loop: void 0,
                to: void 0,
                type: void 0
            });
            defaults.describe("animation", {
                _fallback: false,
                _indexable: false,
                _scriptable: name => name !== "onProgress" && name !== "onComplete" && name !== "fn"
            });
            defaults.set("animations", {
                colors: {
                    type: "color",
                    properties: colors
                },
                numbers: {
                    type: "number",
                    properties: numbers
                }
            });
            defaults.describe("animations", {
                _fallback: "animation"
            });
            defaults.set("transitions", {
                active: {
                    animation: {
                        duration: 400
                    }
                },
                resize: {
                    animation: {
                        duration: 0
                    }
                },
                show: {
                    animations: {
                        colors: {
                            from: "transparent"
                        },
                        visible: {
                            type: "boolean",
                            duration: 0
                        }
                    }
                },
                hide: {
                    animations: {
                        colors: {
                            to: "transparent"
                        },
                        visible: {
                            type: "boolean",
                            easing: "linear",
                            fn: v => v | 0
                        }
                    }
                }
            });
        }
        function applyLayoutsDefaults(defaults) {
            defaults.set("layout", {
                autoPadding: true,
                padding: {
                    top: 0,
                    right: 0,
                    bottom: 0,
                    left: 0
                }
            });
        }
        const intlCache = new Map;
        function getNumberFormat(locale, options) {
            options = options || {};
            const cacheKey = locale + JSON.stringify(options);
            let formatter = intlCache.get(cacheKey);
            if (!formatter) {
                formatter = new Intl.NumberFormat(locale, options);
                intlCache.set(cacheKey, formatter);
            }
            return formatter;
        }
        function formatNumber(num, locale, options) {
            return getNumberFormat(locale, options).format(num);
        }
        const formatters = {
            values(value) {
                return isArray(value) ? value : "" + value;
            },
            numeric(tickValue, index, ticks) {
                if (tickValue === 0) return "0";
                const locale = this.chart.options.locale;
                let notation;
                let delta = tickValue;
                if (ticks.length > 1) {
                    const maxTick = Math.max(Math.abs(ticks[0].value), Math.abs(ticks[ticks.length - 1].value));
                    if (maxTick < 1e-4 || maxTick > 1e15) notation = "scientific";
                    delta = calculateDelta(tickValue, ticks);
                }
                const logDelta = log10(Math.abs(delta));
                const numDecimal = isNaN(logDelta) ? 1 : Math.max(Math.min(-1 * Math.floor(logDelta), 20), 0);
                const options = {
                    notation,
                    minimumFractionDigits: numDecimal,
                    maximumFractionDigits: numDecimal
                };
                Object.assign(options, this.options.ticks.format);
                return formatNumber(tickValue, locale, options);
            },
            logarithmic(tickValue, index, ticks) {
                if (tickValue === 0) return "0";
                const remain = ticks[index].significand || tickValue / Math.pow(10, Math.floor(log10(tickValue)));
                if ([ 1, 2, 3, 5, 10, 15 ].includes(remain) || index > .8 * ticks.length) return formatters.numeric.call(this, tickValue, index, ticks);
                return "";
            }
        };
        function calculateDelta(tickValue, ticks) {
            let delta = ticks.length > 3 ? ticks[2].value - ticks[1].value : ticks[1].value - ticks[0].value;
            if (Math.abs(delta) >= 1 && tickValue !== Math.floor(tickValue)) delta = tickValue - Math.floor(tickValue);
            return delta;
        }
        var Ticks = {
            formatters
        };
        function applyScaleDefaults(defaults) {
            defaults.set("scale", {
                display: true,
                offset: false,
                reverse: false,
                beginAtZero: false,
                bounds: "ticks",
                clip: true,
                grace: 0,
                grid: {
                    display: true,
                    lineWidth: 1,
                    drawOnChartArea: true,
                    drawTicks: true,
                    tickLength: 8,
                    tickWidth: (_ctx, options) => options.lineWidth,
                    tickColor: (_ctx, options) => options.color,
                    offset: false
                },
                border: {
                    display: true,
                    dash: [],
                    dashOffset: 0,
                    width: 1
                },
                title: {
                    display: false,
                    text: "",
                    padding: {
                        top: 4,
                        bottom: 4
                    }
                },
                ticks: {
                    minRotation: 0,
                    maxRotation: 50,
                    mirror: false,
                    textStrokeWidth: 0,
                    textStrokeColor: "",
                    padding: 3,
                    display: true,
                    autoSkip: true,
                    autoSkipPadding: 3,
                    labelOffset: 0,
                    callback: Ticks.formatters.values,
                    minor: {},
                    major: {},
                    align: "center",
                    crossAlign: "near",
                    showLabelBackdrop: false,
                    backdropColor: "rgba(255, 255, 255, 0.75)",
                    backdropPadding: 2
                }
            });
            defaults.route("scale.ticks", "color", "", "color");
            defaults.route("scale.grid", "color", "", "borderColor");
            defaults.route("scale.border", "color", "", "borderColor");
            defaults.route("scale.title", "color", "", "color");
            defaults.describe("scale", {
                _fallback: false,
                _scriptable: name => !name.startsWith("before") && !name.startsWith("after") && name !== "callback" && name !== "parser",
                _indexable: name => name !== "borderDash" && name !== "tickBorderDash" && name !== "dash"
            });
            defaults.describe("scales", {
                _fallback: "scale"
            });
            defaults.describe("scale.ticks", {
                _scriptable: name => name !== "backdropPadding" && name !== "callback",
                _indexable: name => name !== "backdropPadding"
            });
        }
        const overrides = Object.create(null);
        const descriptors = Object.create(null);
        function getScope$1(node, key) {
            if (!key) return node;
            const keys = key.split(".");
            for (let i = 0, n = keys.length; i < n; ++i) {
                const k = keys[i];
                node = node[k] || (node[k] = Object.create(null));
            }
            return node;
        }
        function set(root, scope, values) {
            if (typeof scope === "string") return merge(getScope$1(root, scope), values);
            return merge(getScope$1(root, ""), scope);
        }
        class Defaults {
            constructor(_descriptors, _appliers) {
                this.animation = void 0;
                this.backgroundColor = "rgba(0,0,0,0.1)";
                this.borderColor = "rgba(0,0,0,0.1)";
                this.color = "#666";
                this.datasets = {};
                this.devicePixelRatio = context => context.chart.platform.getDevicePixelRatio();
                this.elements = {};
                this.events = [ "mousemove", "mouseout", "click", "touchstart", "touchmove" ];
                this.font = {
                    family: "'Helvetica Neue', 'Helvetica', 'Arial', sans-serif",
                    size: 12,
                    style: "normal",
                    lineHeight: 1.2,
                    weight: null
                };
                this.hover = {};
                this.hoverBackgroundColor = (ctx, options) => getHoverColor(options.backgroundColor);
                this.hoverBorderColor = (ctx, options) => getHoverColor(options.borderColor);
                this.hoverColor = (ctx, options) => getHoverColor(options.color);
                this.indexAxis = "x";
                this.interaction = {
                    mode: "nearest",
                    intersect: true,
                    includeInvisible: false
                };
                this.maintainAspectRatio = true;
                this.onHover = null;
                this.onClick = null;
                this.parsing = true;
                this.plugins = {};
                this.responsive = true;
                this.scale = void 0;
                this.scales = {};
                this.showLine = true;
                this.drawActiveElementsOnTop = true;
                this.describe(_descriptors);
                this.apply(_appliers);
            }
            set(scope, values) {
                return set(this, scope, values);
            }
            get(scope) {
                return getScope$1(this, scope);
            }
            describe(scope, values) {
                return set(descriptors, scope, values);
            }
            override(scope, values) {
                return set(overrides, scope, values);
            }
            route(scope, name, targetScope, targetName) {
                const scopeObject = getScope$1(this, scope);
                const targetScopeObject = getScope$1(this, targetScope);
                const privateName = "_" + name;
                Object.defineProperties(scopeObject, {
                    [privateName]: {
                        value: scopeObject[name],
                        writable: true
                    },
                    [name]: {
                        enumerable: true,
                        get() {
                            const local = this[privateName];
                            const target = targetScopeObject[targetName];
                            if (helpers_segment_isObject(local)) return Object.assign({}, target, local);
                            return valueOrDefault(local, target);
                        },
                        set(value) {
                            this[privateName] = value;
                        }
                    }
                });
            }
            apply(appliers) {
                appliers.forEach((apply => apply(this)));
            }
        }
        var defaults = new Defaults({
            _scriptable: name => !name.startsWith("on"),
            _indexable: name => name !== "events",
            hover: {
                _fallback: "interaction"
            },
            interaction: {
                _scriptable: false,
                _indexable: false
            }
        }, [ applyAnimationsDefaults, applyLayoutsDefaults, applyScaleDefaults ]);
        function toFontString(font) {
            if (!font || isNullOrUndef(font.size) || isNullOrUndef(font.family)) return null;
            return (font.style ? font.style + " " : "") + (font.weight ? font.weight + " " : "") + font.size + "px " + font.family;
        }
        function _measureText(ctx, data, gc, longest, string) {
            let textWidth = data[string];
            if (!textWidth) {
                textWidth = data[string] = ctx.measureText(string).width;
                gc.push(string);
            }
            if (textWidth > longest) longest = textWidth;
            return longest;
        }
        function _longestText(ctx, font, arrayOfThings, cache) {
            cache = cache || {};
            let data = cache.data = cache.data || {};
            let gc = cache.garbageCollect = cache.garbageCollect || [];
            if (cache.font !== font) {
                data = cache.data = {};
                gc = cache.garbageCollect = [];
                cache.font = font;
            }
            ctx.save();
            ctx.font = font;
            let longest = 0;
            const ilen = arrayOfThings.length;
            let i, j, jlen, thing, nestedThing;
            for (i = 0; i < ilen; i++) {
                thing = arrayOfThings[i];
                if (thing !== void 0 && thing !== null && !isArray(thing)) longest = _measureText(ctx, data, gc, longest, thing); else if (isArray(thing)) for (j = 0, 
                jlen = thing.length; j < jlen; j++) {
                    nestedThing = thing[j];
                    if (nestedThing !== void 0 && nestedThing !== null && !isArray(nestedThing)) longest = _measureText(ctx, data, gc, longest, nestedThing);
                }
            }
            ctx.restore();
            const gcLen = gc.length / 2;
            if (gcLen > arrayOfThings.length) {
                for (i = 0; i < gcLen; i++) delete data[gc[i]];
                gc.splice(0, gcLen);
            }
            return longest;
        }
        function _alignPixel(chart, pixel, width) {
            const devicePixelRatio = chart.currentDevicePixelRatio;
            const halfWidth = width !== 0 ? Math.max(width / 2, .5) : 0;
            return Math.round((pixel - halfWidth) * devicePixelRatio) / devicePixelRatio + halfWidth;
        }
        function clearCanvas(canvas, ctx) {
            if (!ctx && !canvas) return;
            ctx = ctx || canvas.getContext("2d");
            ctx.save();
            ctx.resetTransform();
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.restore();
        }
        function drawPoint(ctx, options, x, y) {
            drawPointLegend(ctx, options, x, y, null);
        }
        function drawPointLegend(ctx, options, x, y, w) {
            let type, xOffset, yOffset, size, cornerRadius, width, xOffsetW, yOffsetW;
            const style = options.pointStyle;
            const rotation = options.rotation;
            const radius = options.radius;
            let rad = (rotation || 0) * RAD_PER_DEG;
            if (style && typeof style === "object") {
                type = style.toString();
                if (type === "[object HTMLImageElement]" || type === "[object HTMLCanvasElement]") {
                    ctx.save();
                    ctx.translate(x, y);
                    ctx.rotate(rad);
                    ctx.drawImage(style, -style.width / 2, -style.height / 2, style.width, style.height);
                    ctx.restore();
                    return;
                }
            }
            if (isNaN(radius) || radius <= 0) return;
            ctx.beginPath();
            switch (style) {
              default:
                if (w) ctx.ellipse(x, y, w / 2, radius, 0, 0, TAU); else ctx.arc(x, y, radius, 0, TAU);
                ctx.closePath();
                break;

              case "triangle":
                width = w ? w / 2 : radius;
                ctx.moveTo(x + Math.sin(rad) * width, y - Math.cos(rad) * radius);
                rad += TWO_THIRDS_PI;
                ctx.lineTo(x + Math.sin(rad) * width, y - Math.cos(rad) * radius);
                rad += TWO_THIRDS_PI;
                ctx.lineTo(x + Math.sin(rad) * width, y - Math.cos(rad) * radius);
                ctx.closePath();
                break;

              case "rectRounded":
                cornerRadius = radius * .516;
                size = radius - cornerRadius;
                xOffset = Math.cos(rad + QUARTER_PI) * size;
                xOffsetW = Math.cos(rad + QUARTER_PI) * (w ? w / 2 - cornerRadius : size);
                yOffset = Math.sin(rad + QUARTER_PI) * size;
                yOffsetW = Math.sin(rad + QUARTER_PI) * (w ? w / 2 - cornerRadius : size);
                ctx.arc(x - xOffsetW, y - yOffset, cornerRadius, rad - PI, rad - HALF_PI);
                ctx.arc(x + yOffsetW, y - xOffset, cornerRadius, rad - HALF_PI, rad);
                ctx.arc(x + xOffsetW, y + yOffset, cornerRadius, rad, rad + HALF_PI);
                ctx.arc(x - yOffsetW, y + xOffset, cornerRadius, rad + HALF_PI, rad + PI);
                ctx.closePath();
                break;

              case "rect":
                if (!rotation) {
                    size = Math.SQRT1_2 * radius;
                    width = w ? w / 2 : size;
                    ctx.rect(x - width, y - size, 2 * width, 2 * size);
                    break;
                }
                rad += QUARTER_PI;

              case "rectRot":
                xOffsetW = Math.cos(rad) * (w ? w / 2 : radius);
                xOffset = Math.cos(rad) * radius;
                yOffset = Math.sin(rad) * radius;
                yOffsetW = Math.sin(rad) * (w ? w / 2 : radius);
                ctx.moveTo(x - xOffsetW, y - yOffset);
                ctx.lineTo(x + yOffsetW, y - xOffset);
                ctx.lineTo(x + xOffsetW, y + yOffset);
                ctx.lineTo(x - yOffsetW, y + xOffset);
                ctx.closePath();
                break;

              case "crossRot":
                rad += QUARTER_PI;

              case "cross":
                xOffsetW = Math.cos(rad) * (w ? w / 2 : radius);
                xOffset = Math.cos(rad) * radius;
                yOffset = Math.sin(rad) * radius;
                yOffsetW = Math.sin(rad) * (w ? w / 2 : radius);
                ctx.moveTo(x - xOffsetW, y - yOffset);
                ctx.lineTo(x + xOffsetW, y + yOffset);
                ctx.moveTo(x + yOffsetW, y - xOffset);
                ctx.lineTo(x - yOffsetW, y + xOffset);
                break;

              case "star":
                xOffsetW = Math.cos(rad) * (w ? w / 2 : radius);
                xOffset = Math.cos(rad) * radius;
                yOffset = Math.sin(rad) * radius;
                yOffsetW = Math.sin(rad) * (w ? w / 2 : radius);
                ctx.moveTo(x - xOffsetW, y - yOffset);
                ctx.lineTo(x + xOffsetW, y + yOffset);
                ctx.moveTo(x + yOffsetW, y - xOffset);
                ctx.lineTo(x - yOffsetW, y + xOffset);
                rad += QUARTER_PI;
                xOffsetW = Math.cos(rad) * (w ? w / 2 : radius);
                xOffset = Math.cos(rad) * radius;
                yOffset = Math.sin(rad) * radius;
                yOffsetW = Math.sin(rad) * (w ? w / 2 : radius);
                ctx.moveTo(x - xOffsetW, y - yOffset);
                ctx.lineTo(x + xOffsetW, y + yOffset);
                ctx.moveTo(x + yOffsetW, y - xOffset);
                ctx.lineTo(x - yOffsetW, y + xOffset);
                break;

              case "line":
                xOffset = w ? w / 2 : Math.cos(rad) * radius;
                yOffset = Math.sin(rad) * radius;
                ctx.moveTo(x - xOffset, y - yOffset);
                ctx.lineTo(x + xOffset, y + yOffset);
                break;

              case "dash":
                ctx.moveTo(x, y);
                ctx.lineTo(x + Math.cos(rad) * (w ? w / 2 : radius), y + Math.sin(rad) * radius);
                break;

              case false:
                ctx.closePath();
                break;
            }
            ctx.fill();
            if (options.borderWidth > 0) ctx.stroke();
        }
        function _isPointInArea(point, area, margin) {
            margin = margin || .5;
            return !area || point && point.x > area.left - margin && point.x < area.right + margin && point.y > area.top - margin && point.y < area.bottom + margin;
        }
        function clipArea(ctx, area) {
            ctx.save();
            ctx.beginPath();
            ctx.rect(area.left, area.top, area.right - area.left, area.bottom - area.top);
            ctx.clip();
        }
        function unclipArea(ctx) {
            ctx.restore();
        }
        function _steppedLineTo(ctx, previous, target, flip, mode) {
            if (!previous) return ctx.lineTo(target.x, target.y);
            if (mode === "middle") {
                const midpoint = (previous.x + target.x) / 2;
                ctx.lineTo(midpoint, previous.y);
                ctx.lineTo(midpoint, target.y);
            } else if (mode === "after" !== !!flip) ctx.lineTo(previous.x, target.y); else ctx.lineTo(target.x, previous.y);
            ctx.lineTo(target.x, target.y);
        }
        function _bezierCurveTo(ctx, previous, target, flip) {
            if (!previous) return ctx.lineTo(target.x, target.y);
            ctx.bezierCurveTo(flip ? previous.cp1x : previous.cp2x, flip ? previous.cp1y : previous.cp2y, flip ? target.cp2x : target.cp1x, flip ? target.cp2y : target.cp1y, target.x, target.y);
        }
        function setRenderOpts(ctx, opts) {
            if (opts.translation) ctx.translate(opts.translation[0], opts.translation[1]);
            if (!isNullOrUndef(opts.rotation)) ctx.rotate(opts.rotation);
            if (opts.color) ctx.fillStyle = opts.color;
            if (opts.textAlign) ctx.textAlign = opts.textAlign;
            if (opts.textBaseline) ctx.textBaseline = opts.textBaseline;
        }
        function decorateText(ctx, x, y, line, opts) {
            if (opts.strikethrough || opts.underline) {
                const metrics = ctx.measureText(line);
                const left = x - metrics.actualBoundingBoxLeft;
                const right = x + metrics.actualBoundingBoxRight;
                const top = y - metrics.actualBoundingBoxAscent;
                const bottom = y + metrics.actualBoundingBoxDescent;
                const yDecoration = opts.strikethrough ? (top + bottom) / 2 : bottom;
                ctx.strokeStyle = ctx.fillStyle;
                ctx.beginPath();
                ctx.lineWidth = opts.decorationWidth || 2;
                ctx.moveTo(left, yDecoration);
                ctx.lineTo(right, yDecoration);
                ctx.stroke();
            }
        }
        function drawBackdrop(ctx, opts) {
            const oldColor = ctx.fillStyle;
            ctx.fillStyle = opts.color;
            ctx.fillRect(opts.left, opts.top, opts.width, opts.height);
            ctx.fillStyle = oldColor;
        }
        function renderText(ctx, text, x, y, font, opts = {}) {
            const lines = isArray(text) ? text : [ text ];
            const stroke = opts.strokeWidth > 0 && opts.strokeColor !== "";
            let i, line;
            ctx.save();
            ctx.font = font.string;
            setRenderOpts(ctx, opts);
            for (i = 0; i < lines.length; ++i) {
                line = lines[i];
                if (opts.backdrop) drawBackdrop(ctx, opts.backdrop);
                if (stroke) {
                    if (opts.strokeColor) ctx.strokeStyle = opts.strokeColor;
                    if (!isNullOrUndef(opts.strokeWidth)) ctx.lineWidth = opts.strokeWidth;
                    ctx.strokeText(line, x, y, opts.maxWidth);
                }
                ctx.fillText(line, x, y, opts.maxWidth);
                decorateText(ctx, x, y, line, opts);
                y += Number(font.lineHeight);
            }
            ctx.restore();
        }
        function addRoundedRectPath(ctx, rect) {
            const {x, y, w, h, radius} = rect;
            ctx.arc(x + radius.topLeft, y + radius.topLeft, radius.topLeft, 1.5 * PI, PI, true);
            ctx.lineTo(x, y + h - radius.bottomLeft);
            ctx.arc(x + radius.bottomLeft, y + h - radius.bottomLeft, radius.bottomLeft, PI, HALF_PI, true);
            ctx.lineTo(x + w - radius.bottomRight, y + h);
            ctx.arc(x + w - radius.bottomRight, y + h - radius.bottomRight, radius.bottomRight, HALF_PI, 0, true);
            ctx.lineTo(x + w, y + radius.topRight);
            ctx.arc(x + w - radius.topRight, y + radius.topRight, radius.topRight, 0, -HALF_PI, true);
            ctx.lineTo(x + radius.topLeft, y);
        }
        const LINE_HEIGHT = /^(normal|(\d+(?:\.\d+)?)(px|em|%)?)$/;
        const FONT_STYLE = /^(normal|italic|initial|inherit|unset|(oblique( -?[0-9]?[0-9]deg)?))$/;
        function toLineHeight(value, size) {
            const matches = ("" + value).match(LINE_HEIGHT);
            if (!matches || matches[1] === "normal") return size * 1.2;
            value = +matches[2];
            switch (matches[3]) {
              case "px":
                return value;

              case "%":
                value /= 100;
                break;
            }
            return size * value;
        }
        const numberOrZero = v => +v || 0;
        function _readValueToProps(value, props) {
            const ret = {};
            const objProps = helpers_segment_isObject(props);
            const keys = objProps ? Object.keys(props) : props;
            const read = helpers_segment_isObject(value) ? objProps ? prop => valueOrDefault(value[prop], value[props[prop]]) : prop => value[prop] : () => value;
            for (const prop of keys) ret[prop] = numberOrZero(read(prop));
            return ret;
        }
        function toTRBL(value) {
            return _readValueToProps(value, {
                top: "y",
                right: "x",
                bottom: "y",
                left: "x"
            });
        }
        function toTRBLCorners(value) {
            return _readValueToProps(value, [ "topLeft", "topRight", "bottomLeft", "bottomRight" ]);
        }
        function toPadding(value) {
            const obj = toTRBL(value);
            obj.width = obj.left + obj.right;
            obj.height = obj.top + obj.bottom;
            return obj;
        }
        function toFont(options, fallback) {
            options = options || {};
            fallback = fallback || defaults.font;
            let size = valueOrDefault(options.size, fallback.size);
            if (typeof size === "string") size = parseInt(size, 10);
            let style = valueOrDefault(options.style, fallback.style);
            if (style && !("" + style).match(FONT_STYLE)) {
                console.warn('Invalid font style specified: "' + style + '"');
                style = void 0;
            }
            const font = {
                family: valueOrDefault(options.family, fallback.family),
                lineHeight: toLineHeight(valueOrDefault(options.lineHeight, fallback.lineHeight), size),
                size,
                style,
                weight: valueOrDefault(options.weight, fallback.weight),
                string: ""
            };
            font.string = toFontString(font);
            return font;
        }
        function resolve(inputs, context, index, info) {
            let cacheable = true;
            let i, ilen, value;
            for (i = 0, ilen = inputs.length; i < ilen; ++i) {
                value = inputs[i];
                if (value === void 0) continue;
                if (context !== void 0 && typeof value === "function") {
                    value = value(context);
                    cacheable = false;
                }
                if (index !== void 0 && isArray(value)) {
                    value = value[index % value.length];
                    cacheable = false;
                }
                if (value !== void 0) {
                    if (info && !cacheable) info.cacheable = false;
                    return value;
                }
            }
        }
        function _addGrace(minmax, grace, beginAtZero) {
            const {min, max} = minmax;
            const change = toDimension(grace, (max - min) / 2);
            const keepZero = (value, add) => beginAtZero && value === 0 ? 0 : value + add;
            return {
                min: keepZero(min, -Math.abs(change)),
                max: keepZero(max, change)
            };
        }
        function createContext(parentContext, context) {
            return Object.assign(Object.create(parentContext), context);
        }
        function _createResolver(scopes, prefixes = [ "" ], rootScopes, fallback, getTarget = () => scopes[0]) {
            const finalRootScopes = rootScopes || scopes;
            if (typeof fallback === "undefined") fallback = _resolve("_fallback", scopes);
            const cache = {
                [Symbol.toStringTag]: "Object",
                _cacheable: true,
                _scopes: scopes,
                _rootScopes: finalRootScopes,
                _fallback: fallback,
                _getTarget: getTarget,
                override: scope => _createResolver([ scope, ...scopes ], prefixes, finalRootScopes, fallback)
            };
            return new Proxy(cache, {
                deleteProperty(target, prop) {
                    delete target[prop];
                    delete target._keys;
                    delete scopes[0][prop];
                    return true;
                },
                get(target, prop) {
                    return _cached(target, prop, (() => _resolveWithPrefixes(prop, prefixes, scopes, target)));
                },
                getOwnPropertyDescriptor(target, prop) {
                    return Reflect.getOwnPropertyDescriptor(target._scopes[0], prop);
                },
                getPrototypeOf() {
                    return Reflect.getPrototypeOf(scopes[0]);
                },
                has(target, prop) {
                    return getKeysFromAllScopes(target).includes(prop);
                },
                ownKeys(target) {
                    return getKeysFromAllScopes(target);
                },
                set(target, prop, value) {
                    const storage = target._storage || (target._storage = getTarget());
                    target[prop] = storage[prop] = value;
                    delete target._keys;
                    return true;
                }
            });
        }
        function _attachContext(proxy, context, subProxy, descriptorDefaults) {
            const cache = {
                _cacheable: false,
                _proxy: proxy,
                _context: context,
                _subProxy: subProxy,
                _stack: new Set,
                _descriptors: _descriptors(proxy, descriptorDefaults),
                setContext: ctx => _attachContext(proxy, ctx, subProxy, descriptorDefaults),
                override: scope => _attachContext(proxy.override(scope), context, subProxy, descriptorDefaults)
            };
            return new Proxy(cache, {
                deleteProperty(target, prop) {
                    delete target[prop];
                    delete proxy[prop];
                    return true;
                },
                get(target, prop, receiver) {
                    return _cached(target, prop, (() => _resolveWithContext(target, prop, receiver)));
                },
                getOwnPropertyDescriptor(target, prop) {
                    return target._descriptors.allKeys ? Reflect.has(proxy, prop) ? {
                        enumerable: true,
                        configurable: true
                    } : void 0 : Reflect.getOwnPropertyDescriptor(proxy, prop);
                },
                getPrototypeOf() {
                    return Reflect.getPrototypeOf(proxy);
                },
                has(target, prop) {
                    return Reflect.has(proxy, prop);
                },
                ownKeys() {
                    return Reflect.ownKeys(proxy);
                },
                set(target, prop, value) {
                    proxy[prop] = value;
                    delete target[prop];
                    return true;
                }
            });
        }
        function _descriptors(proxy, defaults = {
            scriptable: true,
            indexable: true
        }) {
            const {_scriptable = defaults.scriptable, _indexable = defaults.indexable, _allKeys = defaults.allKeys} = proxy;
            return {
                allKeys: _allKeys,
                scriptable: _scriptable,
                indexable: _indexable,
                isScriptable: isFunction(_scriptable) ? _scriptable : () => _scriptable,
                isIndexable: isFunction(_indexable) ? _indexable : () => _indexable
            };
        }
        const readKey = (prefix, name) => prefix ? prefix + _capitalize(name) : name;
        const needsSubResolver = (prop, value) => helpers_segment_isObject(value) && prop !== "adapters" && (Object.getPrototypeOf(value) === null || value.constructor === Object);
        function _cached(target, prop, resolve) {
            if (Object.prototype.hasOwnProperty.call(target, prop) || prop === "constructor") return target[prop];
            const value = resolve();
            target[prop] = value;
            return value;
        }
        function _resolveWithContext(target, prop, receiver) {
            const {_proxy, _context, _subProxy, _descriptors: descriptors} = target;
            let value = _proxy[prop];
            if (isFunction(value) && descriptors.isScriptable(prop)) value = _resolveScriptable(prop, value, target, receiver);
            if (isArray(value) && value.length) value = _resolveArray(prop, value, target, descriptors.isIndexable);
            if (needsSubResolver(prop, value)) value = _attachContext(value, _context, _subProxy && _subProxy[prop], descriptors);
            return value;
        }
        function _resolveScriptable(prop, getValue, target, receiver) {
            const {_proxy, _context, _subProxy, _stack} = target;
            if (_stack.has(prop)) throw new Error("Recursion detected: " + Array.from(_stack).join("->") + "->" + prop);
            _stack.add(prop);
            let value = getValue(_context, _subProxy || receiver);
            _stack.delete(prop);
            if (needsSubResolver(prop, value)) value = createSubResolver(_proxy._scopes, _proxy, prop, value);
            return value;
        }
        function _resolveArray(prop, value, target, isIndexable) {
            const {_proxy, _context, _subProxy, _descriptors: descriptors} = target;
            if (typeof _context.index !== "undefined" && isIndexable(prop)) return value[_context.index % value.length]; else if (helpers_segment_isObject(value[0])) {
                const arr = value;
                const scopes = _proxy._scopes.filter((s => s !== arr));
                value = [];
                for (const item of arr) {
                    const resolver = createSubResolver(scopes, _proxy, prop, item);
                    value.push(_attachContext(resolver, _context, _subProxy && _subProxy[prop], descriptors));
                }
            }
            return value;
        }
        function resolveFallback(fallback, prop, value) {
            return isFunction(fallback) ? fallback(prop, value) : fallback;
        }
        const getScope = (key, parent) => key === true ? parent : typeof key === "string" ? resolveObjectKey(parent, key) : void 0;
        function addScopes(set, parentScopes, key, parentFallback, value) {
            for (const parent of parentScopes) {
                const scope = getScope(key, parent);
                if (scope) {
                    set.add(scope);
                    const fallback = resolveFallback(scope._fallback, key, value);
                    if (typeof fallback !== "undefined" && fallback !== key && fallback !== parentFallback) return fallback;
                } else if (scope === false && typeof parentFallback !== "undefined" && key !== parentFallback) return null;
            }
            return false;
        }
        function createSubResolver(parentScopes, resolver, prop, value) {
            const rootScopes = resolver._rootScopes;
            const fallback = resolveFallback(resolver._fallback, prop, value);
            const allScopes = [ ...parentScopes, ...rootScopes ];
            const set = new Set;
            set.add(value);
            let key = addScopesFromKey(set, allScopes, prop, fallback || prop, value);
            if (key === null) return false;
            if (typeof fallback !== "undefined" && fallback !== prop) {
                key = addScopesFromKey(set, allScopes, fallback, key, value);
                if (key === null) return false;
            }
            return _createResolver(Array.from(set), [ "" ], rootScopes, fallback, (() => subGetTarget(resolver, prop, value)));
        }
        function addScopesFromKey(set, allScopes, key, fallback, item) {
            while (key) key = addScopes(set, allScopes, key, fallback, item);
            return key;
        }
        function subGetTarget(resolver, prop, value) {
            const parent = resolver._getTarget();
            if (!(prop in parent)) parent[prop] = {};
            const target = parent[prop];
            if (isArray(target) && helpers_segment_isObject(value)) return value;
            return target || {};
        }
        function _resolveWithPrefixes(prop, prefixes, scopes, proxy) {
            let value;
            for (const prefix of prefixes) {
                value = _resolve(readKey(prefix, prop), scopes);
                if (typeof value !== "undefined") return needsSubResolver(prop, value) ? createSubResolver(scopes, proxy, prop, value) : value;
            }
        }
        function _resolve(key, scopes) {
            for (const scope of scopes) {
                if (!scope) continue;
                const value = scope[key];
                if (typeof value !== "undefined") return value;
            }
        }
        function getKeysFromAllScopes(target) {
            let keys = target._keys;
            if (!keys) keys = target._keys = resolveKeysFromAllScopes(target._scopes);
            return keys;
        }
        function resolveKeysFromAllScopes(scopes) {
            const set = new Set;
            for (const scope of scopes) for (const key of Object.keys(scope).filter((k => !k.startsWith("_")))) set.add(key);
            return Array.from(set);
        }
        function _parseObjectDataRadialScale(meta, data, start, count) {
            const {iScale} = meta;
            const {key = "r"} = this._parsing;
            const parsed = new Array(count);
            let i, ilen, index, item;
            for (i = 0, ilen = count; i < ilen; ++i) {
                index = i + start;
                item = data[index];
                parsed[i] = {
                    r: iScale.parse(resolveObjectKey(item, key), index)
                };
            }
            return parsed;
        }
        const EPSILON = Number.EPSILON || 1e-14;
        const getPoint = (points, i) => i < points.length && !points[i].skip && points[i];
        const getValueAxis = indexAxis => indexAxis === "x" ? "y" : "x";
        function splineCurve(firstPoint, middlePoint, afterPoint, t) {
            const previous = firstPoint.skip ? middlePoint : firstPoint;
            const current = middlePoint;
            const next = afterPoint.skip ? middlePoint : afterPoint;
            const d01 = distanceBetweenPoints(current, previous);
            const d12 = distanceBetweenPoints(next, current);
            let s01 = d01 / (d01 + d12);
            let s12 = d12 / (d01 + d12);
            s01 = isNaN(s01) ? 0 : s01;
            s12 = isNaN(s12) ? 0 : s12;
            const fa = t * s01;
            const fb = t * s12;
            return {
                previous: {
                    x: current.x - fa * (next.x - previous.x),
                    y: current.y - fa * (next.y - previous.y)
                },
                next: {
                    x: current.x + fb * (next.x - previous.x),
                    y: current.y + fb * (next.y - previous.y)
                }
            };
        }
        function monotoneAdjust(points, deltaK, mK) {
            const pointsLen = points.length;
            let alphaK, betaK, tauK, squaredMagnitude, pointCurrent;
            let pointAfter = getPoint(points, 0);
            for (let i = 0; i < pointsLen - 1; ++i) {
                pointCurrent = pointAfter;
                pointAfter = getPoint(points, i + 1);
                if (!pointCurrent || !pointAfter) continue;
                if (almostEquals(deltaK[i], 0, EPSILON)) {
                    mK[i] = mK[i + 1] = 0;
                    continue;
                }
                alphaK = mK[i] / deltaK[i];
                betaK = mK[i + 1] / deltaK[i];
                squaredMagnitude = Math.pow(alphaK, 2) + Math.pow(betaK, 2);
                if (squaredMagnitude <= 9) continue;
                tauK = 3 / Math.sqrt(squaredMagnitude);
                mK[i] = alphaK * tauK * deltaK[i];
                mK[i + 1] = betaK * tauK * deltaK[i];
            }
        }
        function monotoneCompute(points, mK, indexAxis = "x") {
            const valueAxis = getValueAxis(indexAxis);
            const pointsLen = points.length;
            let delta, pointBefore, pointCurrent;
            let pointAfter = getPoint(points, 0);
            for (let i = 0; i < pointsLen; ++i) {
                pointBefore = pointCurrent;
                pointCurrent = pointAfter;
                pointAfter = getPoint(points, i + 1);
                if (!pointCurrent) continue;
                const iPixel = pointCurrent[indexAxis];
                const vPixel = pointCurrent[valueAxis];
                if (pointBefore) {
                    delta = (iPixel - pointBefore[indexAxis]) / 3;
                    pointCurrent[`cp1${indexAxis}`] = iPixel - delta;
                    pointCurrent[`cp1${valueAxis}`] = vPixel - delta * mK[i];
                }
                if (pointAfter) {
                    delta = (pointAfter[indexAxis] - iPixel) / 3;
                    pointCurrent[`cp2${indexAxis}`] = iPixel + delta;
                    pointCurrent[`cp2${valueAxis}`] = vPixel + delta * mK[i];
                }
            }
        }
        function splineCurveMonotone(points, indexAxis = "x") {
            const valueAxis = getValueAxis(indexAxis);
            const pointsLen = points.length;
            const deltaK = Array(pointsLen).fill(0);
            const mK = Array(pointsLen);
            let i, pointBefore, pointCurrent;
            let pointAfter = getPoint(points, 0);
            for (i = 0; i < pointsLen; ++i) {
                pointBefore = pointCurrent;
                pointCurrent = pointAfter;
                pointAfter = getPoint(points, i + 1);
                if (!pointCurrent) continue;
                if (pointAfter) {
                    const slopeDelta = pointAfter[indexAxis] - pointCurrent[indexAxis];
                    deltaK[i] = slopeDelta !== 0 ? (pointAfter[valueAxis] - pointCurrent[valueAxis]) / slopeDelta : 0;
                }
                mK[i] = !pointBefore ? deltaK[i] : !pointAfter ? deltaK[i - 1] : sign(deltaK[i - 1]) !== sign(deltaK[i]) ? 0 : (deltaK[i - 1] + deltaK[i]) / 2;
            }
            monotoneAdjust(points, deltaK, mK);
            monotoneCompute(points, mK, indexAxis);
        }
        function capControlPoint(pt, min, max) {
            return Math.max(Math.min(pt, max), min);
        }
        function capBezierPoints(points, area) {
            let i, ilen, point, inArea, inAreaPrev;
            let inAreaNext = _isPointInArea(points[0], area);
            for (i = 0, ilen = points.length; i < ilen; ++i) {
                inAreaPrev = inArea;
                inArea = inAreaNext;
                inAreaNext = i < ilen - 1 && _isPointInArea(points[i + 1], area);
                if (!inArea) continue;
                point = points[i];
                if (inAreaPrev) {
                    point.cp1x = capControlPoint(point.cp1x, area.left, area.right);
                    point.cp1y = capControlPoint(point.cp1y, area.top, area.bottom);
                }
                if (inAreaNext) {
                    point.cp2x = capControlPoint(point.cp2x, area.left, area.right);
                    point.cp2y = capControlPoint(point.cp2y, area.top, area.bottom);
                }
            }
        }
        function _updateBezierControlPoints(points, options, area, loop, indexAxis) {
            let i, ilen, point, controlPoints;
            if (options.spanGaps) points = points.filter((pt => !pt.skip));
            if (options.cubicInterpolationMode === "monotone") splineCurveMonotone(points, indexAxis); else {
                let prev = loop ? points[points.length - 1] : points[0];
                for (i = 0, ilen = points.length; i < ilen; ++i) {
                    point = points[i];
                    controlPoints = splineCurve(prev, point, points[Math.min(i + 1, ilen - (loop ? 0 : 1)) % ilen], options.tension);
                    point.cp1x = controlPoints.previous.x;
                    point.cp1y = controlPoints.previous.y;
                    point.cp2x = controlPoints.next.x;
                    point.cp2y = controlPoints.next.y;
                    prev = point;
                }
            }
            if (options.capBezierPoints) capBezierPoints(points, area);
        }
        function _isDomSupported() {
            return typeof window !== "undefined" && typeof document !== "undefined";
        }
        function _getParentNode(domNode) {
            let parent = domNode.parentNode;
            if (parent && parent.toString() === "[object ShadowRoot]") parent = parent.host;
            return parent;
        }
        function parseMaxStyle(styleValue, node, parentProperty) {
            let valueInPixels;
            if (typeof styleValue === "string") {
                valueInPixels = parseInt(styleValue, 10);
                if (styleValue.indexOf("%") !== -1) valueInPixels = valueInPixels / 100 * node.parentNode[parentProperty];
            } else valueInPixels = styleValue;
            return valueInPixels;
        }
        const helpers_segment_getComputedStyle = element => element.ownerDocument.defaultView.getComputedStyle(element, null);
        function getStyle(el, property) {
            return helpers_segment_getComputedStyle(el).getPropertyValue(property);
        }
        const positions = [ "top", "right", "bottom", "left" ];
        function getPositionedStyle(styles, style, suffix) {
            const result = {};
            suffix = suffix ? "-" + suffix : "";
            for (let i = 0; i < 4; i++) {
                const pos = positions[i];
                result[pos] = parseFloat(styles[style + "-" + pos + suffix]) || 0;
            }
            result.width = result.left + result.right;
            result.height = result.top + result.bottom;
            return result;
        }
        const useOffsetPos = (x, y, target) => (x > 0 || y > 0) && (!target || !target.shadowRoot);
        function getCanvasPosition(e, canvas) {
            const touches = e.touches;
            const source = touches && touches.length ? touches[0] : e;
            const {offsetX, offsetY} = source;
            let box = false;
            let x, y;
            if (useOffsetPos(offsetX, offsetY, e.target)) {
                x = offsetX;
                y = offsetY;
            } else {
                const rect = canvas.getBoundingClientRect();
                x = source.clientX - rect.left;
                y = source.clientY - rect.top;
                box = true;
            }
            return {
                x,
                y,
                box
            };
        }
        function getRelativePosition(event, chart) {
            if ("native" in event) return event;
            const {canvas, currentDevicePixelRatio} = chart;
            const style = helpers_segment_getComputedStyle(canvas);
            const borderBox = style.boxSizing === "border-box";
            const paddings = getPositionedStyle(style, "padding");
            const borders = getPositionedStyle(style, "border", "width");
            const {x, y, box} = getCanvasPosition(event, canvas);
            const xOffset = paddings.left + (box && borders.left);
            const yOffset = paddings.top + (box && borders.top);
            let {width, height} = chart;
            if (borderBox) {
                width -= paddings.width + borders.width;
                height -= paddings.height + borders.height;
            }
            return {
                x: Math.round((x - xOffset) / width * canvas.width / currentDevicePixelRatio),
                y: Math.round((y - yOffset) / height * canvas.height / currentDevicePixelRatio)
            };
        }
        function getContainerSize(canvas, width, height) {
            let maxWidth, maxHeight;
            if (width === void 0 || height === void 0) {
                const container = canvas && _getParentNode(canvas);
                if (!container) {
                    width = canvas.clientWidth;
                    height = canvas.clientHeight;
                } else {
                    const rect = container.getBoundingClientRect();
                    const containerStyle = helpers_segment_getComputedStyle(container);
                    const containerBorder = getPositionedStyle(containerStyle, "border", "width");
                    const containerPadding = getPositionedStyle(containerStyle, "padding");
                    width = rect.width - containerPadding.width - containerBorder.width;
                    height = rect.height - containerPadding.height - containerBorder.height;
                    maxWidth = parseMaxStyle(containerStyle.maxWidth, container, "clientWidth");
                    maxHeight = parseMaxStyle(containerStyle.maxHeight, container, "clientHeight");
                }
            }
            return {
                width,
                height,
                maxWidth: maxWidth || INFINITY,
                maxHeight: maxHeight || INFINITY
            };
        }
        const round1 = v => Math.round(v * 10) / 10;
        function getMaximumSize(canvas, bbWidth, bbHeight, aspectRatio) {
            const style = helpers_segment_getComputedStyle(canvas);
            const margins = getPositionedStyle(style, "margin");
            const maxWidth = parseMaxStyle(style.maxWidth, canvas, "clientWidth") || INFINITY;
            const maxHeight = parseMaxStyle(style.maxHeight, canvas, "clientHeight") || INFINITY;
            const containerSize = getContainerSize(canvas, bbWidth, bbHeight);
            let {width, height} = containerSize;
            if (style.boxSizing === "content-box") {
                const borders = getPositionedStyle(style, "border", "width");
                const paddings = getPositionedStyle(style, "padding");
                width -= paddings.width + borders.width;
                height -= paddings.height + borders.height;
            }
            width = Math.max(0, width - margins.width);
            height = Math.max(0, aspectRatio ? width / aspectRatio : height - margins.height);
            width = round1(Math.min(width, maxWidth, containerSize.maxWidth));
            height = round1(Math.min(height, maxHeight, containerSize.maxHeight));
            if (width && !height) height = round1(width / 2);
            const maintainHeight = bbWidth !== void 0 || bbHeight !== void 0;
            if (maintainHeight && aspectRatio && containerSize.height && height > containerSize.height) {
                height = containerSize.height;
                width = round1(Math.floor(height * aspectRatio));
            }
            return {
                width,
                height
            };
        }
        function retinaScale(chart, forceRatio, forceStyle) {
            const pixelRatio = forceRatio || 1;
            const deviceHeight = Math.floor(chart.height * pixelRatio);
            const deviceWidth = Math.floor(chart.width * pixelRatio);
            chart.height = Math.floor(chart.height);
            chart.width = Math.floor(chart.width);
            const canvas = chart.canvas;
            if (canvas.style && (forceStyle || !canvas.style.height && !canvas.style.width)) {
                canvas.style.height = `${chart.height}px`;
                canvas.style.width = `${chart.width}px`;
            }
            if (chart.currentDevicePixelRatio !== pixelRatio || canvas.height !== deviceHeight || canvas.width !== deviceWidth) {
                chart.currentDevicePixelRatio = pixelRatio;
                canvas.height = deviceHeight;
                canvas.width = deviceWidth;
                chart.ctx.setTransform(pixelRatio, 0, 0, pixelRatio, 0, 0);
                return true;
            }
            return false;
        }
        const supportsEventListenerOptions = function() {
            let passiveSupported = false;
            try {
                const options = {
                    get passive() {
                        passiveSupported = true;
                        return false;
                    }
                };
                if (_isDomSupported()) {
                    window.addEventListener("test", null, options);
                    window.removeEventListener("test", null, options);
                }
            } catch (e) {}
            return passiveSupported;
        }();
        function readUsedSize(element, property) {
            const value = getStyle(element, property);
            const matches = value && value.match(/^(\d+)(\.\d+)?px$/);
            return matches ? +matches[1] : void 0;
        }
        function _pointInLine(p1, p2, t, mode) {
            return {
                x: p1.x + t * (p2.x - p1.x),
                y: p1.y + t * (p2.y - p1.y)
            };
        }
        function _steppedInterpolation(p1, p2, t, mode) {
            return {
                x: p1.x + t * (p2.x - p1.x),
                y: mode === "middle" ? t < .5 ? p1.y : p2.y : mode === "after" ? t < 1 ? p1.y : p2.y : t > 0 ? p2.y : p1.y
            };
        }
        function _bezierInterpolation(p1, p2, t, mode) {
            const cp1 = {
                x: p1.cp2x,
                y: p1.cp2y
            };
            const cp2 = {
                x: p2.cp1x,
                y: p2.cp1y
            };
            const a = _pointInLine(p1, cp1, t);
            const b = _pointInLine(cp1, cp2, t);
            const c = _pointInLine(cp2, p2, t);
            const d = _pointInLine(a, b, t);
            const e = _pointInLine(b, c, t);
            return _pointInLine(d, e, t);
        }
        const getRightToLeftAdapter = function(rectX, width) {
            return {
                x(x) {
                    return rectX + rectX + width - x;
                },
                setWidth(w) {
                    width = w;
                },
                textAlign(align) {
                    if (align === "center") return align;
                    return align === "right" ? "left" : "right";
                },
                xPlus(x, value) {
                    return x - value;
                },
                leftForLtr(x, itemWidth) {
                    return x - itemWidth;
                }
            };
        };
        const getLeftToRightAdapter = function() {
            return {
                x(x) {
                    return x;
                },
                setWidth(w) {},
                textAlign(align) {
                    return align;
                },
                xPlus(x, value) {
                    return x + value;
                },
                leftForLtr(x, _itemWidth) {
                    return x;
                }
            };
        };
        function getRtlAdapter(rtl, rectX, width) {
            return rtl ? getRightToLeftAdapter(rectX, width) : getLeftToRightAdapter();
        }
        function overrideTextDirection(ctx, direction) {
            let style, original;
            if (direction === "ltr" || direction === "rtl") {
                style = ctx.canvas.style;
                original = [ style.getPropertyValue("direction"), style.getPropertyPriority("direction") ];
                style.setProperty("direction", direction, "important");
                ctx.prevTextDirection = original;
            }
        }
        function restoreTextDirection(ctx, original) {
            if (original !== void 0) {
                delete ctx.prevTextDirection;
                ctx.canvas.style.setProperty("direction", original[0], original[1]);
            }
        }
        function propertyFn(property) {
            if (property === "angle") return {
                between: _angleBetween,
                compare: _angleDiff,
                normalize: _normalizeAngle
            };
            return {
                between: _isBetween,
                compare: (a, b) => a - b,
                normalize: x => x
            };
        }
        function normalizeSegment({start, end, count, loop, style}) {
            return {
                start: start % count,
                end: end % count,
                loop: loop && (end - start + 1) % count === 0,
                style
            };
        }
        function getSegment(segment, points, bounds) {
            const {property, start: startBound, end: endBound} = bounds;
            const {between, normalize} = propertyFn(property);
            const count = points.length;
            let {start, end, loop} = segment;
            let i, ilen;
            if (loop) {
                start += count;
                end += count;
                for (i = 0, ilen = count; i < ilen; ++i) {
                    if (!between(normalize(points[start % count][property]), startBound, endBound)) break;
                    start--;
                    end--;
                }
                start %= count;
                end %= count;
            }
            if (end < start) end += count;
            return {
                start,
                end,
                loop,
                style: segment.style
            };
        }
        function _boundSegment(segment, points, bounds) {
            if (!bounds) return [ segment ];
            const {property, start: startBound, end: endBound} = bounds;
            const count = points.length;
            const {compare, between, normalize} = propertyFn(property);
            const {start, end, loop, style} = getSegment(segment, points, bounds);
            const result = [];
            let inside = false;
            let subStart = null;
            let value, point, prevValue;
            const startIsBefore = () => between(startBound, prevValue, value) && compare(startBound, prevValue) !== 0;
            const endIsBefore = () => compare(endBound, value) === 0 || between(endBound, prevValue, value);
            const shouldStart = () => inside || startIsBefore();
            const shouldStop = () => !inside || endIsBefore();
            for (let i = start, prev = start; i <= end; ++i) {
                point = points[i % count];
                if (point.skip) continue;
                value = normalize(point[property]);
                if (value === prevValue) continue;
                inside = between(value, startBound, endBound);
                if (subStart === null && shouldStart()) subStart = compare(value, startBound) === 0 ? i : prev;
                if (subStart !== null && shouldStop()) {
                    result.push(normalizeSegment({
                        start: subStart,
                        end: i,
                        loop,
                        count,
                        style
                    }));
                    subStart = null;
                }
                prev = i;
                prevValue = value;
            }
            if (subStart !== null) result.push(normalizeSegment({
                start: subStart,
                end,
                loop,
                count,
                style
            }));
            return result;
        }
        function _boundSegments(line, bounds) {
            const result = [];
            const segments = line.segments;
            for (let i = 0; i < segments.length; i++) {
                const sub = _boundSegment(segments[i], line.points, bounds);
                if (sub.length) result.push(...sub);
            }
            return result;
        }
        function findStartAndEnd(points, count, loop, spanGaps) {
            let start = 0;
            let end = count - 1;
            if (loop && !spanGaps) while (start < count && !points[start].skip) start++;
            while (start < count && points[start].skip) start++;
            start %= count;
            if (loop) end += start;
            while (end > start && points[end % count].skip) end--;
            end %= count;
            return {
                start,
                end
            };
        }
        function solidSegments(points, start, max, loop) {
            const count = points.length;
            const result = [];
            let last = start;
            let prev = points[start];
            let end;
            for (end = start + 1; end <= max; ++end) {
                const cur = points[end % count];
                if (cur.skip || cur.stop) {
                    if (!prev.skip) {
                        loop = false;
                        result.push({
                            start: start % count,
                            end: (end - 1) % count,
                            loop
                        });
                        start = last = cur.stop ? end : null;
                    }
                } else {
                    last = end;
                    if (prev.skip) start = end;
                }
                prev = cur;
            }
            if (last !== null) result.push({
                start: start % count,
                end: last % count,
                loop
            });
            return result;
        }
        function _computeSegments(line, segmentOptions) {
            const points = line.points;
            const spanGaps = line.options.spanGaps;
            const count = points.length;
            if (!count) return [];
            const loop = !!line._loop;
            const {start, end} = findStartAndEnd(points, count, loop, spanGaps);
            if (spanGaps === true) return splitByStyles(line, [ {
                start,
                end,
                loop
            } ], points, segmentOptions);
            const max = end < start ? end + count : end;
            const completeLoop = !!line._fullLoop && start === 0 && end === count - 1;
            return splitByStyles(line, solidSegments(points, start, max, completeLoop), points, segmentOptions);
        }
        function splitByStyles(line, segments, points, segmentOptions) {
            if (!segmentOptions || !segmentOptions.setContext || !points) return segments;
            return doSplitByStyles(line, segments, points, segmentOptions);
        }
        function doSplitByStyles(line, segments, points, segmentOptions) {
            const chartContext = line._chart.getContext();
            const baseStyle = readStyle(line.options);
            const {_datasetIndex: datasetIndex, options: {spanGaps}} = line;
            const count = points.length;
            const result = [];
            let prevStyle = baseStyle;
            let start = segments[0].start;
            let i = start;
            function addStyle(s, e, l, st) {
                const dir = spanGaps ? -1 : 1;
                if (s === e) return;
                s += count;
                while (points[s % count].skip) s -= dir;
                while (points[e % count].skip) e += dir;
                if (s % count !== e % count) {
                    result.push({
                        start: s % count,
                        end: e % count,
                        loop: l,
                        style: st
                    });
                    prevStyle = st;
                    start = e % count;
                }
            }
            for (const segment of segments) {
                start = spanGaps ? start : segment.start;
                let prev = points[start % count];
                let style;
                for (i = start + 1; i <= segment.end; i++) {
                    const pt = points[i % count];
                    style = readStyle(segmentOptions.setContext(createContext(chartContext, {
                        type: "segment",
                        p0: prev,
                        p1: pt,
                        p0DataIndex: (i - 1) % count,
                        p1DataIndex: i % count,
                        datasetIndex
                    })));
                    if (styleChanged(style, prevStyle)) addStyle(start, i - 1, segment.loop, prevStyle);
                    prev = pt;
                    prevStyle = style;
                }
                if (start < i - 1) addStyle(start, i - 1, segment.loop, prevStyle);
            }
            return result;
        }
        function readStyle(options) {
            return {
                backgroundColor: options.backgroundColor,
                borderCapStyle: options.borderCapStyle,
                borderDash: options.borderDash,
                borderDashOffset: options.borderDashOffset,
                borderJoinStyle: options.borderJoinStyle,
                borderWidth: options.borderWidth,
                borderColor: options.borderColor
            };
        }
        function styleChanged(style, prevStyle) {
            if (!prevStyle) return false;
            const cache = [];
            const replacer = function(key, value) {
                if (!isPatternOrGradient(value)) return value;
                if (!cache.includes(value)) cache.push(value);
                return cache.indexOf(value);
            };
            return JSON.stringify(style, replacer) !== JSON.stringify(prevStyle, replacer);
        }
        /*!
 * Chart.js v4.4.7
 * https://www.chartjs.org
 * (c) 2024 Chart.js Contributors
 * Released under the MIT License
 */
        class Animator {
            constructor() {
                this._request = null;
                this._charts = new Map;
                this._running = false;
                this._lastDate = void 0;
            }
            _notify(chart, anims, date, type) {
                const callbacks = anims.listeners[type];
                const numSteps = anims.duration;
                callbacks.forEach((fn => fn({
                    chart,
                    initial: anims.initial,
                    numSteps,
                    currentStep: Math.min(date - anims.start, numSteps)
                })));
            }
            _refresh() {
                if (this._request) return;
                this._running = true;
                this._request = requestAnimFrame.call(window, (() => {
                    this._update();
                    this._request = null;
                    if (this._running) this._refresh();
                }));
            }
            _update(date = Date.now()) {
                let remaining = 0;
                this._charts.forEach(((anims, chart) => {
                    if (!anims.running || !anims.items.length) return;
                    const items = anims.items;
                    let i = items.length - 1;
                    let draw = false;
                    let item;
                    for (;i >= 0; --i) {
                        item = items[i];
                        if (item._active) {
                            if (item._total > anims.duration) anims.duration = item._total;
                            item.tick(date);
                            draw = true;
                        } else {
                            items[i] = items[items.length - 1];
                            items.pop();
                        }
                    }
                    if (draw) {
                        chart.draw();
                        this._notify(chart, anims, date, "progress");
                    }
                    if (!items.length) {
                        anims.running = false;
                        this._notify(chart, anims, date, "complete");
                        anims.initial = false;
                    }
                    remaining += items.length;
                }));
                this._lastDate = date;
                if (remaining === 0) this._running = false;
            }
            _getAnims(chart) {
                const charts = this._charts;
                let anims = charts.get(chart);
                if (!anims) {
                    anims = {
                        running: false,
                        initial: true,
                        items: [],
                        listeners: {
                            complete: [],
                            progress: []
                        }
                    };
                    charts.set(chart, anims);
                }
                return anims;
            }
            listen(chart, event, cb) {
                this._getAnims(chart).listeners[event].push(cb);
            }
            add(chart, items) {
                if (!items || !items.length) return;
                this._getAnims(chart).items.push(...items);
            }
            has(chart) {
                return this._getAnims(chart).items.length > 0;
            }
            start(chart) {
                const anims = this._charts.get(chart);
                if (!anims) return;
                anims.running = true;
                anims.start = Date.now();
                anims.duration = anims.items.reduce(((acc, cur) => Math.max(acc, cur._duration)), 0);
                this._refresh();
            }
            running(chart) {
                if (!this._running) return false;
                const anims = this._charts.get(chart);
                if (!anims || !anims.running || !anims.items.length) return false;
                return true;
            }
            stop(chart) {
                const anims = this._charts.get(chart);
                if (!anims || !anims.items.length) return;
                const items = anims.items;
                let i = items.length - 1;
                for (;i >= 0; --i) items[i].cancel();
                anims.items = [];
                this._notify(chart, anims, Date.now(), "complete");
            }
            remove(chart) {
                return this._charts.delete(chart);
            }
        }
        var animator = new Animator;
        const transparent = "transparent";
        const interpolators = {
            boolean(from, to, factor) {
                return factor > .5 ? to : from;
            },
            color(from, to, factor) {
                const c0 = color(from || transparent);
                const c1 = c0.valid && color(to || transparent);
                return c1 && c1.valid ? c1.mix(c0, factor).hexString() : to;
            },
            number(from, to, factor) {
                return from + (to - from) * factor;
            }
        };
        class Animation {
            constructor(cfg, target, prop, to) {
                const currentValue = target[prop];
                to = resolve([ cfg.to, to, currentValue, cfg.from ]);
                const from = resolve([ cfg.from, currentValue, to ]);
                this._active = true;
                this._fn = cfg.fn || interpolators[cfg.type || typeof from];
                this._easing = effects[cfg.easing] || effects.linear;
                this._start = Math.floor(Date.now() + (cfg.delay || 0));
                this._duration = this._total = Math.floor(cfg.duration);
                this._loop = !!cfg.loop;
                this._target = target;
                this._prop = prop;
                this._from = from;
                this._to = to;
                this._promises = void 0;
            }
            active() {
                return this._active;
            }
            update(cfg, to, date) {
                if (this._active) {
                    this._notify(false);
                    const currentValue = this._target[this._prop];
                    const elapsed = date - this._start;
                    const remain = this._duration - elapsed;
                    this._start = date;
                    this._duration = Math.floor(Math.max(remain, cfg.duration));
                    this._total += elapsed;
                    this._loop = !!cfg.loop;
                    this._to = resolve([ cfg.to, to, currentValue, cfg.from ]);
                    this._from = resolve([ cfg.from, currentValue, to ]);
                }
            }
            cancel() {
                if (this._active) {
                    this.tick(Date.now());
                    this._active = false;
                    this._notify(false);
                }
            }
            tick(date) {
                const elapsed = date - this._start;
                const duration = this._duration;
                const prop = this._prop;
                const from = this._from;
                const loop = this._loop;
                const to = this._to;
                let factor;
                this._active = from !== to && (loop || elapsed < duration);
                if (!this._active) {
                    this._target[prop] = to;
                    this._notify(true);
                    return;
                }
                if (elapsed < 0) {
                    this._target[prop] = from;
                    return;
                }
                factor = elapsed / duration % 2;
                factor = loop && factor > 1 ? 2 - factor : factor;
                factor = this._easing(Math.min(1, Math.max(0, factor)));
                this._target[prop] = this._fn(from, to, factor);
            }
            wait() {
                const promises = this._promises || (this._promises = []);
                return new Promise(((res, rej) => {
                    promises.push({
                        res,
                        rej
                    });
                }));
            }
            _notify(resolved) {
                const method = resolved ? "res" : "rej";
                const promises = this._promises || [];
                for (let i = 0; i < promises.length; i++) promises[i][method]();
            }
        }
        class Animations {
            constructor(chart, config) {
                this._chart = chart;
                this._properties = new Map;
                this.configure(config);
            }
            configure(config) {
                if (!helpers_segment_isObject(config)) return;
                const animationOptions = Object.keys(defaults.animation);
                const animatedProps = this._properties;
                Object.getOwnPropertyNames(config).forEach((key => {
                    const cfg = config[key];
                    if (!helpers_segment_isObject(cfg)) return;
                    const resolved = {};
                    for (const option of animationOptions) resolved[option] = cfg[option];
                    (isArray(cfg.properties) && cfg.properties || [ key ]).forEach((prop => {
                        if (prop === key || !animatedProps.has(prop)) animatedProps.set(prop, resolved);
                    }));
                }));
            }
            _animateOptions(target, values) {
                const newOptions = values.options;
                const options = resolveTargetOptions(target, newOptions);
                if (!options) return [];
                const animations = this._createAnimations(options, newOptions);
                if (newOptions.$shared) awaitAll(target.options.$animations, newOptions).then((() => {
                    target.options = newOptions;
                }), (() => {}));
                return animations;
            }
            _createAnimations(target, values) {
                const animatedProps = this._properties;
                const animations = [];
                const running = target.$animations || (target.$animations = {});
                const props = Object.keys(values);
                const date = Date.now();
                let i;
                for (i = props.length - 1; i >= 0; --i) {
                    const prop = props[i];
                    if (prop.charAt(0) === "$") continue;
                    if (prop === "options") {
                        animations.push(...this._animateOptions(target, values));
                        continue;
                    }
                    const value = values[prop];
                    let animation = running[prop];
                    const cfg = animatedProps.get(prop);
                    if (animation) if (cfg && animation.active()) {
                        animation.update(cfg, value, date);
                        continue;
                    } else animation.cancel();
                    if (!cfg || !cfg.duration) {
                        target[prop] = value;
                        continue;
                    }
                    running[prop] = animation = new Animation(cfg, target, prop, value);
                    animations.push(animation);
                }
                return animations;
            }
            update(target, values) {
                if (this._properties.size === 0) {
                    Object.assign(target, values);
                    return;
                }
                const animations = this._createAnimations(target, values);
                if (animations.length) {
                    animator.add(this._chart, animations);
                    return true;
                }
            }
        }
        function awaitAll(animations, properties) {
            const running = [];
            const keys = Object.keys(properties);
            for (let i = 0; i < keys.length; i++) {
                const anim = animations[keys[i]];
                if (anim && anim.active()) running.push(anim.wait());
            }
            return Promise.all(running);
        }
        function resolveTargetOptions(target, newOptions) {
            if (!newOptions) return;
            let options = target.options;
            if (!options) {
                target.options = newOptions;
                return;
            }
            if (options.$shared) target.options = options = Object.assign({}, options, {
                $shared: false,
                $animations: {}
            });
            return options;
        }
        function scaleClip(scale, allowedOverflow) {
            const opts = scale && scale.options || {};
            const reverse = opts.reverse;
            const min = opts.min === void 0 ? allowedOverflow : 0;
            const max = opts.max === void 0 ? allowedOverflow : 0;
            return {
                start: reverse ? max : min,
                end: reverse ? min : max
            };
        }
        function defaultClip(xScale, yScale, allowedOverflow) {
            if (allowedOverflow === false) return false;
            const x = scaleClip(xScale, allowedOverflow);
            const y = scaleClip(yScale, allowedOverflow);
            return {
                top: y.end,
                right: x.end,
                bottom: y.start,
                left: x.start
            };
        }
        function toClip(value) {
            let t, r, b, l;
            if (helpers_segment_isObject(value)) {
                t = value.top;
                r = value.right;
                b = value.bottom;
                l = value.left;
            } else t = r = b = l = value;
            return {
                top: t,
                right: r,
                bottom: b,
                left: l,
                disabled: value === false
            };
        }
        function getSortedDatasetIndices(chart, filterVisible) {
            const keys = [];
            const metasets = chart._getSortedDatasetMetas(filterVisible);
            let i, ilen;
            for (i = 0, ilen = metasets.length; i < ilen; ++i) keys.push(metasets[i].index);
            return keys;
        }
        function applyStack(stack, value, dsIndex, options = {}) {
            const keys = stack.keys;
            const singleMode = options.mode === "single";
            let i, ilen, datasetIndex, otherValue;
            if (value === null) return;
            let found = false;
            for (i = 0, ilen = keys.length; i < ilen; ++i) {
                datasetIndex = +keys[i];
                if (datasetIndex === dsIndex) {
                    found = true;
                    if (options.all) continue;
                    break;
                }
                otherValue = stack.values[datasetIndex];
                if (isNumberFinite(otherValue) && (singleMode || value === 0 || sign(value) === sign(otherValue))) value += otherValue;
            }
            if (!found && !options.all) return 0;
            return value;
        }
        function convertObjectDataToArray(data, meta) {
            const {iScale, vScale} = meta;
            const iAxisKey = iScale.axis === "x" ? "x" : "y";
            const vAxisKey = vScale.axis === "x" ? "x" : "y";
            const keys = Object.keys(data);
            const adata = new Array(keys.length);
            let i, ilen, key;
            for (i = 0, ilen = keys.length; i < ilen; ++i) {
                key = keys[i];
                adata[i] = {
                    [iAxisKey]: key,
                    [vAxisKey]: data[key]
                };
            }
            return adata;
        }
        function isStacked(scale, meta) {
            const stacked = scale && scale.options.stacked;
            return stacked || stacked === void 0 && meta.stack !== void 0;
        }
        function getStackKey(indexScale, valueScale, meta) {
            return `${indexScale.id}.${valueScale.id}.${meta.stack || meta.type}`;
        }
        function getUserBounds(scale) {
            const {min, max, minDefined, maxDefined} = scale.getUserBounds();
            return {
                min: minDefined ? min : Number.NEGATIVE_INFINITY,
                max: maxDefined ? max : Number.POSITIVE_INFINITY
            };
        }
        function getOrCreateStack(stacks, stackKey, indexValue) {
            const subStack = stacks[stackKey] || (stacks[stackKey] = {});
            return subStack[indexValue] || (subStack[indexValue] = {});
        }
        function getLastIndexInStack(stack, vScale, positive, type) {
            for (const meta of vScale.getMatchingVisibleMetas(type).reverse()) {
                const value = stack[meta.index];
                if (positive && value > 0 || !positive && value < 0) return meta.index;
            }
            return null;
        }
        function updateStacks(controller, parsed) {
            const {chart, _cachedMeta: meta} = controller;
            const stacks = chart._stacks || (chart._stacks = {});
            const {iScale, vScale, index: datasetIndex} = meta;
            const iAxis = iScale.axis;
            const vAxis = vScale.axis;
            const key = getStackKey(iScale, vScale, meta);
            const ilen = parsed.length;
            let stack;
            for (let i = 0; i < ilen; ++i) {
                const item = parsed[i];
                const {[iAxis]: index, [vAxis]: value} = item;
                const itemStacks = item._stacks || (item._stacks = {});
                stack = itemStacks[vAxis] = getOrCreateStack(stacks, key, index);
                stack[datasetIndex] = value;
                stack._top = getLastIndexInStack(stack, vScale, true, meta.type);
                stack._bottom = getLastIndexInStack(stack, vScale, false, meta.type);
                const visualValues = stack._visualValues || (stack._visualValues = {});
                visualValues[datasetIndex] = value;
            }
        }
        function getFirstScaleId(chart, axis) {
            const scales = chart.scales;
            return Object.keys(scales).filter((key => scales[key].axis === axis)).shift();
        }
        function createDatasetContext(parent, index) {
            return createContext(parent, {
                active: false,
                dataset: void 0,
                datasetIndex: index,
                index,
                mode: "default",
                type: "dataset"
            });
        }
        function createDataContext(parent, index, element) {
            return createContext(parent, {
                active: false,
                dataIndex: index,
                parsed: void 0,
                raw: void 0,
                element,
                index,
                mode: "default",
                type: "data"
            });
        }
        function clearStacks(meta, items) {
            const datasetIndex = meta.controller.index;
            const axis = meta.vScale && meta.vScale.axis;
            if (!axis) return;
            items = items || meta._parsed;
            for (const parsed of items) {
                const stacks = parsed._stacks;
                if (!stacks || stacks[axis] === void 0 || stacks[axis][datasetIndex] === void 0) return;
                delete stacks[axis][datasetIndex];
                if (stacks[axis]._visualValues !== void 0 && stacks[axis]._visualValues[datasetIndex] !== void 0) delete stacks[axis]._visualValues[datasetIndex];
            }
        }
        const isDirectUpdateMode = mode => mode === "reset" || mode === "none";
        const cloneIfNotShared = (cached, shared) => shared ? cached : Object.assign({}, cached);
        const createStack = (canStack, meta, chart) => canStack && !meta.hidden && meta._stacked && {
            keys: getSortedDatasetIndices(chart, true),
            values: null
        };
        class DatasetController {
            static defaults={};
            static datasetElementType=null;
            static dataElementType=null;
            constructor(chart, datasetIndex) {
                this.chart = chart;
                this._ctx = chart.ctx;
                this.index = datasetIndex;
                this._cachedDataOpts = {};
                this._cachedMeta = this.getMeta();
                this._type = this._cachedMeta.type;
                this.options = void 0;
                this._parsing = false;
                this._data = void 0;
                this._objectData = void 0;
                this._sharedOptions = void 0;
                this._drawStart = void 0;
                this._drawCount = void 0;
                this.enableOptionSharing = false;
                this.supportsDecimation = false;
                this.$context = void 0;
                this._syncList = [];
                this.datasetElementType = new.target.datasetElementType;
                this.dataElementType = new.target.dataElementType;
                this.initialize();
            }
            initialize() {
                const meta = this._cachedMeta;
                this.configure();
                this.linkScales();
                meta._stacked = isStacked(meta.vScale, meta);
                this.addElements();
                if (this.options.fill && !this.chart.isPluginEnabled("filler")) console.warn("Tried to use the 'fill' option without the 'Filler' plugin enabled. Please import and register the 'Filler' plugin and make sure it is not disabled in the options");
            }
            updateIndex(datasetIndex) {
                if (this.index !== datasetIndex) clearStacks(this._cachedMeta);
                this.index = datasetIndex;
            }
            linkScales() {
                const chart = this.chart;
                const meta = this._cachedMeta;
                const dataset = this.getDataset();
                const chooseId = (axis, x, y, r) => axis === "x" ? x : axis === "r" ? r : y;
                const xid = meta.xAxisID = valueOrDefault(dataset.xAxisID, getFirstScaleId(chart, "x"));
                const yid = meta.yAxisID = valueOrDefault(dataset.yAxisID, getFirstScaleId(chart, "y"));
                const rid = meta.rAxisID = valueOrDefault(dataset.rAxisID, getFirstScaleId(chart, "r"));
                const indexAxis = meta.indexAxis;
                const iid = meta.iAxisID = chooseId(indexAxis, xid, yid, rid);
                const vid = meta.vAxisID = chooseId(indexAxis, yid, xid, rid);
                meta.xScale = this.getScaleForId(xid);
                meta.yScale = this.getScaleForId(yid);
                meta.rScale = this.getScaleForId(rid);
                meta.iScale = this.getScaleForId(iid);
                meta.vScale = this.getScaleForId(vid);
            }
            getDataset() {
                return this.chart.data.datasets[this.index];
            }
            getMeta() {
                return this.chart.getDatasetMeta(this.index);
            }
            getScaleForId(scaleID) {
                return this.chart.scales[scaleID];
            }
            _getOtherScale(scale) {
                const meta = this._cachedMeta;
                return scale === meta.iScale ? meta.vScale : meta.iScale;
            }
            reset() {
                this._update("reset");
            }
            _destroy() {
                const meta = this._cachedMeta;
                if (this._data) unlistenArrayEvents(this._data, this);
                if (meta._stacked) clearStacks(meta);
            }
            _dataCheck() {
                const dataset = this.getDataset();
                const data = dataset.data || (dataset.data = []);
                const _data = this._data;
                if (helpers_segment_isObject(data)) {
                    const meta = this._cachedMeta;
                    this._data = convertObjectDataToArray(data, meta);
                } else if (_data !== data) {
                    if (_data) {
                        unlistenArrayEvents(_data, this);
                        const meta = this._cachedMeta;
                        clearStacks(meta);
                        meta._parsed = [];
                    }
                    if (data && Object.isExtensible(data)) listenArrayEvents(data, this);
                    this._syncList = [];
                    this._data = data;
                }
            }
            addElements() {
                const meta = this._cachedMeta;
                this._dataCheck();
                if (this.datasetElementType) meta.dataset = new this.datasetElementType;
            }
            buildOrUpdateElements(resetNewElements) {
                const meta = this._cachedMeta;
                const dataset = this.getDataset();
                let stackChanged = false;
                this._dataCheck();
                const oldStacked = meta._stacked;
                meta._stacked = isStacked(meta.vScale, meta);
                if (meta.stack !== dataset.stack) {
                    stackChanged = true;
                    clearStacks(meta);
                    meta.stack = dataset.stack;
                }
                this._resyncElements(resetNewElements);
                if (stackChanged || oldStacked !== meta._stacked) {
                    updateStacks(this, meta._parsed);
                    meta._stacked = isStacked(meta.vScale, meta);
                }
            }
            configure() {
                const config = this.chart.config;
                const scopeKeys = config.datasetScopeKeys(this._type);
                const scopes = config.getOptionScopes(this.getDataset(), scopeKeys, true);
                this.options = config.createResolver(scopes, this.getContext());
                this._parsing = this.options.parsing;
                this._cachedDataOpts = {};
            }
            parse(start, count) {
                const {_cachedMeta: meta, _data: data} = this;
                const {iScale, _stacked} = meta;
                const iAxis = iScale.axis;
                let sorted = start === 0 && count === data.length ? true : meta._sorted;
                let prev = start > 0 && meta._parsed[start - 1];
                let i, cur, parsed;
                if (this._parsing === false) {
                    meta._parsed = data;
                    meta._sorted = true;
                    parsed = data;
                } else {
                    if (isArray(data[start])) parsed = this.parseArrayData(meta, data, start, count); else if (helpers_segment_isObject(data[start])) parsed = this.parseObjectData(meta, data, start, count); else parsed = this.parsePrimitiveData(meta, data, start, count);
                    const isNotInOrderComparedToPrev = () => cur[iAxis] === null || prev && cur[iAxis] < prev[iAxis];
                    for (i = 0; i < count; ++i) {
                        meta._parsed[i + start] = cur = parsed[i];
                        if (sorted) {
                            if (isNotInOrderComparedToPrev()) sorted = false;
                            prev = cur;
                        }
                    }
                    meta._sorted = sorted;
                }
                if (_stacked) updateStacks(this, parsed);
            }
            parsePrimitiveData(meta, data, start, count) {
                const {iScale, vScale} = meta;
                const iAxis = iScale.axis;
                const vAxis = vScale.axis;
                const labels = iScale.getLabels();
                const singleScale = iScale === vScale;
                const parsed = new Array(count);
                let i, ilen, index;
                for (i = 0, ilen = count; i < ilen; ++i) {
                    index = i + start;
                    parsed[i] = {
                        [iAxis]: singleScale || iScale.parse(labels[index], index),
                        [vAxis]: vScale.parse(data[index], index)
                    };
                }
                return parsed;
            }
            parseArrayData(meta, data, start, count) {
                const {xScale, yScale} = meta;
                const parsed = new Array(count);
                let i, ilen, index, item;
                for (i = 0, ilen = count; i < ilen; ++i) {
                    index = i + start;
                    item = data[index];
                    parsed[i] = {
                        x: xScale.parse(item[0], index),
                        y: yScale.parse(item[1], index)
                    };
                }
                return parsed;
            }
            parseObjectData(meta, data, start, count) {
                const {xScale, yScale} = meta;
                const {xAxisKey = "x", yAxisKey = "y"} = this._parsing;
                const parsed = new Array(count);
                let i, ilen, index, item;
                for (i = 0, ilen = count; i < ilen; ++i) {
                    index = i + start;
                    item = data[index];
                    parsed[i] = {
                        x: xScale.parse(resolveObjectKey(item, xAxisKey), index),
                        y: yScale.parse(resolveObjectKey(item, yAxisKey), index)
                    };
                }
                return parsed;
            }
            getParsed(index) {
                return this._cachedMeta._parsed[index];
            }
            getDataElement(index) {
                return this._cachedMeta.data[index];
            }
            applyStack(scale, parsed, mode) {
                const chart = this.chart;
                const meta = this._cachedMeta;
                const value = parsed[scale.axis];
                const stack = {
                    keys: getSortedDatasetIndices(chart, true),
                    values: parsed._stacks[scale.axis]._visualValues
                };
                return applyStack(stack, value, meta.index, {
                    mode
                });
            }
            updateRangeFromParsed(range, scale, parsed, stack) {
                const parsedValue = parsed[scale.axis];
                let value = parsedValue === null ? NaN : parsedValue;
                const values = stack && parsed._stacks[scale.axis];
                if (stack && values) {
                    stack.values = values;
                    value = applyStack(stack, parsedValue, this._cachedMeta.index);
                }
                range.min = Math.min(range.min, value);
                range.max = Math.max(range.max, value);
            }
            getMinMax(scale, canStack) {
                const meta = this._cachedMeta;
                const _parsed = meta._parsed;
                const sorted = meta._sorted && scale === meta.iScale;
                const ilen = _parsed.length;
                const otherScale = this._getOtherScale(scale);
                const stack = createStack(canStack, meta, this.chart);
                const range = {
                    min: Number.POSITIVE_INFINITY,
                    max: Number.NEGATIVE_INFINITY
                };
                const {min: otherMin, max: otherMax} = getUserBounds(otherScale);
                let i, parsed;
                function _skip() {
                    parsed = _parsed[i];
                    const otherValue = parsed[otherScale.axis];
                    return !isNumberFinite(parsed[scale.axis]) || otherMin > otherValue || otherMax < otherValue;
                }
                for (i = 0; i < ilen; ++i) {
                    if (_skip()) continue;
                    this.updateRangeFromParsed(range, scale, parsed, stack);
                    if (sorted) break;
                }
                if (sorted) for (i = ilen - 1; i >= 0; --i) {
                    if (_skip()) continue;
                    this.updateRangeFromParsed(range, scale, parsed, stack);
                    break;
                }
                return range;
            }
            getAllParsedValues(scale) {
                const parsed = this._cachedMeta._parsed;
                const values = [];
                let i, ilen, value;
                for (i = 0, ilen = parsed.length; i < ilen; ++i) {
                    value = parsed[i][scale.axis];
                    if (isNumberFinite(value)) values.push(value);
                }
                return values;
            }
            getMaxOverflow() {
                return false;
            }
            getLabelAndValue(index) {
                const meta = this._cachedMeta;
                const iScale = meta.iScale;
                const vScale = meta.vScale;
                const parsed = this.getParsed(index);
                return {
                    label: iScale ? "" + iScale.getLabelForValue(parsed[iScale.axis]) : "",
                    value: vScale ? "" + vScale.getLabelForValue(parsed[vScale.axis]) : ""
                };
            }
            _update(mode) {
                const meta = this._cachedMeta;
                this.update(mode || "default");
                meta._clip = toClip(valueOrDefault(this.options.clip, defaultClip(meta.xScale, meta.yScale, this.getMaxOverflow())));
            }
            update(mode) {}
            draw() {
                const ctx = this._ctx;
                const chart = this.chart;
                const meta = this._cachedMeta;
                const elements = meta.data || [];
                const area = chart.chartArea;
                const active = [];
                const start = this._drawStart || 0;
                const count = this._drawCount || elements.length - start;
                const drawActiveElementsOnTop = this.options.drawActiveElementsOnTop;
                let i;
                if (meta.dataset) meta.dataset.draw(ctx, area, start, count);
                for (i = start; i < start + count; ++i) {
                    const element = elements[i];
                    if (element.hidden) continue;
                    if (element.active && drawActiveElementsOnTop) active.push(element); else element.draw(ctx, area);
                }
                for (i = 0; i < active.length; ++i) active[i].draw(ctx, area);
            }
            getStyle(index, active) {
                const mode = active ? "active" : "default";
                return index === void 0 && this._cachedMeta.dataset ? this.resolveDatasetElementOptions(mode) : this.resolveDataElementOptions(index || 0, mode);
            }
            getContext(index, active, mode) {
                const dataset = this.getDataset();
                let context;
                if (index >= 0 && index < this._cachedMeta.data.length) {
                    const element = this._cachedMeta.data[index];
                    context = element.$context || (element.$context = createDataContext(this.getContext(), index, element));
                    context.parsed = this.getParsed(index);
                    context.raw = dataset.data[index];
                    context.index = context.dataIndex = index;
                } else {
                    context = this.$context || (this.$context = createDatasetContext(this.chart.getContext(), this.index));
                    context.dataset = dataset;
                    context.index = context.datasetIndex = this.index;
                }
                context.active = !!active;
                context.mode = mode;
                return context;
            }
            resolveDatasetElementOptions(mode) {
                return this._resolveElementOptions(this.datasetElementType.id, mode);
            }
            resolveDataElementOptions(index, mode) {
                return this._resolveElementOptions(this.dataElementType.id, mode, index);
            }
            _resolveElementOptions(elementType, mode = "default", index) {
                const active = mode === "active";
                const cache = this._cachedDataOpts;
                const cacheKey = elementType + "-" + mode;
                const cached = cache[cacheKey];
                const sharing = this.enableOptionSharing && defined(index);
                if (cached) return cloneIfNotShared(cached, sharing);
                const config = this.chart.config;
                const scopeKeys = config.datasetElementScopeKeys(this._type, elementType);
                const prefixes = active ? [ `${elementType}Hover`, "hover", elementType, "" ] : [ elementType, "" ];
                const scopes = config.getOptionScopes(this.getDataset(), scopeKeys);
                const names = Object.keys(defaults.elements[elementType]);
                const context = () => this.getContext(index, active, mode);
                const values = config.resolveNamedOptions(scopes, names, context, prefixes);
                if (values.$shared) {
                    values.$shared = sharing;
                    cache[cacheKey] = Object.freeze(cloneIfNotShared(values, sharing));
                }
                return values;
            }
            _resolveAnimations(index, transition, active) {
                const chart = this.chart;
                const cache = this._cachedDataOpts;
                const cacheKey = `animation-${transition}`;
                const cached = cache[cacheKey];
                if (cached) return cached;
                let options;
                if (chart.options.animation !== false) {
                    const config = this.chart.config;
                    const scopeKeys = config.datasetAnimationScopeKeys(this._type, transition);
                    const scopes = config.getOptionScopes(this.getDataset(), scopeKeys);
                    options = config.createResolver(scopes, this.getContext(index, active, transition));
                }
                const animations = new Animations(chart, options && options.animations);
                if (options && options._cacheable) cache[cacheKey] = Object.freeze(animations);
                return animations;
            }
            getSharedOptions(options) {
                if (!options.$shared) return;
                return this._sharedOptions || (this._sharedOptions = Object.assign({}, options));
            }
            includeOptions(mode, sharedOptions) {
                return !sharedOptions || isDirectUpdateMode(mode) || this.chart._animationsDisabled;
            }
            _getSharedOptions(start, mode) {
                const firstOpts = this.resolveDataElementOptions(start, mode);
                const previouslySharedOptions = this._sharedOptions;
                const sharedOptions = this.getSharedOptions(firstOpts);
                const includeOptions = this.includeOptions(mode, sharedOptions) || sharedOptions !== previouslySharedOptions;
                this.updateSharedOptions(sharedOptions, mode, firstOpts);
                return {
                    sharedOptions,
                    includeOptions
                };
            }
            updateElement(element, index, properties, mode) {
                if (isDirectUpdateMode(mode)) Object.assign(element, properties); else this._resolveAnimations(index, mode).update(element, properties);
            }
            updateSharedOptions(sharedOptions, mode, newOptions) {
                if (sharedOptions && !isDirectUpdateMode(mode)) this._resolveAnimations(void 0, mode).update(sharedOptions, newOptions);
            }
            _setStyle(element, index, mode, active) {
                element.active = active;
                const options = this.getStyle(index, active);
                this._resolveAnimations(index, mode, active).update(element, {
                    options: !active && this.getSharedOptions(options) || options
                });
            }
            removeHoverStyle(element, datasetIndex, index) {
                this._setStyle(element, index, "active", false);
            }
            setHoverStyle(element, datasetIndex, index) {
                this._setStyle(element, index, "active", true);
            }
            _removeDatasetHoverStyle() {
                const element = this._cachedMeta.dataset;
                if (element) this._setStyle(element, void 0, "active", false);
            }
            _setDatasetHoverStyle() {
                const element = this._cachedMeta.dataset;
                if (element) this._setStyle(element, void 0, "active", true);
            }
            _resyncElements(resetNewElements) {
                const data = this._data;
                const elements = this._cachedMeta.data;
                for (const [method, arg1, arg2] of this._syncList) this[method](arg1, arg2);
                this._syncList = [];
                const numMeta = elements.length;
                const numData = data.length;
                const count = Math.min(numData, numMeta);
                if (count) this.parse(0, count);
                if (numData > numMeta) this._insertElements(numMeta, numData - numMeta, resetNewElements); else if (numData < numMeta) this._removeElements(numData, numMeta - numData);
            }
            _insertElements(start, count, resetNewElements = true) {
                const meta = this._cachedMeta;
                const data = meta.data;
                const end = start + count;
                let i;
                const move = arr => {
                    arr.length += count;
                    for (i = arr.length - 1; i >= end; i--) arr[i] = arr[i - count];
                };
                move(data);
                for (i = start; i < end; ++i) data[i] = new this.dataElementType;
                if (this._parsing) move(meta._parsed);
                this.parse(start, count);
                if (resetNewElements) this.updateElements(data, start, count, "reset");
            }
            updateElements(element, start, count, mode) {}
            _removeElements(start, count) {
                const meta = this._cachedMeta;
                if (this._parsing) {
                    const removed = meta._parsed.splice(start, count);
                    if (meta._stacked) clearStacks(meta, removed);
                }
                meta.data.splice(start, count);
            }
            _sync(args) {
                if (this._parsing) this._syncList.push(args); else {
                    const [method, arg1, arg2] = args;
                    this[method](arg1, arg2);
                }
                this.chart._dataChanges.push([ this.index, ...args ]);
            }
            _onDataPush() {
                const count = arguments.length;
                this._sync([ "_insertElements", this.getDataset().data.length - count, count ]);
            }
            _onDataPop() {
                this._sync([ "_removeElements", this._cachedMeta.data.length - 1, 1 ]);
            }
            _onDataShift() {
                this._sync([ "_removeElements", 0, 1 ]);
            }
            _onDataSplice(start, count) {
                if (count) this._sync([ "_removeElements", start, count ]);
                const newCount = arguments.length - 2;
                if (newCount) this._sync([ "_insertElements", start, newCount ]);
            }
            _onDataUnshift() {
                this._sync([ "_insertElements", 0, arguments.length ]);
            }
        }
        function getAllScaleValues(scale, type) {
            if (!scale._cache.$bar) {
                const visibleMetas = scale.getMatchingVisibleMetas(type);
                let values = [];
                for (let i = 0, ilen = visibleMetas.length; i < ilen; i++) values = values.concat(visibleMetas[i].controller.getAllParsedValues(scale));
                scale._cache.$bar = _arrayUnique(values.sort(((a, b) => a - b)));
            }
            return scale._cache.$bar;
        }
        function computeMinSampleSize(meta) {
            const scale = meta.iScale;
            const values = getAllScaleValues(scale, meta.type);
            let min = scale._length;
            let i, ilen, curr, prev;
            const updateMinAndPrev = () => {
                if (curr === 32767 || curr === -32768) return;
                if (defined(prev)) min = Math.min(min, Math.abs(curr - prev) || min);
                prev = curr;
            };
            for (i = 0, ilen = values.length; i < ilen; ++i) {
                curr = scale.getPixelForValue(values[i]);
                updateMinAndPrev();
            }
            prev = void 0;
            for (i = 0, ilen = scale.ticks.length; i < ilen; ++i) {
                curr = scale.getPixelForTick(i);
                updateMinAndPrev();
            }
            return min;
        }
        function computeFitCategoryTraits(index, ruler, options, stackCount) {
            const thickness = options.barThickness;
            let size, ratio;
            if (isNullOrUndef(thickness)) {
                size = ruler.min * options.categoryPercentage;
                ratio = options.barPercentage;
            } else {
                size = thickness * stackCount;
                ratio = 1;
            }
            return {
                chunk: size / stackCount,
                ratio,
                start: ruler.pixels[index] - size / 2
            };
        }
        function computeFlexCategoryTraits(index, ruler, options, stackCount) {
            const pixels = ruler.pixels;
            const curr = pixels[index];
            let prev = index > 0 ? pixels[index - 1] : null;
            let next = index < pixels.length - 1 ? pixels[index + 1] : null;
            const percent = options.categoryPercentage;
            if (prev === null) prev = curr - (next === null ? ruler.end - ruler.start : next - curr);
            if (next === null) next = curr + curr - prev;
            const start = curr - (curr - Math.min(prev, next)) / 2 * percent;
            const size = Math.abs(next - prev) / 2 * percent;
            return {
                chunk: size / stackCount,
                ratio: options.barPercentage,
                start
            };
        }
        function parseFloatBar(entry, item, vScale, i) {
            const startValue = vScale.parse(entry[0], i);
            const endValue = vScale.parse(entry[1], i);
            const min = Math.min(startValue, endValue);
            const max = Math.max(startValue, endValue);
            let barStart = min;
            let barEnd = max;
            if (Math.abs(min) > Math.abs(max)) {
                barStart = max;
                barEnd = min;
            }
            item[vScale.axis] = barEnd;
            item._custom = {
                barStart,
                barEnd,
                start: startValue,
                end: endValue,
                min,
                max
            };
        }
        function parseValue(entry, item, vScale, i) {
            if (isArray(entry)) parseFloatBar(entry, item, vScale, i); else item[vScale.axis] = vScale.parse(entry, i);
            return item;
        }
        function parseArrayOrPrimitive(meta, data, start, count) {
            const iScale = meta.iScale;
            const vScale = meta.vScale;
            const labels = iScale.getLabels();
            const singleScale = iScale === vScale;
            const parsed = [];
            let i, ilen, item, entry;
            for (i = start, ilen = start + count; i < ilen; ++i) {
                entry = data[i];
                item = {};
                item[iScale.axis] = singleScale || iScale.parse(labels[i], i);
                parsed.push(parseValue(entry, item, vScale, i));
            }
            return parsed;
        }
        function isFloatBar(custom) {
            return custom && custom.barStart !== void 0 && custom.barEnd !== void 0;
        }
        function barSign(size, vScale, actualBase) {
            if (size !== 0) return sign(size);
            return (vScale.isHorizontal() ? 1 : -1) * (vScale.min >= actualBase ? 1 : -1);
        }
        function borderProps(properties) {
            let reverse, start, end, top, bottom;
            if (properties.horizontal) {
                reverse = properties.base > properties.x;
                start = "left";
                end = "right";
            } else {
                reverse = properties.base < properties.y;
                start = "bottom";
                end = "top";
            }
            if (reverse) {
                top = "end";
                bottom = "start";
            } else {
                top = "start";
                bottom = "end";
            }
            return {
                start,
                end,
                reverse,
                top,
                bottom
            };
        }
        function setBorderSkipped(properties, options, stack, index) {
            let edge = options.borderSkipped;
            const res = {};
            if (!edge) {
                properties.borderSkipped = res;
                return;
            }
            if (edge === true) {
                properties.borderSkipped = {
                    top: true,
                    right: true,
                    bottom: true,
                    left: true
                };
                return;
            }
            const {start, end, reverse, top, bottom} = borderProps(properties);
            if (edge === "middle" && stack) {
                properties.enableBorderRadius = true;
                if ((stack._top || 0) === index) edge = top; else if ((stack._bottom || 0) === index) edge = bottom; else {
                    res[parseEdge(bottom, start, end, reverse)] = true;
                    edge = top;
                }
            }
            res[parseEdge(edge, start, end, reverse)] = true;
            properties.borderSkipped = res;
        }
        function parseEdge(edge, a, b, reverse) {
            if (reverse) {
                edge = swap(edge, a, b);
                edge = startEnd(edge, b, a);
            } else edge = startEnd(edge, a, b);
            return edge;
        }
        function swap(orig, v1, v2) {
            return orig === v1 ? v2 : orig === v2 ? v1 : orig;
        }
        function startEnd(v, start, end) {
            return v === "start" ? start : v === "end" ? end : v;
        }
        function setInflateAmount(properties, {inflateAmount}, ratio) {
            properties.inflateAmount = inflateAmount === "auto" ? ratio === 1 ? .33 : 0 : inflateAmount;
        }
        class BarController extends DatasetController {
            static id="bar";
            static defaults={
                datasetElementType: false,
                dataElementType: "bar",
                categoryPercentage: .8,
                barPercentage: .9,
                grouped: true,
                animations: {
                    numbers: {
                        type: "number",
                        properties: [ "x", "y", "base", "width", "height" ]
                    }
                }
            };
            static overrides={
                scales: {
                    _index_: {
                        type: "category",
                        offset: true,
                        grid: {
                            offset: true
                        }
                    },
                    _value_: {
                        type: "linear",
                        beginAtZero: true
                    }
                }
            };
            parsePrimitiveData(meta, data, start, count) {
                return parseArrayOrPrimitive(meta, data, start, count);
            }
            parseArrayData(meta, data, start, count) {
                return parseArrayOrPrimitive(meta, data, start, count);
            }
            parseObjectData(meta, data, start, count) {
                const {iScale, vScale} = meta;
                const {xAxisKey = "x", yAxisKey = "y"} = this._parsing;
                const iAxisKey = iScale.axis === "x" ? xAxisKey : yAxisKey;
                const vAxisKey = vScale.axis === "x" ? xAxisKey : yAxisKey;
                const parsed = [];
                let i, ilen, item, obj;
                for (i = start, ilen = start + count; i < ilen; ++i) {
                    obj = data[i];
                    item = {};
                    item[iScale.axis] = iScale.parse(resolveObjectKey(obj, iAxisKey), i);
                    parsed.push(parseValue(resolveObjectKey(obj, vAxisKey), item, vScale, i));
                }
                return parsed;
            }
            updateRangeFromParsed(range, scale, parsed, stack) {
                super.updateRangeFromParsed(range, scale, parsed, stack);
                const custom = parsed._custom;
                if (custom && scale === this._cachedMeta.vScale) {
                    range.min = Math.min(range.min, custom.min);
                    range.max = Math.max(range.max, custom.max);
                }
            }
            getMaxOverflow() {
                return 0;
            }
            getLabelAndValue(index) {
                const meta = this._cachedMeta;
                const {iScale, vScale} = meta;
                const parsed = this.getParsed(index);
                const custom = parsed._custom;
                const value = isFloatBar(custom) ? "[" + custom.start + ", " + custom.end + "]" : "" + vScale.getLabelForValue(parsed[vScale.axis]);
                return {
                    label: "" + iScale.getLabelForValue(parsed[iScale.axis]),
                    value
                };
            }
            initialize() {
                this.enableOptionSharing = true;
                super.initialize();
                const meta = this._cachedMeta;
                meta.stack = this.getDataset().stack;
            }
            update(mode) {
                const meta = this._cachedMeta;
                this.updateElements(meta.data, 0, meta.data.length, mode);
            }
            updateElements(bars, start, count, mode) {
                const reset = mode === "reset";
                const {index, _cachedMeta: {vScale}} = this;
                const base = vScale.getBasePixel();
                const horizontal = vScale.isHorizontal();
                const ruler = this._getRuler();
                const {sharedOptions, includeOptions} = this._getSharedOptions(start, mode);
                for (let i = start; i < start + count; i++) {
                    const parsed = this.getParsed(i);
                    const vpixels = reset || isNullOrUndef(parsed[vScale.axis]) ? {
                        base,
                        head: base
                    } : this._calculateBarValuePixels(i);
                    const ipixels = this._calculateBarIndexPixels(i, ruler);
                    const stack = (parsed._stacks || {})[vScale.axis];
                    const properties = {
                        horizontal,
                        base: vpixels.base,
                        enableBorderRadius: !stack || isFloatBar(parsed._custom) || index === stack._top || index === stack._bottom,
                        x: horizontal ? vpixels.head : ipixels.center,
                        y: horizontal ? ipixels.center : vpixels.head,
                        height: horizontal ? ipixels.size : Math.abs(vpixels.size),
                        width: horizontal ? Math.abs(vpixels.size) : ipixels.size
                    };
                    if (includeOptions) properties.options = sharedOptions || this.resolveDataElementOptions(i, bars[i].active ? "active" : mode);
                    const options = properties.options || bars[i].options;
                    setBorderSkipped(properties, options, stack, index);
                    setInflateAmount(properties, options, ruler.ratio);
                    this.updateElement(bars[i], i, properties, mode);
                }
            }
            _getStacks(last, dataIndex) {
                const {iScale} = this._cachedMeta;
                const metasets = iScale.getMatchingVisibleMetas(this._type).filter((meta => meta.controller.options.grouped));
                const stacked = iScale.options.stacked;
                const stacks = [];
                const currentParsed = this._cachedMeta.controller.getParsed(dataIndex);
                const iScaleValue = currentParsed && currentParsed[iScale.axis];
                const skipNull = meta => {
                    const parsed = meta._parsed.find((item => item[iScale.axis] === iScaleValue));
                    const val = parsed && parsed[meta.vScale.axis];
                    if (isNullOrUndef(val) || isNaN(val)) return true;
                };
                for (const meta of metasets) {
                    if (dataIndex !== void 0 && skipNull(meta)) continue;
                    if (stacked === false || stacks.indexOf(meta.stack) === -1 || stacked === void 0 && meta.stack === void 0) stacks.push(meta.stack);
                    if (meta.index === last) break;
                }
                if (!stacks.length) stacks.push(void 0);
                return stacks;
            }
            _getStackCount(index) {
                return this._getStacks(void 0, index).length;
            }
            _getStackIndex(datasetIndex, name, dataIndex) {
                const stacks = this._getStacks(datasetIndex, dataIndex);
                const index = name !== void 0 ? stacks.indexOf(name) : -1;
                return index === -1 ? stacks.length - 1 : index;
            }
            _getRuler() {
                const opts = this.options;
                const meta = this._cachedMeta;
                const iScale = meta.iScale;
                const pixels = [];
                let i, ilen;
                for (i = 0, ilen = meta.data.length; i < ilen; ++i) pixels.push(iScale.getPixelForValue(this.getParsed(i)[iScale.axis], i));
                const barThickness = opts.barThickness;
                const min = barThickness || computeMinSampleSize(meta);
                return {
                    min,
                    pixels,
                    start: iScale._startPixel,
                    end: iScale._endPixel,
                    stackCount: this._getStackCount(),
                    scale: iScale,
                    grouped: opts.grouped,
                    ratio: barThickness ? 1 : opts.categoryPercentage * opts.barPercentage
                };
            }
            _calculateBarValuePixels(index) {
                const {_cachedMeta: {vScale, _stacked, index: datasetIndex}, options: {base: baseValue, minBarLength}} = this;
                const actualBase = baseValue || 0;
                const parsed = this.getParsed(index);
                const custom = parsed._custom;
                const floating = isFloatBar(custom);
                let value = parsed[vScale.axis];
                let start = 0;
                let length = _stacked ? this.applyStack(vScale, parsed, _stacked) : value;
                let head, size;
                if (length !== value) {
                    start = length - value;
                    length = value;
                }
                if (floating) {
                    value = custom.barStart;
                    length = custom.barEnd - custom.barStart;
                    if (value !== 0 && sign(value) !== sign(custom.barEnd)) start = 0;
                    start += value;
                }
                const startValue = !isNullOrUndef(baseValue) && !floating ? baseValue : start;
                let base = vScale.getPixelForValue(startValue);
                if (this.chart.getDataVisibility(index)) head = vScale.getPixelForValue(start + length); else head = base;
                size = head - base;
                if (Math.abs(size) < minBarLength) {
                    size = barSign(size, vScale, actualBase) * minBarLength;
                    if (value === actualBase) base -= size / 2;
                    const startPixel = vScale.getPixelForDecimal(0);
                    const endPixel = vScale.getPixelForDecimal(1);
                    const min = Math.min(startPixel, endPixel);
                    const max = Math.max(startPixel, endPixel);
                    base = Math.max(Math.min(base, max), min);
                    head = base + size;
                    if (_stacked && !floating) parsed._stacks[vScale.axis]._visualValues[datasetIndex] = vScale.getValueForPixel(head) - vScale.getValueForPixel(base);
                }
                if (base === vScale.getPixelForValue(actualBase)) {
                    const halfGrid = sign(size) * vScale.getLineWidthForValue(actualBase) / 2;
                    base += halfGrid;
                    size -= halfGrid;
                }
                return {
                    size,
                    base,
                    head,
                    center: head + size / 2
                };
            }
            _calculateBarIndexPixels(index, ruler) {
                const scale = ruler.scale;
                const options = this.options;
                const skipNull = options.skipNull;
                const maxBarThickness = valueOrDefault(options.maxBarThickness, 1 / 0);
                let center, size;
                if (ruler.grouped) {
                    const stackCount = skipNull ? this._getStackCount(index) : ruler.stackCount;
                    const range = options.barThickness === "flex" ? computeFlexCategoryTraits(index, ruler, options, stackCount) : computeFitCategoryTraits(index, ruler, options, stackCount);
                    const stackIndex = this._getStackIndex(this.index, this._cachedMeta.stack, skipNull ? index : void 0);
                    center = range.start + range.chunk * stackIndex + range.chunk / 2;
                    size = Math.min(maxBarThickness, range.chunk * range.ratio);
                } else {
                    center = scale.getPixelForValue(this.getParsed(index)[scale.axis], index);
                    size = Math.min(maxBarThickness, ruler.min * ruler.ratio);
                }
                return {
                    base: center - size / 2,
                    head: center + size / 2,
                    center,
                    size
                };
            }
            draw() {
                const meta = this._cachedMeta;
                const vScale = meta.vScale;
                const rects = meta.data;
                const ilen = rects.length;
                let i = 0;
                for (;i < ilen; ++i) if (this.getParsed(i)[vScale.axis] !== null && !rects[i].hidden) rects[i].draw(this._ctx);
            }
        }
        class BubbleController extends DatasetController {
            static id="bubble";
            static defaults={
                datasetElementType: false,
                dataElementType: "point",
                animations: {
                    numbers: {
                        type: "number",
                        properties: [ "x", "y", "borderWidth", "radius" ]
                    }
                }
            };
            static overrides={
                scales: {
                    x: {
                        type: "linear"
                    },
                    y: {
                        type: "linear"
                    }
                }
            };
            initialize() {
                this.enableOptionSharing = true;
                super.initialize();
            }
            parsePrimitiveData(meta, data, start, count) {
                const parsed = super.parsePrimitiveData(meta, data, start, count);
                for (let i = 0; i < parsed.length; i++) parsed[i]._custom = this.resolveDataElementOptions(i + start).radius;
                return parsed;
            }
            parseArrayData(meta, data, start, count) {
                const parsed = super.parseArrayData(meta, data, start, count);
                for (let i = 0; i < parsed.length; i++) {
                    const item = data[start + i];
                    parsed[i]._custom = valueOrDefault(item[2], this.resolveDataElementOptions(i + start).radius);
                }
                return parsed;
            }
            parseObjectData(meta, data, start, count) {
                const parsed = super.parseObjectData(meta, data, start, count);
                for (let i = 0; i < parsed.length; i++) {
                    const item = data[start + i];
                    parsed[i]._custom = valueOrDefault(item && item.r && +item.r, this.resolveDataElementOptions(i + start).radius);
                }
                return parsed;
            }
            getMaxOverflow() {
                const data = this._cachedMeta.data;
                let max = 0;
                for (let i = data.length - 1; i >= 0; --i) max = Math.max(max, data[i].size(this.resolveDataElementOptions(i)) / 2);
                return max > 0 && max;
            }
            getLabelAndValue(index) {
                const meta = this._cachedMeta;
                const labels = this.chart.data.labels || [];
                const {xScale, yScale} = meta;
                const parsed = this.getParsed(index);
                const x = xScale.getLabelForValue(parsed.x);
                const y = yScale.getLabelForValue(parsed.y);
                const r = parsed._custom;
                return {
                    label: labels[index] || "",
                    value: "(" + x + ", " + y + (r ? ", " + r : "") + ")"
                };
            }
            update(mode) {
                const points = this._cachedMeta.data;
                this.updateElements(points, 0, points.length, mode);
            }
            updateElements(points, start, count, mode) {
                const reset = mode === "reset";
                const {iScale, vScale} = this._cachedMeta;
                const {sharedOptions, includeOptions} = this._getSharedOptions(start, mode);
                const iAxis = iScale.axis;
                const vAxis = vScale.axis;
                for (let i = start; i < start + count; i++) {
                    const point = points[i];
                    const parsed = !reset && this.getParsed(i);
                    const properties = {};
                    const iPixel = properties[iAxis] = reset ? iScale.getPixelForDecimal(.5) : iScale.getPixelForValue(parsed[iAxis]);
                    const vPixel = properties[vAxis] = reset ? vScale.getBasePixel() : vScale.getPixelForValue(parsed[vAxis]);
                    properties.skip = isNaN(iPixel) || isNaN(vPixel);
                    if (includeOptions) {
                        properties.options = sharedOptions || this.resolveDataElementOptions(i, point.active ? "active" : mode);
                        if (reset) properties.options.radius = 0;
                    }
                    this.updateElement(point, i, properties, mode);
                }
            }
            resolveDataElementOptions(index, mode) {
                const parsed = this.getParsed(index);
                let values = super.resolveDataElementOptions(index, mode);
                if (values.$shared) values = Object.assign({}, values, {
                    $shared: false
                });
                const radius = values.radius;
                if (mode !== "active") values.radius = 0;
                values.radius += valueOrDefault(parsed && parsed._custom, radius);
                return values;
            }
        }
        function getRatioAndOffset(rotation, circumference, cutout) {
            let ratioX = 1;
            let ratioY = 1;
            let offsetX = 0;
            let offsetY = 0;
            if (circumference < TAU) {
                const startAngle = rotation;
                const endAngle = startAngle + circumference;
                const startX = Math.cos(startAngle);
                const startY = Math.sin(startAngle);
                const endX = Math.cos(endAngle);
                const endY = Math.sin(endAngle);
                const calcMax = (angle, a, b) => _angleBetween(angle, startAngle, endAngle, true) ? 1 : Math.max(a, a * cutout, b, b * cutout);
                const calcMin = (angle, a, b) => _angleBetween(angle, startAngle, endAngle, true) ? -1 : Math.min(a, a * cutout, b, b * cutout);
                const maxX = calcMax(0, startX, endX);
                const maxY = calcMax(HALF_PI, startY, endY);
                const minX = calcMin(PI, startX, endX);
                const minY = calcMin(PI + HALF_PI, startY, endY);
                ratioX = (maxX - minX) / 2;
                ratioY = (maxY - minY) / 2;
                offsetX = -(maxX + minX) / 2;
                offsetY = -(maxY + minY) / 2;
            }
            return {
                ratioX,
                ratioY,
                offsetX,
                offsetY
            };
        }
        class DoughnutController extends DatasetController {
            static id="doughnut";
            static defaults={
                datasetElementType: false,
                dataElementType: "arc",
                animation: {
                    animateRotate: true,
                    animateScale: false
                },
                animations: {
                    numbers: {
                        type: "number",
                        properties: [ "circumference", "endAngle", "innerRadius", "outerRadius", "startAngle", "x", "y", "offset", "borderWidth", "spacing" ]
                    }
                },
                cutout: "50%",
                rotation: 0,
                circumference: 360,
                radius: "100%",
                spacing: 0,
                indexAxis: "r"
            };
            static descriptors={
                _scriptable: name => name !== "spacing",
                _indexable: name => name !== "spacing" && !name.startsWith("borderDash") && !name.startsWith("hoverBorderDash")
            };
            static overrides={
                aspectRatio: 1,
                plugins: {
                    legend: {
                        labels: {
                            generateLabels(chart) {
                                const data = chart.data;
                                if (data.labels.length && data.datasets.length) {
                                    const {labels: {pointStyle, color}} = chart.legend.options;
                                    return data.labels.map(((label, i) => {
                                        const meta = chart.getDatasetMeta(0);
                                        const style = meta.controller.getStyle(i);
                                        return {
                                            text: label,
                                            fillStyle: style.backgroundColor,
                                            strokeStyle: style.borderColor,
                                            fontColor: color,
                                            lineWidth: style.borderWidth,
                                            pointStyle,
                                            hidden: !chart.getDataVisibility(i),
                                            index: i
                                        };
                                    }));
                                }
                                return [];
                            }
                        },
                        onClick(e, legendItem, legend) {
                            legend.chart.toggleDataVisibility(legendItem.index);
                            legend.chart.update();
                        }
                    }
                }
            };
            constructor(chart, datasetIndex) {
                super(chart, datasetIndex);
                this.enableOptionSharing = true;
                this.innerRadius = void 0;
                this.outerRadius = void 0;
                this.offsetX = void 0;
                this.offsetY = void 0;
            }
            linkScales() {}
            parse(start, count) {
                const data = this.getDataset().data;
                const meta = this._cachedMeta;
                if (this._parsing === false) meta._parsed = data; else {
                    let getter = i => +data[i];
                    if (helpers_segment_isObject(data[start])) {
                        const {key = "value"} = this._parsing;
                        getter = i => +resolveObjectKey(data[i], key);
                    }
                    let i, ilen;
                    for (i = start, ilen = start + count; i < ilen; ++i) meta._parsed[i] = getter(i);
                }
            }
            _getRotation() {
                return toRadians(this.options.rotation - 90);
            }
            _getCircumference() {
                return toRadians(this.options.circumference);
            }
            _getRotationExtents() {
                let min = TAU;
                let max = -TAU;
                for (let i = 0; i < this.chart.data.datasets.length; ++i) if (this.chart.isDatasetVisible(i) && this.chart.getDatasetMeta(i).type === this._type) {
                    const controller = this.chart.getDatasetMeta(i).controller;
                    const rotation = controller._getRotation();
                    const circumference = controller._getCircumference();
                    min = Math.min(min, rotation);
                    max = Math.max(max, rotation + circumference);
                }
                return {
                    rotation: min,
                    circumference: max - min
                };
            }
            update(mode) {
                const chart = this.chart;
                const {chartArea} = chart;
                const meta = this._cachedMeta;
                const arcs = meta.data;
                const spacing = this.getMaxBorderWidth() + this.getMaxOffset(arcs) + this.options.spacing;
                const maxSize = Math.max((Math.min(chartArea.width, chartArea.height) - spacing) / 2, 0);
                const cutout = Math.min(toPercentage(this.options.cutout, maxSize), 1);
                const chartWeight = this._getRingWeight(this.index);
                const {circumference, rotation} = this._getRotationExtents();
                const {ratioX, ratioY, offsetX, offsetY} = getRatioAndOffset(rotation, circumference, cutout);
                const maxWidth = (chartArea.width - spacing) / ratioX;
                const maxHeight = (chartArea.height - spacing) / ratioY;
                const maxRadius = Math.max(Math.min(maxWidth, maxHeight) / 2, 0);
                const outerRadius = toDimension(this.options.radius, maxRadius);
                const innerRadius = Math.max(outerRadius * cutout, 0);
                const radiusLength = (outerRadius - innerRadius) / this._getVisibleDatasetWeightTotal();
                this.offsetX = offsetX * outerRadius;
                this.offsetY = offsetY * outerRadius;
                meta.total = this.calculateTotal();
                this.outerRadius = outerRadius - radiusLength * this._getRingWeightOffset(this.index);
                this.innerRadius = Math.max(this.outerRadius - radiusLength * chartWeight, 0);
                this.updateElements(arcs, 0, arcs.length, mode);
            }
            _circumference(i, reset) {
                const opts = this.options;
                const meta = this._cachedMeta;
                const circumference = this._getCircumference();
                if (reset && opts.animation.animateRotate || !this.chart.getDataVisibility(i) || meta._parsed[i] === null || meta.data[i].hidden) return 0;
                return this.calculateCircumference(meta._parsed[i] * circumference / TAU);
            }
            updateElements(arcs, start, count, mode) {
                const reset = mode === "reset";
                const chart = this.chart;
                const chartArea = chart.chartArea;
                const opts = chart.options;
                const animationOpts = opts.animation;
                const centerX = (chartArea.left + chartArea.right) / 2;
                const centerY = (chartArea.top + chartArea.bottom) / 2;
                const animateScale = reset && animationOpts.animateScale;
                const innerRadius = animateScale ? 0 : this.innerRadius;
                const outerRadius = animateScale ? 0 : this.outerRadius;
                const {sharedOptions, includeOptions} = this._getSharedOptions(start, mode);
                let startAngle = this._getRotation();
                let i;
                for (i = 0; i < start; ++i) startAngle += this._circumference(i, reset);
                for (i = start; i < start + count; ++i) {
                    const circumference = this._circumference(i, reset);
                    const arc = arcs[i];
                    const properties = {
                        x: centerX + this.offsetX,
                        y: centerY + this.offsetY,
                        startAngle,
                        endAngle: startAngle + circumference,
                        circumference,
                        outerRadius,
                        innerRadius
                    };
                    if (includeOptions) properties.options = sharedOptions || this.resolveDataElementOptions(i, arc.active ? "active" : mode);
                    startAngle += circumference;
                    this.updateElement(arc, i, properties, mode);
                }
            }
            calculateTotal() {
                const meta = this._cachedMeta;
                const metaData = meta.data;
                let total = 0;
                let i;
                for (i = 0; i < metaData.length; i++) {
                    const value = meta._parsed[i];
                    if (value !== null && !isNaN(value) && this.chart.getDataVisibility(i) && !metaData[i].hidden) total += Math.abs(value);
                }
                return total;
            }
            calculateCircumference(value) {
                const total = this._cachedMeta.total;
                if (total > 0 && !isNaN(value)) return TAU * (Math.abs(value) / total);
                return 0;
            }
            getLabelAndValue(index) {
                const meta = this._cachedMeta;
                const chart = this.chart;
                const labels = chart.data.labels || [];
                const value = formatNumber(meta._parsed[index], chart.options.locale);
                return {
                    label: labels[index] || "",
                    value
                };
            }
            getMaxBorderWidth(arcs) {
                let max = 0;
                const chart = this.chart;
                let i, ilen, meta, controller, options;
                if (!arcs) for (i = 0, ilen = chart.data.datasets.length; i < ilen; ++i) if (chart.isDatasetVisible(i)) {
                    meta = chart.getDatasetMeta(i);
                    arcs = meta.data;
                    controller = meta.controller;
                    break;
                }
                if (!arcs) return 0;
                for (i = 0, ilen = arcs.length; i < ilen; ++i) {
                    options = controller.resolveDataElementOptions(i);
                    if (options.borderAlign !== "inner") max = Math.max(max, options.borderWidth || 0, options.hoverBorderWidth || 0);
                }
                return max;
            }
            getMaxOffset(arcs) {
                let max = 0;
                for (let i = 0, ilen = arcs.length; i < ilen; ++i) {
                    const options = this.resolveDataElementOptions(i);
                    max = Math.max(max, options.offset || 0, options.hoverOffset || 0);
                }
                return max;
            }
            _getRingWeightOffset(datasetIndex) {
                let ringWeightOffset = 0;
                for (let i = 0; i < datasetIndex; ++i) if (this.chart.isDatasetVisible(i)) ringWeightOffset += this._getRingWeight(i);
                return ringWeightOffset;
            }
            _getRingWeight(datasetIndex) {
                return Math.max(valueOrDefault(this.chart.data.datasets[datasetIndex].weight, 1), 0);
            }
            _getVisibleDatasetWeightTotal() {
                return this._getRingWeightOffset(this.chart.data.datasets.length) || 1;
            }
        }
        class LineController extends DatasetController {
            static id="line";
            static defaults={
                datasetElementType: "line",
                dataElementType: "point",
                showLine: true,
                spanGaps: false
            };
            static overrides={
                scales: {
                    _index_: {
                        type: "category"
                    },
                    _value_: {
                        type: "linear"
                    }
                }
            };
            initialize() {
                this.enableOptionSharing = true;
                this.supportsDecimation = true;
                super.initialize();
            }
            update(mode) {
                const meta = this._cachedMeta;
                const {dataset: line, data: points = [], _dataset} = meta;
                const animationsDisabled = this.chart._animationsDisabled;
                let {start, count} = _getStartAndCountOfVisiblePoints(meta, points, animationsDisabled);
                this._drawStart = start;
                this._drawCount = count;
                if (_scaleRangesChanged(meta)) {
                    start = 0;
                    count = points.length;
                }
                line._chart = this.chart;
                line._datasetIndex = this.index;
                line._decimated = !!_dataset._decimated;
                line.points = points;
                const options = this.resolveDatasetElementOptions(mode);
                if (!this.options.showLine) options.borderWidth = 0;
                options.segment = this.options.segment;
                this.updateElement(line, void 0, {
                    animated: !animationsDisabled,
                    options
                }, mode);
                this.updateElements(points, start, count, mode);
            }
            updateElements(points, start, count, mode) {
                const reset = mode === "reset";
                const {iScale, vScale, _stacked, _dataset} = this._cachedMeta;
                const {sharedOptions, includeOptions} = this._getSharedOptions(start, mode);
                const iAxis = iScale.axis;
                const vAxis = vScale.axis;
                const {spanGaps, segment} = this.options;
                const maxGapLength = isNumber(spanGaps) ? spanGaps : Number.POSITIVE_INFINITY;
                const directUpdate = this.chart._animationsDisabled || reset || mode === "none";
                const end = start + count;
                const pointsCount = points.length;
                let prevParsed = start > 0 && this.getParsed(start - 1);
                for (let i = 0; i < pointsCount; ++i) {
                    const point = points[i];
                    const properties = directUpdate ? point : {};
                    if (i < start || i >= end) {
                        properties.skip = true;
                        continue;
                    }
                    const parsed = this.getParsed(i);
                    const nullData = isNullOrUndef(parsed[vAxis]);
                    const iPixel = properties[iAxis] = iScale.getPixelForValue(parsed[iAxis], i);
                    const vPixel = properties[vAxis] = reset || nullData ? vScale.getBasePixel() : vScale.getPixelForValue(_stacked ? this.applyStack(vScale, parsed, _stacked) : parsed[vAxis], i);
                    properties.skip = isNaN(iPixel) || isNaN(vPixel) || nullData;
                    properties.stop = i > 0 && Math.abs(parsed[iAxis] - prevParsed[iAxis]) > maxGapLength;
                    if (segment) {
                        properties.parsed = parsed;
                        properties.raw = _dataset.data[i];
                    }
                    if (includeOptions) properties.options = sharedOptions || this.resolveDataElementOptions(i, point.active ? "active" : mode);
                    if (!directUpdate) this.updateElement(point, i, properties, mode);
                    prevParsed = parsed;
                }
            }
            getMaxOverflow() {
                const meta = this._cachedMeta;
                const dataset = meta.dataset;
                const border = dataset.options && dataset.options.borderWidth || 0;
                const data = meta.data || [];
                if (!data.length) return border;
                const firstPoint = data[0].size(this.resolveDataElementOptions(0));
                const lastPoint = data[data.length - 1].size(this.resolveDataElementOptions(data.length - 1));
                return Math.max(border, firstPoint, lastPoint) / 2;
            }
            draw() {
                const meta = this._cachedMeta;
                meta.dataset.updateControlPoints(this.chart.chartArea, meta.iScale.axis);
                super.draw();
            }
        }
        class PolarAreaController extends DatasetController {
            static id="polarArea";
            static defaults={
                dataElementType: "arc",
                animation: {
                    animateRotate: true,
                    animateScale: true
                },
                animations: {
                    numbers: {
                        type: "number",
                        properties: [ "x", "y", "startAngle", "endAngle", "innerRadius", "outerRadius" ]
                    }
                },
                indexAxis: "r",
                startAngle: 0
            };
            static overrides={
                aspectRatio: 1,
                plugins: {
                    legend: {
                        labels: {
                            generateLabels(chart) {
                                const data = chart.data;
                                if (data.labels.length && data.datasets.length) {
                                    const {labels: {pointStyle, color}} = chart.legend.options;
                                    return data.labels.map(((label, i) => {
                                        const meta = chart.getDatasetMeta(0);
                                        const style = meta.controller.getStyle(i);
                                        return {
                                            text: label,
                                            fillStyle: style.backgroundColor,
                                            strokeStyle: style.borderColor,
                                            fontColor: color,
                                            lineWidth: style.borderWidth,
                                            pointStyle,
                                            hidden: !chart.getDataVisibility(i),
                                            index: i
                                        };
                                    }));
                                }
                                return [];
                            }
                        },
                        onClick(e, legendItem, legend) {
                            legend.chart.toggleDataVisibility(legendItem.index);
                            legend.chart.update();
                        }
                    }
                },
                scales: {
                    r: {
                        type: "radialLinear",
                        angleLines: {
                            display: false
                        },
                        beginAtZero: true,
                        grid: {
                            circular: true
                        },
                        pointLabels: {
                            display: false
                        },
                        startAngle: 0
                    }
                }
            };
            constructor(chart, datasetIndex) {
                super(chart, datasetIndex);
                this.innerRadius = void 0;
                this.outerRadius = void 0;
            }
            getLabelAndValue(index) {
                const meta = this._cachedMeta;
                const chart = this.chart;
                const labels = chart.data.labels || [];
                const value = formatNumber(meta._parsed[index].r, chart.options.locale);
                return {
                    label: labels[index] || "",
                    value
                };
            }
            parseObjectData(meta, data, start, count) {
                return _parseObjectDataRadialScale.bind(this)(meta, data, start, count);
            }
            update(mode) {
                const arcs = this._cachedMeta.data;
                this._updateRadius();
                this.updateElements(arcs, 0, arcs.length, mode);
            }
            getMinMax() {
                const meta = this._cachedMeta;
                const range = {
                    min: Number.POSITIVE_INFINITY,
                    max: Number.NEGATIVE_INFINITY
                };
                meta.data.forEach(((element, index) => {
                    const parsed = this.getParsed(index).r;
                    if (!isNaN(parsed) && this.chart.getDataVisibility(index)) {
                        if (parsed < range.min) range.min = parsed;
                        if (parsed > range.max) range.max = parsed;
                    }
                }));
                return range;
            }
            _updateRadius() {
                const chart = this.chart;
                const chartArea = chart.chartArea;
                const opts = chart.options;
                const minSize = Math.min(chartArea.right - chartArea.left, chartArea.bottom - chartArea.top);
                const outerRadius = Math.max(minSize / 2, 0);
                const innerRadius = Math.max(opts.cutoutPercentage ? outerRadius / 100 * opts.cutoutPercentage : 1, 0);
                const radiusLength = (outerRadius - innerRadius) / chart.getVisibleDatasetCount();
                this.outerRadius = outerRadius - radiusLength * this.index;
                this.innerRadius = this.outerRadius - radiusLength;
            }
            updateElements(arcs, start, count, mode) {
                const reset = mode === "reset";
                const chart = this.chart;
                const opts = chart.options;
                const animationOpts = opts.animation;
                const scale = this._cachedMeta.rScale;
                const centerX = scale.xCenter;
                const centerY = scale.yCenter;
                const datasetStartAngle = scale.getIndexAngle(0) - .5 * PI;
                let angle = datasetStartAngle;
                let i;
                const defaultAngle = 360 / this.countVisibleElements();
                for (i = 0; i < start; ++i) angle += this._computeAngle(i, mode, defaultAngle);
                for (i = start; i < start + count; i++) {
                    const arc = arcs[i];
                    let startAngle = angle;
                    let endAngle = angle + this._computeAngle(i, mode, defaultAngle);
                    let outerRadius = chart.getDataVisibility(i) ? scale.getDistanceFromCenterForValue(this.getParsed(i).r) : 0;
                    angle = endAngle;
                    if (reset) {
                        if (animationOpts.animateScale) outerRadius = 0;
                        if (animationOpts.animateRotate) startAngle = endAngle = datasetStartAngle;
                    }
                    const properties = {
                        x: centerX,
                        y: centerY,
                        innerRadius: 0,
                        outerRadius,
                        startAngle,
                        endAngle,
                        options: this.resolveDataElementOptions(i, arc.active ? "active" : mode)
                    };
                    this.updateElement(arc, i, properties, mode);
                }
            }
            countVisibleElements() {
                const meta = this._cachedMeta;
                let count = 0;
                meta.data.forEach(((element, index) => {
                    if (!isNaN(this.getParsed(index).r) && this.chart.getDataVisibility(index)) count++;
                }));
                return count;
            }
            _computeAngle(index, mode, defaultAngle) {
                return this.chart.getDataVisibility(index) ? toRadians(this.resolveDataElementOptions(index, mode).angle || defaultAngle) : 0;
            }
        }
        class PieController extends DoughnutController {
            static id="pie";
            static defaults={
                cutout: 0,
                rotation: 0,
                circumference: 360,
                radius: "100%"
            };
        }
        class RadarController extends DatasetController {
            static id="radar";
            static defaults={
                datasetElementType: "line",
                dataElementType: "point",
                indexAxis: "r",
                showLine: true,
                elements: {
                    line: {
                        fill: "start"
                    }
                }
            };
            static overrides={
                aspectRatio: 1,
                scales: {
                    r: {
                        type: "radialLinear"
                    }
                }
            };
            getLabelAndValue(index) {
                const vScale = this._cachedMeta.vScale;
                const parsed = this.getParsed(index);
                return {
                    label: vScale.getLabels()[index],
                    value: "" + vScale.getLabelForValue(parsed[vScale.axis])
                };
            }
            parseObjectData(meta, data, start, count) {
                return _parseObjectDataRadialScale.bind(this)(meta, data, start, count);
            }
            update(mode) {
                const meta = this._cachedMeta;
                const line = meta.dataset;
                const points = meta.data || [];
                const labels = meta.iScale.getLabels();
                line.points = points;
                if (mode !== "resize") {
                    const options = this.resolveDatasetElementOptions(mode);
                    if (!this.options.showLine) options.borderWidth = 0;
                    const properties = {
                        _loop: true,
                        _fullLoop: labels.length === points.length,
                        options
                    };
                    this.updateElement(line, void 0, properties, mode);
                }
                this.updateElements(points, 0, points.length, mode);
            }
            updateElements(points, start, count, mode) {
                const scale = this._cachedMeta.rScale;
                const reset = mode === "reset";
                for (let i = start; i < start + count; i++) {
                    const point = points[i];
                    const options = this.resolveDataElementOptions(i, point.active ? "active" : mode);
                    const pointPosition = scale.getPointPositionForValue(i, this.getParsed(i).r);
                    const x = reset ? scale.xCenter : pointPosition.x;
                    const y = reset ? scale.yCenter : pointPosition.y;
                    const properties = {
                        x,
                        y,
                        angle: pointPosition.angle,
                        skip: isNaN(x) || isNaN(y),
                        options
                    };
                    this.updateElement(point, i, properties, mode);
                }
            }
        }
        class ScatterController extends DatasetController {
            static id="scatter";
            static defaults={
                datasetElementType: false,
                dataElementType: "point",
                showLine: false,
                fill: false
            };
            static overrides={
                interaction: {
                    mode: "point"
                },
                scales: {
                    x: {
                        type: "linear"
                    },
                    y: {
                        type: "linear"
                    }
                }
            };
            getLabelAndValue(index) {
                const meta = this._cachedMeta;
                const labels = this.chart.data.labels || [];
                const {xScale, yScale} = meta;
                const parsed = this.getParsed(index);
                const x = xScale.getLabelForValue(parsed.x);
                const y = yScale.getLabelForValue(parsed.y);
                return {
                    label: labels[index] || "",
                    value: "(" + x + ", " + y + ")"
                };
            }
            update(mode) {
                const meta = this._cachedMeta;
                const {data: points = []} = meta;
                const animationsDisabled = this.chart._animationsDisabled;
                let {start, count} = _getStartAndCountOfVisiblePoints(meta, points, animationsDisabled);
                this._drawStart = start;
                this._drawCount = count;
                if (_scaleRangesChanged(meta)) {
                    start = 0;
                    count = points.length;
                }
                if (this.options.showLine) {
                    if (!this.datasetElementType) this.addElements();
                    const {dataset: line, _dataset} = meta;
                    line._chart = this.chart;
                    line._datasetIndex = this.index;
                    line._decimated = !!_dataset._decimated;
                    line.points = points;
                    const options = this.resolveDatasetElementOptions(mode);
                    options.segment = this.options.segment;
                    this.updateElement(line, void 0, {
                        animated: !animationsDisabled,
                        options
                    }, mode);
                } else if (this.datasetElementType) {
                    delete meta.dataset;
                    this.datasetElementType = false;
                }
                this.updateElements(points, start, count, mode);
            }
            addElements() {
                const {showLine} = this.options;
                if (!this.datasetElementType && showLine) this.datasetElementType = this.chart.registry.getElement("line");
                super.addElements();
            }
            updateElements(points, start, count, mode) {
                const reset = mode === "reset";
                const {iScale, vScale, _stacked, _dataset} = this._cachedMeta;
                const firstOpts = this.resolveDataElementOptions(start, mode);
                const sharedOptions = this.getSharedOptions(firstOpts);
                const includeOptions = this.includeOptions(mode, sharedOptions);
                const iAxis = iScale.axis;
                const vAxis = vScale.axis;
                const {spanGaps, segment} = this.options;
                const maxGapLength = isNumber(spanGaps) ? spanGaps : Number.POSITIVE_INFINITY;
                const directUpdate = this.chart._animationsDisabled || reset || mode === "none";
                let prevParsed = start > 0 && this.getParsed(start - 1);
                for (let i = start; i < start + count; ++i) {
                    const point = points[i];
                    const parsed = this.getParsed(i);
                    const properties = directUpdate ? point : {};
                    const nullData = isNullOrUndef(parsed[vAxis]);
                    const iPixel = properties[iAxis] = iScale.getPixelForValue(parsed[iAxis], i);
                    const vPixel = properties[vAxis] = reset || nullData ? vScale.getBasePixel() : vScale.getPixelForValue(_stacked ? this.applyStack(vScale, parsed, _stacked) : parsed[vAxis], i);
                    properties.skip = isNaN(iPixel) || isNaN(vPixel) || nullData;
                    properties.stop = i > 0 && Math.abs(parsed[iAxis] - prevParsed[iAxis]) > maxGapLength;
                    if (segment) {
                        properties.parsed = parsed;
                        properties.raw = _dataset.data[i];
                    }
                    if (includeOptions) properties.options = sharedOptions || this.resolveDataElementOptions(i, point.active ? "active" : mode);
                    if (!directUpdate) this.updateElement(point, i, properties, mode);
                    prevParsed = parsed;
                }
                this.updateSharedOptions(sharedOptions, mode, firstOpts);
            }
            getMaxOverflow() {
                const meta = this._cachedMeta;
                const data = meta.data || [];
                if (!this.options.showLine) {
                    let max = 0;
                    for (let i = data.length - 1; i >= 0; --i) max = Math.max(max, data[i].size(this.resolveDataElementOptions(i)) / 2);
                    return max > 0 && max;
                }
                const dataset = meta.dataset;
                const border = dataset.options && dataset.options.borderWidth || 0;
                if (!data.length) return border;
                const firstPoint = data[0].size(this.resolveDataElementOptions(0));
                const lastPoint = data[data.length - 1].size(this.resolveDataElementOptions(data.length - 1));
                return Math.max(border, firstPoint, lastPoint) / 2;
            }
        }
        var controllers = Object.freeze({
            __proto__: null,
            BarController,
            BubbleController,
            DoughnutController,
            LineController,
            PieController,
            PolarAreaController,
            RadarController,
            ScatterController
        });
        function chart_abstract() {
            throw new Error("This method is not implemented: Check that a complete date adapter is provided.");
        }
        class DateAdapterBase {
            static override(members) {
                Object.assign(DateAdapterBase.prototype, members);
            }
            options;
            constructor(options) {
                this.options = options || {};
            }
            init() {}
            formats() {
                return chart_abstract();
            }
            parse() {
                return chart_abstract();
            }
            format() {
                return chart_abstract();
            }
            add() {
                return chart_abstract();
            }
            diff() {
                return chart_abstract();
            }
            startOf() {
                return chart_abstract();
            }
            endOf() {
                return chart_abstract();
            }
        }
        var adapters = {
            _date: DateAdapterBase
        };
        function binarySearch(metaset, axis, value, intersect) {
            const {controller, data, _sorted} = metaset;
            const iScale = controller._cachedMeta.iScale;
            if (iScale && axis === iScale.axis && axis !== "r" && _sorted && data.length) {
                const lookupMethod = iScale._reversePixels ? _rlookupByKey : _lookupByKey;
                if (!intersect) return lookupMethod(data, axis, value); else if (controller._sharedOptions) {
                    const el = data[0];
                    const range = typeof el.getRange === "function" && el.getRange(axis);
                    if (range) {
                        const start = lookupMethod(data, axis, value - range);
                        const end = lookupMethod(data, axis, value + range);
                        return {
                            lo: start.lo,
                            hi: end.hi
                        };
                    }
                }
            }
            return {
                lo: 0,
                hi: data.length - 1
            };
        }
        function evaluateInteractionItems(chart, axis, position, handler, intersect) {
            const metasets = chart.getSortedVisibleDatasetMetas();
            const value = position[axis];
            for (let i = 0, ilen = metasets.length; i < ilen; ++i) {
                const {index, data} = metasets[i];
                const {lo, hi} = binarySearch(metasets[i], axis, value, intersect);
                for (let j = lo; j <= hi; ++j) {
                    const element = data[j];
                    if (!element.skip) handler(element, index, j);
                }
            }
        }
        function getDistanceMetricForAxis(axis) {
            const useX = axis.indexOf("x") !== -1;
            const useY = axis.indexOf("y") !== -1;
            return function(pt1, pt2) {
                const deltaX = useX ? Math.abs(pt1.x - pt2.x) : 0;
                const deltaY = useY ? Math.abs(pt1.y - pt2.y) : 0;
                return Math.sqrt(Math.pow(deltaX, 2) + Math.pow(deltaY, 2));
            };
        }
        function getIntersectItems(chart, position, axis, useFinalPosition, includeInvisible) {
            const items = [];
            if (!includeInvisible && !chart.isPointInArea(position)) return items;
            const evaluationFunc = function(element, datasetIndex, index) {
                if (!includeInvisible && !_isPointInArea(element, chart.chartArea, 0)) return;
                if (element.inRange(position.x, position.y, useFinalPosition)) items.push({
                    element,
                    datasetIndex,
                    index
                });
            };
            evaluateInteractionItems(chart, axis, position, evaluationFunc, true);
            return items;
        }
        function getNearestRadialItems(chart, position, axis, useFinalPosition) {
            let items = [];
            function evaluationFunc(element, datasetIndex, index) {
                const {startAngle, endAngle} = element.getProps([ "startAngle", "endAngle" ], useFinalPosition);
                const {angle} = getAngleFromPoint(element, {
                    x: position.x,
                    y: position.y
                });
                if (_angleBetween(angle, startAngle, endAngle)) items.push({
                    element,
                    datasetIndex,
                    index
                });
            }
            evaluateInteractionItems(chart, axis, position, evaluationFunc);
            return items;
        }
        function getNearestCartesianItems(chart, position, axis, intersect, useFinalPosition, includeInvisible) {
            let items = [];
            const distanceMetric = getDistanceMetricForAxis(axis);
            let minDistance = Number.POSITIVE_INFINITY;
            function evaluationFunc(element, datasetIndex, index) {
                const inRange = element.inRange(position.x, position.y, useFinalPosition);
                if (intersect && !inRange) return;
                const center = element.getCenterPoint(useFinalPosition);
                const pointInArea = !!includeInvisible || chart.isPointInArea(center);
                if (!pointInArea && !inRange) return;
                const distance = distanceMetric(position, center);
                if (distance < minDistance) {
                    items = [ {
                        element,
                        datasetIndex,
                        index
                    } ];
                    minDistance = distance;
                } else if (distance === minDistance) items.push({
                    element,
                    datasetIndex,
                    index
                });
            }
            evaluateInteractionItems(chart, axis, position, evaluationFunc);
            return items;
        }
        function getNearestItems(chart, position, axis, intersect, useFinalPosition, includeInvisible) {
            if (!includeInvisible && !chart.isPointInArea(position)) return [];
            return axis === "r" && !intersect ? getNearestRadialItems(chart, position, axis, useFinalPosition) : getNearestCartesianItems(chart, position, axis, intersect, useFinalPosition, includeInvisible);
        }
        function getAxisItems(chart, position, axis, intersect, useFinalPosition) {
            const items = [];
            const rangeMethod = axis === "x" ? "inXRange" : "inYRange";
            let intersectsItem = false;
            evaluateInteractionItems(chart, axis, position, ((element, datasetIndex, index) => {
                if (element[rangeMethod] && element[rangeMethod](position[axis], useFinalPosition)) {
                    items.push({
                        element,
                        datasetIndex,
                        index
                    });
                    intersectsItem = intersectsItem || element.inRange(position.x, position.y, useFinalPosition);
                }
            }));
            if (intersect && !intersectsItem) return [];
            return items;
        }
        var Interaction = {
            evaluateInteractionItems,
            modes: {
                index(chart, e, options, useFinalPosition) {
                    const position = getRelativePosition(e, chart);
                    const axis = options.axis || "x";
                    const includeInvisible = options.includeInvisible || false;
                    const items = options.intersect ? getIntersectItems(chart, position, axis, useFinalPosition, includeInvisible) : getNearestItems(chart, position, axis, false, useFinalPosition, includeInvisible);
                    const elements = [];
                    if (!items.length) return [];
                    chart.getSortedVisibleDatasetMetas().forEach((meta => {
                        const index = items[0].index;
                        const element = meta.data[index];
                        if (element && !element.skip) elements.push({
                            element,
                            datasetIndex: meta.index,
                            index
                        });
                    }));
                    return elements;
                },
                dataset(chart, e, options, useFinalPosition) {
                    const position = getRelativePosition(e, chart);
                    const axis = options.axis || "xy";
                    const includeInvisible = options.includeInvisible || false;
                    let items = options.intersect ? getIntersectItems(chart, position, axis, useFinalPosition, includeInvisible) : getNearestItems(chart, position, axis, false, useFinalPosition, includeInvisible);
                    if (items.length > 0) {
                        const datasetIndex = items[0].datasetIndex;
                        const data = chart.getDatasetMeta(datasetIndex).data;
                        items = [];
                        for (let i = 0; i < data.length; ++i) items.push({
                            element: data[i],
                            datasetIndex,
                            index: i
                        });
                    }
                    return items;
                },
                point(chart, e, options, useFinalPosition) {
                    const position = getRelativePosition(e, chart);
                    const axis = options.axis || "xy";
                    const includeInvisible = options.includeInvisible || false;
                    return getIntersectItems(chart, position, axis, useFinalPosition, includeInvisible);
                },
                nearest(chart, e, options, useFinalPosition) {
                    const position = getRelativePosition(e, chart);
                    const axis = options.axis || "xy";
                    const includeInvisible = options.includeInvisible || false;
                    return getNearestItems(chart, position, axis, options.intersect, useFinalPosition, includeInvisible);
                },
                x(chart, e, options, useFinalPosition) {
                    const position = getRelativePosition(e, chart);
                    return getAxisItems(chart, position, "x", options.intersect, useFinalPosition);
                },
                y(chart, e, options, useFinalPosition) {
                    const position = getRelativePosition(e, chart);
                    return getAxisItems(chart, position, "y", options.intersect, useFinalPosition);
                }
            }
        };
        const STATIC_POSITIONS = [ "left", "top", "right", "bottom" ];
        function filterByPosition(array, position) {
            return array.filter((v => v.pos === position));
        }
        function filterDynamicPositionByAxis(array, axis) {
            return array.filter((v => STATIC_POSITIONS.indexOf(v.pos) === -1 && v.box.axis === axis));
        }
        function sortByWeight(array, reverse) {
            return array.sort(((a, b) => {
                const v0 = reverse ? b : a;
                const v1 = reverse ? a : b;
                return v0.weight === v1.weight ? v0.index - v1.index : v0.weight - v1.weight;
            }));
        }
        function wrapBoxes(boxes) {
            const layoutBoxes = [];
            let i, ilen, box, pos, stack, stackWeight;
            for (i = 0, ilen = (boxes || []).length; i < ilen; ++i) {
                box = boxes[i];
                ({position: pos, options: {stack, stackWeight = 1}} = box);
                layoutBoxes.push({
                    index: i,
                    box,
                    pos,
                    horizontal: box.isHorizontal(),
                    weight: box.weight,
                    stack: stack && pos + stack,
                    stackWeight
                });
            }
            return layoutBoxes;
        }
        function buildStacks(layouts) {
            const stacks = {};
            for (const wrap of layouts) {
                const {stack, pos, stackWeight} = wrap;
                if (!stack || !STATIC_POSITIONS.includes(pos)) continue;
                const _stack = stacks[stack] || (stacks[stack] = {
                    count: 0,
                    placed: 0,
                    weight: 0,
                    size: 0
                });
                _stack.count++;
                _stack.weight += stackWeight;
            }
            return stacks;
        }
        function setLayoutDims(layouts, params) {
            const stacks = buildStacks(layouts);
            const {vBoxMaxWidth, hBoxMaxHeight} = params;
            let i, ilen, layout;
            for (i = 0, ilen = layouts.length; i < ilen; ++i) {
                layout = layouts[i];
                const {fullSize} = layout.box;
                const stack = stacks[layout.stack];
                const factor = stack && layout.stackWeight / stack.weight;
                if (layout.horizontal) {
                    layout.width = factor ? factor * vBoxMaxWidth : fullSize && params.availableWidth;
                    layout.height = hBoxMaxHeight;
                } else {
                    layout.width = vBoxMaxWidth;
                    layout.height = factor ? factor * hBoxMaxHeight : fullSize && params.availableHeight;
                }
            }
            return stacks;
        }
        function buildLayoutBoxes(boxes) {
            const layoutBoxes = wrapBoxes(boxes);
            const fullSize = sortByWeight(layoutBoxes.filter((wrap => wrap.box.fullSize)), true);
            const left = sortByWeight(filterByPosition(layoutBoxes, "left"), true);
            const right = sortByWeight(filterByPosition(layoutBoxes, "right"));
            const top = sortByWeight(filterByPosition(layoutBoxes, "top"), true);
            const bottom = sortByWeight(filterByPosition(layoutBoxes, "bottom"));
            const centerHorizontal = filterDynamicPositionByAxis(layoutBoxes, "x");
            const centerVertical = filterDynamicPositionByAxis(layoutBoxes, "y");
            return {
                fullSize,
                leftAndTop: left.concat(top),
                rightAndBottom: right.concat(centerVertical).concat(bottom).concat(centerHorizontal),
                chartArea: filterByPosition(layoutBoxes, "chartArea"),
                vertical: left.concat(right).concat(centerVertical),
                horizontal: top.concat(bottom).concat(centerHorizontal)
            };
        }
        function getCombinedMax(maxPadding, chartArea, a, b) {
            return Math.max(maxPadding[a], chartArea[a]) + Math.max(maxPadding[b], chartArea[b]);
        }
        function updateMaxPadding(maxPadding, boxPadding) {
            maxPadding.top = Math.max(maxPadding.top, boxPadding.top);
            maxPadding.left = Math.max(maxPadding.left, boxPadding.left);
            maxPadding.bottom = Math.max(maxPadding.bottom, boxPadding.bottom);
            maxPadding.right = Math.max(maxPadding.right, boxPadding.right);
        }
        function updateDims(chartArea, params, layout, stacks) {
            const {pos, box} = layout;
            const maxPadding = chartArea.maxPadding;
            if (!helpers_segment_isObject(pos)) {
                if (layout.size) chartArea[pos] -= layout.size;
                const stack = stacks[layout.stack] || {
                    size: 0,
                    count: 1
                };
                stack.size = Math.max(stack.size, layout.horizontal ? box.height : box.width);
                layout.size = stack.size / stack.count;
                chartArea[pos] += layout.size;
            }
            if (box.getPadding) updateMaxPadding(maxPadding, box.getPadding());
            const newWidth = Math.max(0, params.outerWidth - getCombinedMax(maxPadding, chartArea, "left", "right"));
            const newHeight = Math.max(0, params.outerHeight - getCombinedMax(maxPadding, chartArea, "top", "bottom"));
            const widthChanged = newWidth !== chartArea.w;
            const heightChanged = newHeight !== chartArea.h;
            chartArea.w = newWidth;
            chartArea.h = newHeight;
            return layout.horizontal ? {
                same: widthChanged,
                other: heightChanged
            } : {
                same: heightChanged,
                other: widthChanged
            };
        }
        function handleMaxPadding(chartArea) {
            const maxPadding = chartArea.maxPadding;
            function updatePos(pos) {
                const change = Math.max(maxPadding[pos] - chartArea[pos], 0);
                chartArea[pos] += change;
                return change;
            }
            chartArea.y += updatePos("top");
            chartArea.x += updatePos("left");
            updatePos("right");
            updatePos("bottom");
        }
        function getMargins(horizontal, chartArea) {
            const maxPadding = chartArea.maxPadding;
            function marginForPositions(positions) {
                const margin = {
                    left: 0,
                    top: 0,
                    right: 0,
                    bottom: 0
                };
                positions.forEach((pos => {
                    margin[pos] = Math.max(chartArea[pos], maxPadding[pos]);
                }));
                return margin;
            }
            return horizontal ? marginForPositions([ "left", "right" ]) : marginForPositions([ "top", "bottom" ]);
        }
        function fitBoxes(boxes, chartArea, params, stacks) {
            const refitBoxes = [];
            let i, ilen, layout, box, refit, changed;
            for (i = 0, ilen = boxes.length, refit = 0; i < ilen; ++i) {
                layout = boxes[i];
                box = layout.box;
                box.update(layout.width || chartArea.w, layout.height || chartArea.h, getMargins(layout.horizontal, chartArea));
                const {same, other} = updateDims(chartArea, params, layout, stacks);
                refit |= same && refitBoxes.length;
                changed = changed || other;
                if (!box.fullSize) refitBoxes.push(layout);
            }
            return refit && fitBoxes(refitBoxes, chartArea, params, stacks) || changed;
        }
        function setBoxDims(box, left, top, width, height) {
            box.top = top;
            box.left = left;
            box.right = left + width;
            box.bottom = top + height;
            box.width = width;
            box.height = height;
        }
        function placeBoxes(boxes, chartArea, params, stacks) {
            const userPadding = params.padding;
            let {x, y} = chartArea;
            for (const layout of boxes) {
                const box = layout.box;
                const stack = stacks[layout.stack] || {
                    count: 1,
                    placed: 0,
                    weight: 1
                };
                const weight = layout.stackWeight / stack.weight || 1;
                if (layout.horizontal) {
                    const width = chartArea.w * weight;
                    const height = stack.size || box.height;
                    if (defined(stack.start)) y = stack.start;
                    if (box.fullSize) setBoxDims(box, userPadding.left, y, params.outerWidth - userPadding.right - userPadding.left, height); else setBoxDims(box, chartArea.left + stack.placed, y, width, height);
                    stack.start = y;
                    stack.placed += width;
                    y = box.bottom;
                } else {
                    const height = chartArea.h * weight;
                    const width = stack.size || box.width;
                    if (defined(stack.start)) x = stack.start;
                    if (box.fullSize) setBoxDims(box, x, userPadding.top, width, params.outerHeight - userPadding.bottom - userPadding.top); else setBoxDims(box, x, chartArea.top + stack.placed, width, height);
                    stack.start = x;
                    stack.placed += height;
                    x = box.right;
                }
            }
            chartArea.x = x;
            chartArea.y = y;
        }
        var layouts = {
            addBox(chart, item) {
                if (!chart.boxes) chart.boxes = [];
                item.fullSize = item.fullSize || false;
                item.position = item.position || "top";
                item.weight = item.weight || 0;
                item._layers = item._layers || function() {
                    return [ {
                        z: 0,
                        draw(chartArea) {
                            item.draw(chartArea);
                        }
                    } ];
                };
                chart.boxes.push(item);
            },
            removeBox(chart, layoutItem) {
                const index = chart.boxes ? chart.boxes.indexOf(layoutItem) : -1;
                if (index !== -1) chart.boxes.splice(index, 1);
            },
            configure(chart, item, options) {
                item.fullSize = options.fullSize;
                item.position = options.position;
                item.weight = options.weight;
            },
            update(chart, width, height, minPadding) {
                if (!chart) return;
                const padding = toPadding(chart.options.layout.padding);
                const availableWidth = Math.max(width - padding.width, 0);
                const availableHeight = Math.max(height - padding.height, 0);
                const boxes = buildLayoutBoxes(chart.boxes);
                const verticalBoxes = boxes.vertical;
                const horizontalBoxes = boxes.horizontal;
                each(chart.boxes, (box => {
                    if (typeof box.beforeLayout === "function") box.beforeLayout();
                }));
                const visibleVerticalBoxCount = verticalBoxes.reduce(((total, wrap) => wrap.box.options && wrap.box.options.display === false ? total : total + 1), 0) || 1;
                const params = Object.freeze({
                    outerWidth: width,
                    outerHeight: height,
                    padding,
                    availableWidth,
                    availableHeight,
                    vBoxMaxWidth: availableWidth / 2 / visibleVerticalBoxCount,
                    hBoxMaxHeight: availableHeight / 2
                });
                const maxPadding = Object.assign({}, padding);
                updateMaxPadding(maxPadding, toPadding(minPadding));
                const chartArea = Object.assign({
                    maxPadding,
                    w: availableWidth,
                    h: availableHeight,
                    x: padding.left,
                    y: padding.top
                }, padding);
                const stacks = setLayoutDims(verticalBoxes.concat(horizontalBoxes), params);
                fitBoxes(boxes.fullSize, chartArea, params, stacks);
                fitBoxes(verticalBoxes, chartArea, params, stacks);
                if (fitBoxes(horizontalBoxes, chartArea, params, stacks)) fitBoxes(verticalBoxes, chartArea, params, stacks);
                handleMaxPadding(chartArea);
                placeBoxes(boxes.leftAndTop, chartArea, params, stacks);
                chartArea.x += chartArea.w;
                chartArea.y += chartArea.h;
                placeBoxes(boxes.rightAndBottom, chartArea, params, stacks);
                chart.chartArea = {
                    left: chartArea.left,
                    top: chartArea.top,
                    right: chartArea.left + chartArea.w,
                    bottom: chartArea.top + chartArea.h,
                    height: chartArea.h,
                    width: chartArea.w
                };
                each(boxes.chartArea, (layout => {
                    const box = layout.box;
                    Object.assign(box, chart.chartArea);
                    box.update(chartArea.w, chartArea.h, {
                        left: 0,
                        top: 0,
                        right: 0,
                        bottom: 0
                    });
                }));
            }
        };
        class BasePlatform {
            acquireContext(canvas, aspectRatio) {}
            releaseContext(context) {
                return false;
            }
            addEventListener(chart, type, listener) {}
            removeEventListener(chart, type, listener) {}
            getDevicePixelRatio() {
                return 1;
            }
            getMaximumSize(element, width, height, aspectRatio) {
                width = Math.max(0, width || element.width);
                height = height || element.height;
                return {
                    width,
                    height: Math.max(0, aspectRatio ? Math.floor(width / aspectRatio) : height)
                };
            }
            isAttached(canvas) {
                return true;
            }
            updateConfig(config) {}
        }
        class BasicPlatform extends BasePlatform {
            acquireContext(item) {
                return item && item.getContext && item.getContext("2d") || null;
            }
            updateConfig(config) {
                config.options.animation = false;
            }
        }
        const EXPANDO_KEY = "$chartjs";
        const EVENT_TYPES = {
            touchstart: "mousedown",
            touchmove: "mousemove",
            touchend: "mouseup",
            pointerenter: "mouseenter",
            pointerdown: "mousedown",
            pointermove: "mousemove",
            pointerup: "mouseup",
            pointerleave: "mouseout",
            pointerout: "mouseout"
        };
        const isNullOrEmpty = value => value === null || value === "";
        function initCanvas(canvas, aspectRatio) {
            const style = canvas.style;
            const renderHeight = canvas.getAttribute("height");
            const renderWidth = canvas.getAttribute("width");
            canvas[EXPANDO_KEY] = {
                initial: {
                    height: renderHeight,
                    width: renderWidth,
                    style: {
                        display: style.display,
                        height: style.height,
                        width: style.width
                    }
                }
            };
            style.display = style.display || "block";
            style.boxSizing = style.boxSizing || "border-box";
            if (isNullOrEmpty(renderWidth)) {
                const displayWidth = readUsedSize(canvas, "width");
                if (displayWidth !== void 0) canvas.width = displayWidth;
            }
            if (isNullOrEmpty(renderHeight)) if (canvas.style.height === "") canvas.height = canvas.width / (aspectRatio || 2); else {
                const displayHeight = readUsedSize(canvas, "height");
                if (displayHeight !== void 0) canvas.height = displayHeight;
            }
            return canvas;
        }
        const eventListenerOptions = supportsEventListenerOptions ? {
            passive: true
        } : false;
        function addListener(node, type, listener) {
            if (node) node.addEventListener(type, listener, eventListenerOptions);
        }
        function removeListener(chart, type, listener) {
            if (chart && chart.canvas) chart.canvas.removeEventListener(type, listener, eventListenerOptions);
        }
        function fromNativeEvent(event, chart) {
            const type = EVENT_TYPES[event.type] || event.type;
            const {x, y} = getRelativePosition(event, chart);
            return {
                type,
                chart,
                native: event,
                x: x !== void 0 ? x : null,
                y: y !== void 0 ? y : null
            };
        }
        function nodeListContains(nodeList, canvas) {
            for (const node of nodeList) if (node === canvas || node.contains(canvas)) return true;
        }
        function createAttachObserver(chart, type, listener) {
            const canvas = chart.canvas;
            const observer = new MutationObserver((entries => {
                let trigger = false;
                for (const entry of entries) {
                    trigger = trigger || nodeListContains(entry.addedNodes, canvas);
                    trigger = trigger && !nodeListContains(entry.removedNodes, canvas);
                }
                if (trigger) listener();
            }));
            observer.observe(document, {
                childList: true,
                subtree: true
            });
            return observer;
        }
        function createDetachObserver(chart, type, listener) {
            const canvas = chart.canvas;
            const observer = new MutationObserver((entries => {
                let trigger = false;
                for (const entry of entries) {
                    trigger = trigger || nodeListContains(entry.removedNodes, canvas);
                    trigger = trigger && !nodeListContains(entry.addedNodes, canvas);
                }
                if (trigger) listener();
            }));
            observer.observe(document, {
                childList: true,
                subtree: true
            });
            return observer;
        }
        const drpListeningCharts = new Map;
        let oldDevicePixelRatio = 0;
        function onWindowResize() {
            const dpr = window.devicePixelRatio;
            if (dpr === oldDevicePixelRatio) return;
            oldDevicePixelRatio = dpr;
            drpListeningCharts.forEach(((resize, chart) => {
                if (chart.currentDevicePixelRatio !== dpr) resize();
            }));
        }
        function listenDevicePixelRatioChanges(chart, resize) {
            if (!drpListeningCharts.size) window.addEventListener("resize", onWindowResize);
            drpListeningCharts.set(chart, resize);
        }
        function unlistenDevicePixelRatioChanges(chart) {
            drpListeningCharts.delete(chart);
            if (!drpListeningCharts.size) window.removeEventListener("resize", onWindowResize);
        }
        function createResizeObserver(chart, type, listener) {
            const canvas = chart.canvas;
            const container = canvas && _getParentNode(canvas);
            if (!container) return;
            const resize = throttled(((width, height) => {
                const w = container.clientWidth;
                listener(width, height);
                if (w < container.clientWidth) listener();
            }), window);
            const observer = new ResizeObserver((entries => {
                const entry = entries[0];
                const width = entry.contentRect.width;
                const height = entry.contentRect.height;
                if (width === 0 && height === 0) return;
                resize(width, height);
            }));
            observer.observe(container);
            listenDevicePixelRatioChanges(chart, resize);
            return observer;
        }
        function releaseObserver(chart, type, observer) {
            if (observer) observer.disconnect();
            if (type === "resize") unlistenDevicePixelRatioChanges(chart);
        }
        function createProxyAndListen(chart, type, listener) {
            const canvas = chart.canvas;
            const proxy = throttled((event => {
                if (chart.ctx !== null) listener(fromNativeEvent(event, chart));
            }), chart);
            addListener(canvas, type, proxy);
            return proxy;
        }
        class DomPlatform extends BasePlatform {
            acquireContext(canvas, aspectRatio) {
                const context = canvas && canvas.getContext && canvas.getContext("2d");
                if (context && context.canvas === canvas) {
                    initCanvas(canvas, aspectRatio);
                    return context;
                }
                return null;
            }
            releaseContext(context) {
                const canvas = context.canvas;
                if (!canvas[EXPANDO_KEY]) return false;
                const initial = canvas[EXPANDO_KEY].initial;
                [ "height", "width" ].forEach((prop => {
                    const value = initial[prop];
                    if (isNullOrUndef(value)) canvas.removeAttribute(prop); else canvas.setAttribute(prop, value);
                }));
                const style = initial.style || {};
                Object.keys(style).forEach((key => {
                    canvas.style[key] = style[key];
                }));
                canvas.width = canvas.width;
                delete canvas[EXPANDO_KEY];
                return true;
            }
            addEventListener(chart, type, listener) {
                this.removeEventListener(chart, type);
                const proxies = chart.$proxies || (chart.$proxies = {});
                const handlers = {
                    attach: createAttachObserver,
                    detach: createDetachObserver,
                    resize: createResizeObserver
                };
                const handler = handlers[type] || createProxyAndListen;
                proxies[type] = handler(chart, type, listener);
            }
            removeEventListener(chart, type) {
                const proxies = chart.$proxies || (chart.$proxies = {});
                const proxy = proxies[type];
                if (!proxy) return;
                const handlers = {
                    attach: releaseObserver,
                    detach: releaseObserver,
                    resize: releaseObserver
                };
                const handler = handlers[type] || removeListener;
                handler(chart, type, proxy);
                proxies[type] = void 0;
            }
            getDevicePixelRatio() {
                return window.devicePixelRatio;
            }
            getMaximumSize(canvas, width, height, aspectRatio) {
                return getMaximumSize(canvas, width, height, aspectRatio);
            }
            isAttached(canvas) {
                const container = canvas && _getParentNode(canvas);
                return !!(container && container.isConnected);
            }
        }
        function _detectPlatform(canvas) {
            if (!_isDomSupported() || typeof OffscreenCanvas !== "undefined" && canvas instanceof OffscreenCanvas) return BasicPlatform;
            return DomPlatform;
        }
        class chart_Element {
            static defaults={};
            static defaultRoutes=void 0;
            x;
            y;
            active=false;
            options;
            $animations;
            tooltipPosition(useFinalPosition) {
                const {x, y} = this.getProps([ "x", "y" ], useFinalPosition);
                return {
                    x,
                    y
                };
            }
            hasValue() {
                return isNumber(this.x) && isNumber(this.y);
            }
            getProps(props, final) {
                const anims = this.$animations;
                if (!final || !anims) return this;
                const ret = {};
                props.forEach((prop => {
                    ret[prop] = anims[prop] && anims[prop].active() ? anims[prop]._to : this[prop];
                }));
                return ret;
            }
        }
        function autoSkip(scale, ticks) {
            const tickOpts = scale.options.ticks;
            const determinedMaxTicks = determineMaxTicks(scale);
            const ticksLimit = Math.min(tickOpts.maxTicksLimit || determinedMaxTicks, determinedMaxTicks);
            const majorIndices = tickOpts.major.enabled ? getMajorIndices(ticks) : [];
            const numMajorIndices = majorIndices.length;
            const first = majorIndices[0];
            const last = majorIndices[numMajorIndices - 1];
            const newTicks = [];
            if (numMajorIndices > ticksLimit) {
                skipMajors(ticks, newTicks, majorIndices, numMajorIndices / ticksLimit);
                return newTicks;
            }
            const spacing = calculateSpacing(majorIndices, ticks, ticksLimit);
            if (numMajorIndices > 0) {
                let i, ilen;
                const avgMajorSpacing = numMajorIndices > 1 ? Math.round((last - first) / (numMajorIndices - 1)) : null;
                skip(ticks, newTicks, spacing, isNullOrUndef(avgMajorSpacing) ? 0 : first - avgMajorSpacing, first);
                for (i = 0, ilen = numMajorIndices - 1; i < ilen; i++) skip(ticks, newTicks, spacing, majorIndices[i], majorIndices[i + 1]);
                skip(ticks, newTicks, spacing, last, isNullOrUndef(avgMajorSpacing) ? ticks.length : last + avgMajorSpacing);
                return newTicks;
            }
            skip(ticks, newTicks, spacing);
            return newTicks;
        }
        function determineMaxTicks(scale) {
            const offset = scale.options.offset;
            const tickLength = scale._tickSize();
            const maxScale = scale._length / tickLength + (offset ? 0 : 1);
            const maxChart = scale._maxLength / tickLength;
            return Math.floor(Math.min(maxScale, maxChart));
        }
        function calculateSpacing(majorIndices, ticks, ticksLimit) {
            const evenMajorSpacing = getEvenSpacing(majorIndices);
            const spacing = ticks.length / ticksLimit;
            if (!evenMajorSpacing) return Math.max(spacing, 1);
            const factors = _factorize(evenMajorSpacing);
            for (let i = 0, ilen = factors.length - 1; i < ilen; i++) {
                const factor = factors[i];
                if (factor > spacing) return factor;
            }
            return Math.max(spacing, 1);
        }
        function getMajorIndices(ticks) {
            const result = [];
            let i, ilen;
            for (i = 0, ilen = ticks.length; i < ilen; i++) if (ticks[i].major) result.push(i);
            return result;
        }
        function skipMajors(ticks, newTicks, majorIndices, spacing) {
            let count = 0;
            let next = majorIndices[0];
            let i;
            spacing = Math.ceil(spacing);
            for (i = 0; i < ticks.length; i++) if (i === next) {
                newTicks.push(ticks[i]);
                count++;
                next = majorIndices[count * spacing];
            }
        }
        function skip(ticks, newTicks, spacing, majorStart, majorEnd) {
            const start = valueOrDefault(majorStart, 0);
            const end = Math.min(valueOrDefault(majorEnd, ticks.length), ticks.length);
            let count = 0;
            let length, i, next;
            spacing = Math.ceil(spacing);
            if (majorEnd) {
                length = majorEnd - majorStart;
                spacing = length / Math.floor(length / spacing);
            }
            next = start;
            while (next < 0) {
                count++;
                next = Math.round(start + count * spacing);
            }
            for (i = Math.max(start, 0); i < end; i++) if (i === next) {
                newTicks.push(ticks[i]);
                count++;
                next = Math.round(start + count * spacing);
            }
        }
        function getEvenSpacing(arr) {
            const len = arr.length;
            let i, diff;
            if (len < 2) return false;
            for (diff = arr[0], i = 1; i < len; ++i) if (arr[i] - arr[i - 1] !== diff) return false;
            return diff;
        }
        const reverseAlign = align => align === "left" ? "right" : align === "right" ? "left" : align;
        const offsetFromEdge = (scale, edge, offset) => edge === "top" || edge === "left" ? scale[edge] + offset : scale[edge] - offset;
        const getTicksLimit = (ticksLength, maxTicksLimit) => Math.min(maxTicksLimit || ticksLength, ticksLength);
        function sample(arr, numItems) {
            const result = [];
            const increment = arr.length / numItems;
            const len = arr.length;
            let i = 0;
            for (;i < len; i += increment) result.push(arr[Math.floor(i)]);
            return result;
        }
        function getPixelForGridLine(scale, index, offsetGridLines) {
            const length = scale.ticks.length;
            const validIndex = Math.min(index, length - 1);
            const start = scale._startPixel;
            const end = scale._endPixel;
            const epsilon = 1e-6;
            let lineValue = scale.getPixelForTick(validIndex);
            let offset;
            if (offsetGridLines) {
                if (length === 1) offset = Math.max(lineValue - start, end - lineValue); else if (index === 0) offset = (scale.getPixelForTick(1) - lineValue) / 2; else offset = (lineValue - scale.getPixelForTick(validIndex - 1)) / 2;
                lineValue += validIndex < index ? offset : -offset;
                if (lineValue < start - epsilon || lineValue > end + epsilon) return;
            }
            return lineValue;
        }
        function garbageCollect(caches, length) {
            each(caches, (cache => {
                const gc = cache.gc;
                const gcLen = gc.length / 2;
                let i;
                if (gcLen > length) {
                    for (i = 0; i < gcLen; ++i) delete cache.data[gc[i]];
                    gc.splice(0, gcLen);
                }
            }));
        }
        function getTickMarkLength(options) {
            return options.drawTicks ? options.tickLength : 0;
        }
        function getTitleHeight(options, fallback) {
            if (!options.display) return 0;
            const font = toFont(options.font, fallback);
            const padding = toPadding(options.padding);
            const lines = isArray(options.text) ? options.text.length : 1;
            return lines * font.lineHeight + padding.height;
        }
        function createScaleContext(parent, scale) {
            return createContext(parent, {
                scale,
                type: "scale"
            });
        }
        function createTickContext(parent, index, tick) {
            return createContext(parent, {
                tick,
                index,
                type: "tick"
            });
        }
        function titleAlign(align, position, reverse) {
            let ret = _toLeftRightCenter(align);
            if (reverse && position !== "right" || !reverse && position === "right") ret = reverseAlign(ret);
            return ret;
        }
        function titleArgs(scale, offset, position, align) {
            const {top, left, bottom, right, chart} = scale;
            const {chartArea, scales} = chart;
            let rotation = 0;
            let maxWidth, titleX, titleY;
            const height = bottom - top;
            const width = right - left;
            if (scale.isHorizontal()) {
                titleX = _alignStartEnd(align, left, right);
                if (helpers_segment_isObject(position)) {
                    const positionAxisID = Object.keys(position)[0];
                    const value = position[positionAxisID];
                    titleY = scales[positionAxisID].getPixelForValue(value) + height - offset;
                } else if (position === "center") titleY = (chartArea.bottom + chartArea.top) / 2 + height - offset; else titleY = offsetFromEdge(scale, position, offset);
                maxWidth = right - left;
            } else {
                if (helpers_segment_isObject(position)) {
                    const positionAxisID = Object.keys(position)[0];
                    const value = position[positionAxisID];
                    titleX = scales[positionAxisID].getPixelForValue(value) - width + offset;
                } else if (position === "center") titleX = (chartArea.left + chartArea.right) / 2 - width + offset; else titleX = offsetFromEdge(scale, position, offset);
                titleY = _alignStartEnd(align, bottom, top);
                rotation = position === "left" ? -HALF_PI : HALF_PI;
            }
            return {
                titleX,
                titleY,
                maxWidth,
                rotation
            };
        }
        class Scale extends chart_Element {
            constructor(cfg) {
                super();
                this.id = cfg.id;
                this.type = cfg.type;
                this.options = void 0;
                this.ctx = cfg.ctx;
                this.chart = cfg.chart;
                this.top = void 0;
                this.bottom = void 0;
                this.left = void 0;
                this.right = void 0;
                this.width = void 0;
                this.height = void 0;
                this._margins = {
                    left: 0,
                    right: 0,
                    top: 0,
                    bottom: 0
                };
                this.maxWidth = void 0;
                this.maxHeight = void 0;
                this.paddingTop = void 0;
                this.paddingBottom = void 0;
                this.paddingLeft = void 0;
                this.paddingRight = void 0;
                this.axis = void 0;
                this.labelRotation = void 0;
                this.min = void 0;
                this.max = void 0;
                this._range = void 0;
                this.ticks = [];
                this._gridLineItems = null;
                this._labelItems = null;
                this._labelSizes = null;
                this._length = 0;
                this._maxLength = 0;
                this._longestTextCache = {};
                this._startPixel = void 0;
                this._endPixel = void 0;
                this._reversePixels = false;
                this._userMax = void 0;
                this._userMin = void 0;
                this._suggestedMax = void 0;
                this._suggestedMin = void 0;
                this._ticksLength = 0;
                this._borderValue = 0;
                this._cache = {};
                this._dataLimitsCached = false;
                this.$context = void 0;
            }
            init(options) {
                this.options = options.setContext(this.getContext());
                this.axis = options.axis;
                this._userMin = this.parse(options.min);
                this._userMax = this.parse(options.max);
                this._suggestedMin = this.parse(options.suggestedMin);
                this._suggestedMax = this.parse(options.suggestedMax);
            }
            parse(raw, index) {
                return raw;
            }
            getUserBounds() {
                let {_userMin, _userMax, _suggestedMin, _suggestedMax} = this;
                _userMin = finiteOrDefault(_userMin, Number.POSITIVE_INFINITY);
                _userMax = finiteOrDefault(_userMax, Number.NEGATIVE_INFINITY);
                _suggestedMin = finiteOrDefault(_suggestedMin, Number.POSITIVE_INFINITY);
                _suggestedMax = finiteOrDefault(_suggestedMax, Number.NEGATIVE_INFINITY);
                return {
                    min: finiteOrDefault(_userMin, _suggestedMin),
                    max: finiteOrDefault(_userMax, _suggestedMax),
                    minDefined: isNumberFinite(_userMin),
                    maxDefined: isNumberFinite(_userMax)
                };
            }
            getMinMax(canStack) {
                let {min, max, minDefined, maxDefined} = this.getUserBounds();
                let range;
                if (minDefined && maxDefined) return {
                    min,
                    max
                };
                const metas = this.getMatchingVisibleMetas();
                for (let i = 0, ilen = metas.length; i < ilen; ++i) {
                    range = metas[i].controller.getMinMax(this, canStack);
                    if (!minDefined) min = Math.min(min, range.min);
                    if (!maxDefined) max = Math.max(max, range.max);
                }
                min = maxDefined && min > max ? max : min;
                max = minDefined && min > max ? min : max;
                return {
                    min: finiteOrDefault(min, finiteOrDefault(max, min)),
                    max: finiteOrDefault(max, finiteOrDefault(min, max))
                };
            }
            getPadding() {
                return {
                    left: this.paddingLeft || 0,
                    top: this.paddingTop || 0,
                    right: this.paddingRight || 0,
                    bottom: this.paddingBottom || 0
                };
            }
            getTicks() {
                return this.ticks;
            }
            getLabels() {
                const data = this.chart.data;
                return this.options.labels || (this.isHorizontal() ? data.xLabels : data.yLabels) || data.labels || [];
            }
            getLabelItems(chartArea = this.chart.chartArea) {
                const items = this._labelItems || (this._labelItems = this._computeLabelItems(chartArea));
                return items;
            }
            beforeLayout() {
                this._cache = {};
                this._dataLimitsCached = false;
            }
            beforeUpdate() {
                callback(this.options.beforeUpdate, [ this ]);
            }
            update(maxWidth, maxHeight, margins) {
                const {beginAtZero, grace, ticks: tickOpts} = this.options;
                const sampleSize = tickOpts.sampleSize;
                this.beforeUpdate();
                this.maxWidth = maxWidth;
                this.maxHeight = maxHeight;
                this._margins = margins = Object.assign({
                    left: 0,
                    right: 0,
                    top: 0,
                    bottom: 0
                }, margins);
                this.ticks = null;
                this._labelSizes = null;
                this._gridLineItems = null;
                this._labelItems = null;
                this.beforeSetDimensions();
                this.setDimensions();
                this.afterSetDimensions();
                this._maxLength = this.isHorizontal() ? this.width + margins.left + margins.right : this.height + margins.top + margins.bottom;
                if (!this._dataLimitsCached) {
                    this.beforeDataLimits();
                    this.determineDataLimits();
                    this.afterDataLimits();
                    this._range = _addGrace(this, grace, beginAtZero);
                    this._dataLimitsCached = true;
                }
                this.beforeBuildTicks();
                this.ticks = this.buildTicks() || [];
                this.afterBuildTicks();
                const samplingEnabled = sampleSize < this.ticks.length;
                this._convertTicksToLabels(samplingEnabled ? sample(this.ticks, sampleSize) : this.ticks);
                this.configure();
                this.beforeCalculateLabelRotation();
                this.calculateLabelRotation();
                this.afterCalculateLabelRotation();
                if (tickOpts.display && (tickOpts.autoSkip || tickOpts.source === "auto")) {
                    this.ticks = autoSkip(this, this.ticks);
                    this._labelSizes = null;
                    this.afterAutoSkip();
                }
                if (samplingEnabled) this._convertTicksToLabels(this.ticks);
                this.beforeFit();
                this.fit();
                this.afterFit();
                this.afterUpdate();
            }
            configure() {
                let reversePixels = this.options.reverse;
                let startPixel, endPixel;
                if (this.isHorizontal()) {
                    startPixel = this.left;
                    endPixel = this.right;
                } else {
                    startPixel = this.top;
                    endPixel = this.bottom;
                    reversePixels = !reversePixels;
                }
                this._startPixel = startPixel;
                this._endPixel = endPixel;
                this._reversePixels = reversePixels;
                this._length = endPixel - startPixel;
                this._alignToPixels = this.options.alignToPixels;
            }
            afterUpdate() {
                callback(this.options.afterUpdate, [ this ]);
            }
            beforeSetDimensions() {
                callback(this.options.beforeSetDimensions, [ this ]);
            }
            setDimensions() {
                if (this.isHorizontal()) {
                    this.width = this.maxWidth;
                    this.left = 0;
                    this.right = this.width;
                } else {
                    this.height = this.maxHeight;
                    this.top = 0;
                    this.bottom = this.height;
                }
                this.paddingLeft = 0;
                this.paddingTop = 0;
                this.paddingRight = 0;
                this.paddingBottom = 0;
            }
            afterSetDimensions() {
                callback(this.options.afterSetDimensions, [ this ]);
            }
            _callHooks(name) {
                this.chart.notifyPlugins(name, this.getContext());
                callback(this.options[name], [ this ]);
            }
            beforeDataLimits() {
                this._callHooks("beforeDataLimits");
            }
            determineDataLimits() {}
            afterDataLimits() {
                this._callHooks("afterDataLimits");
            }
            beforeBuildTicks() {
                this._callHooks("beforeBuildTicks");
            }
            buildTicks() {
                return [];
            }
            afterBuildTicks() {
                this._callHooks("afterBuildTicks");
            }
            beforeTickToLabelConversion() {
                callback(this.options.beforeTickToLabelConversion, [ this ]);
            }
            generateTickLabels(ticks) {
                const tickOpts = this.options.ticks;
                let i, ilen, tick;
                for (i = 0, ilen = ticks.length; i < ilen; i++) {
                    tick = ticks[i];
                    tick.label = callback(tickOpts.callback, [ tick.value, i, ticks ], this);
                }
            }
            afterTickToLabelConversion() {
                callback(this.options.afterTickToLabelConversion, [ this ]);
            }
            beforeCalculateLabelRotation() {
                callback(this.options.beforeCalculateLabelRotation, [ this ]);
            }
            calculateLabelRotation() {
                const options = this.options;
                const tickOpts = options.ticks;
                const numTicks = getTicksLimit(this.ticks.length, options.ticks.maxTicksLimit);
                const minRotation = tickOpts.minRotation || 0;
                const maxRotation = tickOpts.maxRotation;
                let labelRotation = minRotation;
                let tickWidth, maxHeight, maxLabelDiagonal;
                if (!this._isVisible() || !tickOpts.display || minRotation >= maxRotation || numTicks <= 1 || !this.isHorizontal()) {
                    this.labelRotation = minRotation;
                    return;
                }
                const labelSizes = this._getLabelSizes();
                const maxLabelWidth = labelSizes.widest.width;
                const maxLabelHeight = labelSizes.highest.height;
                const maxWidth = _limitValue(this.chart.width - maxLabelWidth, 0, this.maxWidth);
                tickWidth = options.offset ? this.maxWidth / numTicks : maxWidth / (numTicks - 1);
                if (maxLabelWidth + 6 > tickWidth) {
                    tickWidth = maxWidth / (numTicks - (options.offset ? .5 : 1));
                    maxHeight = this.maxHeight - getTickMarkLength(options.grid) - tickOpts.padding - getTitleHeight(options.title, this.chart.options.font);
                    maxLabelDiagonal = Math.sqrt(maxLabelWidth * maxLabelWidth + maxLabelHeight * maxLabelHeight);
                    labelRotation = toDegrees(Math.min(Math.asin(_limitValue((labelSizes.highest.height + 6) / tickWidth, -1, 1)), Math.asin(_limitValue(maxHeight / maxLabelDiagonal, -1, 1)) - Math.asin(_limitValue(maxLabelHeight / maxLabelDiagonal, -1, 1))));
                    labelRotation = Math.max(minRotation, Math.min(maxRotation, labelRotation));
                }
                this.labelRotation = labelRotation;
            }
            afterCalculateLabelRotation() {
                callback(this.options.afterCalculateLabelRotation, [ this ]);
            }
            afterAutoSkip() {}
            beforeFit() {
                callback(this.options.beforeFit, [ this ]);
            }
            fit() {
                const minSize = {
                    width: 0,
                    height: 0
                };
                const {chart, options: {ticks: tickOpts, title: titleOpts, grid: gridOpts}} = this;
                const display = this._isVisible();
                const isHorizontal = this.isHorizontal();
                if (display) {
                    const titleHeight = getTitleHeight(titleOpts, chart.options.font);
                    if (isHorizontal) {
                        minSize.width = this.maxWidth;
                        minSize.height = getTickMarkLength(gridOpts) + titleHeight;
                    } else {
                        minSize.height = this.maxHeight;
                        minSize.width = getTickMarkLength(gridOpts) + titleHeight;
                    }
                    if (tickOpts.display && this.ticks.length) {
                        const {first, last, widest, highest} = this._getLabelSizes();
                        const tickPadding = tickOpts.padding * 2;
                        const angleRadians = toRadians(this.labelRotation);
                        const cos = Math.cos(angleRadians);
                        const sin = Math.sin(angleRadians);
                        if (isHorizontal) {
                            const labelHeight = tickOpts.mirror ? 0 : sin * widest.width + cos * highest.height;
                            minSize.height = Math.min(this.maxHeight, minSize.height + labelHeight + tickPadding);
                        } else {
                            const labelWidth = tickOpts.mirror ? 0 : cos * widest.width + sin * highest.height;
                            minSize.width = Math.min(this.maxWidth, minSize.width + labelWidth + tickPadding);
                        }
                        this._calculatePadding(first, last, sin, cos);
                    }
                }
                this._handleMargins();
                if (isHorizontal) {
                    this.width = this._length = chart.width - this._margins.left - this._margins.right;
                    this.height = minSize.height;
                } else {
                    this.width = minSize.width;
                    this.height = this._length = chart.height - this._margins.top - this._margins.bottom;
                }
            }
            _calculatePadding(first, last, sin, cos) {
                const {ticks: {align, padding}, position} = this.options;
                const isRotated = this.labelRotation !== 0;
                const labelsBelowTicks = position !== "top" && this.axis === "x";
                if (this.isHorizontal()) {
                    const offsetLeft = this.getPixelForTick(0) - this.left;
                    const offsetRight = this.right - this.getPixelForTick(this.ticks.length - 1);
                    let paddingLeft = 0;
                    let paddingRight = 0;
                    if (isRotated) if (labelsBelowTicks) {
                        paddingLeft = cos * first.width;
                        paddingRight = sin * last.height;
                    } else {
                        paddingLeft = sin * first.height;
                        paddingRight = cos * last.width;
                    } else if (align === "start") paddingRight = last.width; else if (align === "end") paddingLeft = first.width; else if (align !== "inner") {
                        paddingLeft = first.width / 2;
                        paddingRight = last.width / 2;
                    }
                    this.paddingLeft = Math.max((paddingLeft - offsetLeft + padding) * this.width / (this.width - offsetLeft), 0);
                    this.paddingRight = Math.max((paddingRight - offsetRight + padding) * this.width / (this.width - offsetRight), 0);
                } else {
                    let paddingTop = last.height / 2;
                    let paddingBottom = first.height / 2;
                    if (align === "start") {
                        paddingTop = 0;
                        paddingBottom = first.height;
                    } else if (align === "end") {
                        paddingTop = last.height;
                        paddingBottom = 0;
                    }
                    this.paddingTop = paddingTop + padding;
                    this.paddingBottom = paddingBottom + padding;
                }
            }
            _handleMargins() {
                if (this._margins) {
                    this._margins.left = Math.max(this.paddingLeft, this._margins.left);
                    this._margins.top = Math.max(this.paddingTop, this._margins.top);
                    this._margins.right = Math.max(this.paddingRight, this._margins.right);
                    this._margins.bottom = Math.max(this.paddingBottom, this._margins.bottom);
                }
            }
            afterFit() {
                callback(this.options.afterFit, [ this ]);
            }
            isHorizontal() {
                const {axis, position} = this.options;
                return position === "top" || position === "bottom" || axis === "x";
            }
            isFullSize() {
                return this.options.fullSize;
            }
            _convertTicksToLabels(ticks) {
                this.beforeTickToLabelConversion();
                this.generateTickLabels(ticks);
                let i, ilen;
                for (i = 0, ilen = ticks.length; i < ilen; i++) if (isNullOrUndef(ticks[i].label)) {
                    ticks.splice(i, 1);
                    ilen--;
                    i--;
                }
                this.afterTickToLabelConversion();
            }
            _getLabelSizes() {
                let labelSizes = this._labelSizes;
                if (!labelSizes) {
                    const sampleSize = this.options.ticks.sampleSize;
                    let ticks = this.ticks;
                    if (sampleSize < ticks.length) ticks = sample(ticks, sampleSize);
                    this._labelSizes = labelSizes = this._computeLabelSizes(ticks, ticks.length, this.options.ticks.maxTicksLimit);
                }
                return labelSizes;
            }
            _computeLabelSizes(ticks, length, maxTicksLimit) {
                const {ctx, _longestTextCache: caches} = this;
                const widths = [];
                const heights = [];
                const increment = Math.floor(length / getTicksLimit(length, maxTicksLimit));
                let widestLabelSize = 0;
                let highestLabelSize = 0;
                let i, j, jlen, label, tickFont, fontString, cache, lineHeight, width, height, nestedLabel;
                for (i = 0; i < length; i += increment) {
                    label = ticks[i].label;
                    tickFont = this._resolveTickFontOptions(i);
                    ctx.font = fontString = tickFont.string;
                    cache = caches[fontString] = caches[fontString] || {
                        data: {},
                        gc: []
                    };
                    lineHeight = tickFont.lineHeight;
                    width = height = 0;
                    if (!isNullOrUndef(label) && !isArray(label)) {
                        width = _measureText(ctx, cache.data, cache.gc, width, label);
                        height = lineHeight;
                    } else if (isArray(label)) for (j = 0, jlen = label.length; j < jlen; ++j) {
                        nestedLabel = label[j];
                        if (!isNullOrUndef(nestedLabel) && !isArray(nestedLabel)) {
                            width = _measureText(ctx, cache.data, cache.gc, width, nestedLabel);
                            height += lineHeight;
                        }
                    }
                    widths.push(width);
                    heights.push(height);
                    widestLabelSize = Math.max(width, widestLabelSize);
                    highestLabelSize = Math.max(height, highestLabelSize);
                }
                garbageCollect(caches, length);
                const widest = widths.indexOf(widestLabelSize);
                const highest = heights.indexOf(highestLabelSize);
                const valueAt = idx => ({
                    width: widths[idx] || 0,
                    height: heights[idx] || 0
                });
                return {
                    first: valueAt(0),
                    last: valueAt(length - 1),
                    widest: valueAt(widest),
                    highest: valueAt(highest),
                    widths,
                    heights
                };
            }
            getLabelForValue(value) {
                return value;
            }
            getPixelForValue(value, index) {
                return NaN;
            }
            getValueForPixel(pixel) {}
            getPixelForTick(index) {
                const ticks = this.ticks;
                if (index < 0 || index > ticks.length - 1) return null;
                return this.getPixelForValue(ticks[index].value);
            }
            getPixelForDecimal(decimal) {
                if (this._reversePixels) decimal = 1 - decimal;
                const pixel = this._startPixel + decimal * this._length;
                return _int16Range(this._alignToPixels ? _alignPixel(this.chart, pixel, 0) : pixel);
            }
            getDecimalForPixel(pixel) {
                const decimal = (pixel - this._startPixel) / this._length;
                return this._reversePixels ? 1 - decimal : decimal;
            }
            getBasePixel() {
                return this.getPixelForValue(this.getBaseValue());
            }
            getBaseValue() {
                const {min, max} = this;
                return min < 0 && max < 0 ? max : min > 0 && max > 0 ? min : 0;
            }
            getContext(index) {
                const ticks = this.ticks || [];
                if (index >= 0 && index < ticks.length) {
                    const tick = ticks[index];
                    return tick.$context || (tick.$context = createTickContext(this.getContext(), index, tick));
                }
                return this.$context || (this.$context = createScaleContext(this.chart.getContext(), this));
            }
            _tickSize() {
                const optionTicks = this.options.ticks;
                const rot = toRadians(this.labelRotation);
                const cos = Math.abs(Math.cos(rot));
                const sin = Math.abs(Math.sin(rot));
                const labelSizes = this._getLabelSizes();
                const padding = optionTicks.autoSkipPadding || 0;
                const w = labelSizes ? labelSizes.widest.width + padding : 0;
                const h = labelSizes ? labelSizes.highest.height + padding : 0;
                return this.isHorizontal() ? h * cos > w * sin ? w / cos : h / sin : h * sin < w * cos ? h / cos : w / sin;
            }
            _isVisible() {
                const display = this.options.display;
                if (display !== "auto") return !!display;
                return this.getMatchingVisibleMetas().length > 0;
            }
            _computeGridLineItems(chartArea) {
                const axis = this.axis;
                const chart = this.chart;
                const options = this.options;
                const {grid, position, border} = options;
                const offset = grid.offset;
                const isHorizontal = this.isHorizontal();
                const ticks = this.ticks;
                const ticksLength = ticks.length + (offset ? 1 : 0);
                const tl = getTickMarkLength(grid);
                const items = [];
                const borderOpts = border.setContext(this.getContext());
                const axisWidth = borderOpts.display ? borderOpts.width : 0;
                const axisHalfWidth = axisWidth / 2;
                const alignBorderValue = function(pixel) {
                    return _alignPixel(chart, pixel, axisWidth);
                };
                let borderValue, i, lineValue, alignedLineValue;
                let tx1, ty1, tx2, ty2, x1, y1, x2, y2;
                if (position === "top") {
                    borderValue = alignBorderValue(this.bottom);
                    ty1 = this.bottom - tl;
                    ty2 = borderValue - axisHalfWidth;
                    y1 = alignBorderValue(chartArea.top) + axisHalfWidth;
                    y2 = chartArea.bottom;
                } else if (position === "bottom") {
                    borderValue = alignBorderValue(this.top);
                    y1 = chartArea.top;
                    y2 = alignBorderValue(chartArea.bottom) - axisHalfWidth;
                    ty1 = borderValue + axisHalfWidth;
                    ty2 = this.top + tl;
                } else if (position === "left") {
                    borderValue = alignBorderValue(this.right);
                    tx1 = this.right - tl;
                    tx2 = borderValue - axisHalfWidth;
                    x1 = alignBorderValue(chartArea.left) + axisHalfWidth;
                    x2 = chartArea.right;
                } else if (position === "right") {
                    borderValue = alignBorderValue(this.left);
                    x1 = chartArea.left;
                    x2 = alignBorderValue(chartArea.right) - axisHalfWidth;
                    tx1 = borderValue + axisHalfWidth;
                    tx2 = this.left + tl;
                } else if (axis === "x") {
                    if (position === "center") borderValue = alignBorderValue((chartArea.top + chartArea.bottom) / 2 + .5); else if (helpers_segment_isObject(position)) {
                        const positionAxisID = Object.keys(position)[0];
                        const value = position[positionAxisID];
                        borderValue = alignBorderValue(this.chart.scales[positionAxisID].getPixelForValue(value));
                    }
                    y1 = chartArea.top;
                    y2 = chartArea.bottom;
                    ty1 = borderValue + axisHalfWidth;
                    ty2 = ty1 + tl;
                } else if (axis === "y") {
                    if (position === "center") borderValue = alignBorderValue((chartArea.left + chartArea.right) / 2); else if (helpers_segment_isObject(position)) {
                        const positionAxisID = Object.keys(position)[0];
                        const value = position[positionAxisID];
                        borderValue = alignBorderValue(this.chart.scales[positionAxisID].getPixelForValue(value));
                    }
                    tx1 = borderValue - axisHalfWidth;
                    tx2 = tx1 - tl;
                    x1 = chartArea.left;
                    x2 = chartArea.right;
                }
                const limit = valueOrDefault(options.ticks.maxTicksLimit, ticksLength);
                const step = Math.max(1, Math.ceil(ticksLength / limit));
                for (i = 0; i < ticksLength; i += step) {
                    const context = this.getContext(i);
                    const optsAtIndex = grid.setContext(context);
                    const optsAtIndexBorder = border.setContext(context);
                    const lineWidth = optsAtIndex.lineWidth;
                    const lineColor = optsAtIndex.color;
                    const borderDash = optsAtIndexBorder.dash || [];
                    const borderDashOffset = optsAtIndexBorder.dashOffset;
                    const tickWidth = optsAtIndex.tickWidth;
                    const tickColor = optsAtIndex.tickColor;
                    const tickBorderDash = optsAtIndex.tickBorderDash || [];
                    const tickBorderDashOffset = optsAtIndex.tickBorderDashOffset;
                    lineValue = getPixelForGridLine(this, i, offset);
                    if (lineValue === void 0) continue;
                    alignedLineValue = _alignPixel(chart, lineValue, lineWidth);
                    if (isHorizontal) tx1 = tx2 = x1 = x2 = alignedLineValue; else ty1 = ty2 = y1 = y2 = alignedLineValue;
                    items.push({
                        tx1,
                        ty1,
                        tx2,
                        ty2,
                        x1,
                        y1,
                        x2,
                        y2,
                        width: lineWidth,
                        color: lineColor,
                        borderDash,
                        borderDashOffset,
                        tickWidth,
                        tickColor,
                        tickBorderDash,
                        tickBorderDashOffset
                    });
                }
                this._ticksLength = ticksLength;
                this._borderValue = borderValue;
                return items;
            }
            _computeLabelItems(chartArea) {
                const axis = this.axis;
                const options = this.options;
                const {position, ticks: optionTicks} = options;
                const isHorizontal = this.isHorizontal();
                const ticks = this.ticks;
                const {align, crossAlign, padding, mirror} = optionTicks;
                const tl = getTickMarkLength(options.grid);
                const tickAndPadding = tl + padding;
                const hTickAndPadding = mirror ? -padding : tickAndPadding;
                const rotation = -toRadians(this.labelRotation);
                const items = [];
                let i, ilen, tick, label, x, y, textAlign, pixel, font, lineHeight, lineCount, textOffset;
                let textBaseline = "middle";
                if (position === "top") {
                    y = this.bottom - hTickAndPadding;
                    textAlign = this._getXAxisLabelAlignment();
                } else if (position === "bottom") {
                    y = this.top + hTickAndPadding;
                    textAlign = this._getXAxisLabelAlignment();
                } else if (position === "left") {
                    const ret = this._getYAxisLabelAlignment(tl);
                    textAlign = ret.textAlign;
                    x = ret.x;
                } else if (position === "right") {
                    const ret = this._getYAxisLabelAlignment(tl);
                    textAlign = ret.textAlign;
                    x = ret.x;
                } else if (axis === "x") {
                    if (position === "center") y = (chartArea.top + chartArea.bottom) / 2 + tickAndPadding; else if (helpers_segment_isObject(position)) {
                        const positionAxisID = Object.keys(position)[0];
                        const value = position[positionAxisID];
                        y = this.chart.scales[positionAxisID].getPixelForValue(value) + tickAndPadding;
                    }
                    textAlign = this._getXAxisLabelAlignment();
                } else if (axis === "y") {
                    if (position === "center") x = (chartArea.left + chartArea.right) / 2 - tickAndPadding; else if (helpers_segment_isObject(position)) {
                        const positionAxisID = Object.keys(position)[0];
                        const value = position[positionAxisID];
                        x = this.chart.scales[positionAxisID].getPixelForValue(value);
                    }
                    textAlign = this._getYAxisLabelAlignment(tl).textAlign;
                }
                if (axis === "y") if (align === "start") textBaseline = "top"; else if (align === "end") textBaseline = "bottom";
                const labelSizes = this._getLabelSizes();
                for (i = 0, ilen = ticks.length; i < ilen; ++i) {
                    tick = ticks[i];
                    label = tick.label;
                    const optsAtIndex = optionTicks.setContext(this.getContext(i));
                    pixel = this.getPixelForTick(i) + optionTicks.labelOffset;
                    font = this._resolveTickFontOptions(i);
                    lineHeight = font.lineHeight;
                    lineCount = isArray(label) ? label.length : 1;
                    const halfCount = lineCount / 2;
                    const color = optsAtIndex.color;
                    const strokeColor = optsAtIndex.textStrokeColor;
                    const strokeWidth = optsAtIndex.textStrokeWidth;
                    let tickTextAlign = textAlign;
                    if (isHorizontal) {
                        x = pixel;
                        if (textAlign === "inner") if (i === ilen - 1) tickTextAlign = !this.options.reverse ? "right" : "left"; else if (i === 0) tickTextAlign = !this.options.reverse ? "left" : "right"; else tickTextAlign = "center";
                        if (position === "top") if (crossAlign === "near" || rotation !== 0) textOffset = -lineCount * lineHeight + lineHeight / 2; else if (crossAlign === "center") textOffset = -labelSizes.highest.height / 2 - halfCount * lineHeight + lineHeight; else textOffset = -labelSizes.highest.height + lineHeight / 2; else if (crossAlign === "near" || rotation !== 0) textOffset = lineHeight / 2; else if (crossAlign === "center") textOffset = labelSizes.highest.height / 2 - halfCount * lineHeight; else textOffset = labelSizes.highest.height - lineCount * lineHeight;
                        if (mirror) textOffset *= -1;
                        if (rotation !== 0 && !optsAtIndex.showLabelBackdrop) x += lineHeight / 2 * Math.sin(rotation);
                    } else {
                        y = pixel;
                        textOffset = (1 - lineCount) * lineHeight / 2;
                    }
                    let backdrop;
                    if (optsAtIndex.showLabelBackdrop) {
                        const labelPadding = toPadding(optsAtIndex.backdropPadding);
                        const height = labelSizes.heights[i];
                        const width = labelSizes.widths[i];
                        let top = textOffset - labelPadding.top;
                        let left = 0 - labelPadding.left;
                        switch (textBaseline) {
                          case "middle":
                            top -= height / 2;
                            break;

                          case "bottom":
                            top -= height;
                            break;
                        }
                        switch (textAlign) {
                          case "center":
                            left -= width / 2;
                            break;

                          case "right":
                            left -= width;
                            break;

                          case "inner":
                            if (i === ilen - 1) left -= width; else if (i > 0) left -= width / 2;
                            break;
                        }
                        backdrop = {
                            left,
                            top,
                            width: width + labelPadding.width,
                            height: height + labelPadding.height,
                            color: optsAtIndex.backdropColor
                        };
                    }
                    items.push({
                        label,
                        font,
                        textOffset,
                        options: {
                            rotation,
                            color,
                            strokeColor,
                            strokeWidth,
                            textAlign: tickTextAlign,
                            textBaseline,
                            translation: [ x, y ],
                            backdrop
                        }
                    });
                }
                return items;
            }
            _getXAxisLabelAlignment() {
                const {position, ticks} = this.options;
                const rotation = -toRadians(this.labelRotation);
                if (rotation) return position === "top" ? "left" : "right";
                let align = "center";
                if (ticks.align === "start") align = "left"; else if (ticks.align === "end") align = "right"; else if (ticks.align === "inner") align = "inner";
                return align;
            }
            _getYAxisLabelAlignment(tl) {
                const {position, ticks: {crossAlign, mirror, padding}} = this.options;
                const labelSizes = this._getLabelSizes();
                const tickAndPadding = tl + padding;
                const widest = labelSizes.widest.width;
                let textAlign;
                let x;
                if (position === "left") if (mirror) {
                    x = this.right + padding;
                    if (crossAlign === "near") textAlign = "left"; else if (crossAlign === "center") {
                        textAlign = "center";
                        x += widest / 2;
                    } else {
                        textAlign = "right";
                        x += widest;
                    }
                } else {
                    x = this.right - tickAndPadding;
                    if (crossAlign === "near") textAlign = "right"; else if (crossAlign === "center") {
                        textAlign = "center";
                        x -= widest / 2;
                    } else {
                        textAlign = "left";
                        x = this.left;
                    }
                } else if (position === "right") if (mirror) {
                    x = this.left + padding;
                    if (crossAlign === "near") textAlign = "right"; else if (crossAlign === "center") {
                        textAlign = "center";
                        x -= widest / 2;
                    } else {
                        textAlign = "left";
                        x -= widest;
                    }
                } else {
                    x = this.left + tickAndPadding;
                    if (crossAlign === "near") textAlign = "left"; else if (crossAlign === "center") {
                        textAlign = "center";
                        x += widest / 2;
                    } else {
                        textAlign = "right";
                        x = this.right;
                    }
                } else textAlign = "right";
                return {
                    textAlign,
                    x
                };
            }
            _computeLabelArea() {
                if (this.options.ticks.mirror) return;
                const chart = this.chart;
                const position = this.options.position;
                if (position === "left" || position === "right") return {
                    top: 0,
                    left: this.left,
                    bottom: chart.height,
                    right: this.right
                };
                if (position === "top" || position === "bottom") return {
                    top: this.top,
                    left: 0,
                    bottom: this.bottom,
                    right: chart.width
                };
            }
            drawBackground() {
                const {ctx, options: {backgroundColor}, left, top, width, height} = this;
                if (backgroundColor) {
                    ctx.save();
                    ctx.fillStyle = backgroundColor;
                    ctx.fillRect(left, top, width, height);
                    ctx.restore();
                }
            }
            getLineWidthForValue(value) {
                const grid = this.options.grid;
                if (!this._isVisible() || !grid.display) return 0;
                const ticks = this.ticks;
                const index = ticks.findIndex((t => t.value === value));
                if (index >= 0) {
                    const opts = grid.setContext(this.getContext(index));
                    return opts.lineWidth;
                }
                return 0;
            }
            drawGrid(chartArea) {
                const grid = this.options.grid;
                const ctx = this.ctx;
                const items = this._gridLineItems || (this._gridLineItems = this._computeGridLineItems(chartArea));
                let i, ilen;
                const drawLine = (p1, p2, style) => {
                    if (!style.width || !style.color) return;
                    ctx.save();
                    ctx.lineWidth = style.width;
                    ctx.strokeStyle = style.color;
                    ctx.setLineDash(style.borderDash || []);
                    ctx.lineDashOffset = style.borderDashOffset;
                    ctx.beginPath();
                    ctx.moveTo(p1.x, p1.y);
                    ctx.lineTo(p2.x, p2.y);
                    ctx.stroke();
                    ctx.restore();
                };
                if (grid.display) for (i = 0, ilen = items.length; i < ilen; ++i) {
                    const item = items[i];
                    if (grid.drawOnChartArea) drawLine({
                        x: item.x1,
                        y: item.y1
                    }, {
                        x: item.x2,
                        y: item.y2
                    }, item);
                    if (grid.drawTicks) drawLine({
                        x: item.tx1,
                        y: item.ty1
                    }, {
                        x: item.tx2,
                        y: item.ty2
                    }, {
                        color: item.tickColor,
                        width: item.tickWidth,
                        borderDash: item.tickBorderDash,
                        borderDashOffset: item.tickBorderDashOffset
                    });
                }
            }
            drawBorder() {
                const {chart, ctx, options: {border, grid}} = this;
                const borderOpts = border.setContext(this.getContext());
                const axisWidth = border.display ? borderOpts.width : 0;
                if (!axisWidth) return;
                const lastLineWidth = grid.setContext(this.getContext(0)).lineWidth;
                const borderValue = this._borderValue;
                let x1, x2, y1, y2;
                if (this.isHorizontal()) {
                    x1 = _alignPixel(chart, this.left, axisWidth) - axisWidth / 2;
                    x2 = _alignPixel(chart, this.right, lastLineWidth) + lastLineWidth / 2;
                    y1 = y2 = borderValue;
                } else {
                    y1 = _alignPixel(chart, this.top, axisWidth) - axisWidth / 2;
                    y2 = _alignPixel(chart, this.bottom, lastLineWidth) + lastLineWidth / 2;
                    x1 = x2 = borderValue;
                }
                ctx.save();
                ctx.lineWidth = borderOpts.width;
                ctx.strokeStyle = borderOpts.color;
                ctx.beginPath();
                ctx.moveTo(x1, y1);
                ctx.lineTo(x2, y2);
                ctx.stroke();
                ctx.restore();
            }
            drawLabels(chartArea) {
                const optionTicks = this.options.ticks;
                if (!optionTicks.display) return;
                const ctx = this.ctx;
                const area = this._computeLabelArea();
                if (area) clipArea(ctx, area);
                const items = this.getLabelItems(chartArea);
                for (const item of items) {
                    const renderTextOptions = item.options;
                    const tickFont = item.font;
                    const label = item.label;
                    const y = item.textOffset;
                    renderText(ctx, label, 0, y, tickFont, renderTextOptions);
                }
                if (area) unclipArea(ctx);
            }
            drawTitle() {
                const {ctx, options: {position, title, reverse}} = this;
                if (!title.display) return;
                const font = toFont(title.font);
                const padding = toPadding(title.padding);
                const align = title.align;
                let offset = font.lineHeight / 2;
                if (position === "bottom" || position === "center" || helpers_segment_isObject(position)) {
                    offset += padding.bottom;
                    if (isArray(title.text)) offset += font.lineHeight * (title.text.length - 1);
                } else offset += padding.top;
                const {titleX, titleY, maxWidth, rotation} = titleArgs(this, offset, position, align);
                renderText(ctx, title.text, 0, 0, font, {
                    color: title.color,
                    maxWidth,
                    rotation,
                    textAlign: titleAlign(align, position, reverse),
                    textBaseline: "middle",
                    translation: [ titleX, titleY ]
                });
            }
            draw(chartArea) {
                if (!this._isVisible()) return;
                this.drawBackground();
                this.drawGrid(chartArea);
                this.drawBorder();
                this.drawTitle();
                this.drawLabels(chartArea);
            }
            _layers() {
                const opts = this.options;
                const tz = opts.ticks && opts.ticks.z || 0;
                const gz = valueOrDefault(opts.grid && opts.grid.z, -1);
                const bz = valueOrDefault(opts.border && opts.border.z, 0);
                if (!this._isVisible() || this.draw !== Scale.prototype.draw) return [ {
                    z: tz,
                    draw: chartArea => {
                        this.draw(chartArea);
                    }
                } ];
                return [ {
                    z: gz,
                    draw: chartArea => {
                        this.drawBackground();
                        this.drawGrid(chartArea);
                        this.drawTitle();
                    }
                }, {
                    z: bz,
                    draw: () => {
                        this.drawBorder();
                    }
                }, {
                    z: tz,
                    draw: chartArea => {
                        this.drawLabels(chartArea);
                    }
                } ];
            }
            getMatchingVisibleMetas(type) {
                const metas = this.chart.getSortedVisibleDatasetMetas();
                const axisID = this.axis + "AxisID";
                const result = [];
                let i, ilen;
                for (i = 0, ilen = metas.length; i < ilen; ++i) {
                    const meta = metas[i];
                    if (meta[axisID] === this.id && (!type || meta.type === type)) result.push(meta);
                }
                return result;
            }
            _resolveTickFontOptions(index) {
                const opts = this.options.ticks.setContext(this.getContext(index));
                return toFont(opts.font);
            }
            _maxDigits() {
                const fontSize = this._resolveTickFontOptions(0).lineHeight;
                return (this.isHorizontal() ? this.width : this.height) / fontSize;
            }
        }
        class TypedRegistry {
            constructor(type, scope, override) {
                this.type = type;
                this.scope = scope;
                this.override = override;
                this.items = Object.create(null);
            }
            isForType(type) {
                return Object.prototype.isPrototypeOf.call(this.type.prototype, type.prototype);
            }
            register(item) {
                const proto = Object.getPrototypeOf(item);
                let parentScope;
                if (isIChartComponent(proto)) parentScope = this.register(proto);
                const items = this.items;
                const id = item.id;
                const scope = this.scope + "." + id;
                if (!id) throw new Error("class does not have id: " + item);
                if (id in items) return scope;
                items[id] = item;
                registerDefaults(item, scope, parentScope);
                if (this.override) defaults.override(item.id, item.overrides);
                return scope;
            }
            get(id) {
                return this.items[id];
            }
            unregister(item) {
                const items = this.items;
                const id = item.id;
                const scope = this.scope;
                if (id in items) delete items[id];
                if (scope && id in defaults[scope]) {
                    delete defaults[scope][id];
                    if (this.override) delete overrides[id];
                }
            }
        }
        function registerDefaults(item, scope, parentScope) {
            const itemDefaults = merge(Object.create(null), [ parentScope ? defaults.get(parentScope) : {}, defaults.get(scope), item.defaults ]);
            defaults.set(scope, itemDefaults);
            if (item.defaultRoutes) routeDefaults(scope, item.defaultRoutes);
            if (item.descriptors) defaults.describe(scope, item.descriptors);
        }
        function routeDefaults(scope, routes) {
            Object.keys(routes).forEach((property => {
                const propertyParts = property.split(".");
                const sourceName = propertyParts.pop();
                const sourceScope = [ scope ].concat(propertyParts).join(".");
                const parts = routes[property].split(".");
                const targetName = parts.pop();
                const targetScope = parts.join(".");
                defaults.route(sourceScope, sourceName, targetScope, targetName);
            }));
        }
        function isIChartComponent(proto) {
            return "id" in proto && "defaults" in proto;
        }
        class Registry {
            constructor() {
                this.controllers = new TypedRegistry(DatasetController, "datasets", true);
                this.elements = new TypedRegistry(chart_Element, "elements");
                this.plugins = new TypedRegistry(Object, "plugins");
                this.scales = new TypedRegistry(Scale, "scales");
                this._typedRegistries = [ this.controllers, this.scales, this.elements ];
            }
            add(...args) {
                this._each("register", args);
            }
            remove(...args) {
                this._each("unregister", args);
            }
            addControllers(...args) {
                this._each("register", args, this.controllers);
            }
            addElements(...args) {
                this._each("register", args, this.elements);
            }
            addPlugins(...args) {
                this._each("register", args, this.plugins);
            }
            addScales(...args) {
                this._each("register", args, this.scales);
            }
            getController(id) {
                return this._get(id, this.controllers, "controller");
            }
            getElement(id) {
                return this._get(id, this.elements, "element");
            }
            getPlugin(id) {
                return this._get(id, this.plugins, "plugin");
            }
            getScale(id) {
                return this._get(id, this.scales, "scale");
            }
            removeControllers(...args) {
                this._each("unregister", args, this.controllers);
            }
            removeElements(...args) {
                this._each("unregister", args, this.elements);
            }
            removePlugins(...args) {
                this._each("unregister", args, this.plugins);
            }
            removeScales(...args) {
                this._each("unregister", args, this.scales);
            }
            _each(method, args, typedRegistry) {
                [ ...args ].forEach((arg => {
                    const reg = typedRegistry || this._getRegistryForType(arg);
                    if (typedRegistry || reg.isForType(arg) || reg === this.plugins && arg.id) this._exec(method, reg, arg); else each(arg, (item => {
                        const itemReg = typedRegistry || this._getRegistryForType(item);
                        this._exec(method, itemReg, item);
                    }));
                }));
            }
            _exec(method, registry, component) {
                const camelMethod = _capitalize(method);
                callback(component["before" + camelMethod], [], component);
                registry[method](component);
                callback(component["after" + camelMethod], [], component);
            }
            _getRegistryForType(type) {
                for (let i = 0; i < this._typedRegistries.length; i++) {
                    const reg = this._typedRegistries[i];
                    if (reg.isForType(type)) return reg;
                }
                return this.plugins;
            }
            _get(id, typedRegistry, type) {
                const item = typedRegistry.get(id);
                if (item === void 0) throw new Error('"' + id + '" is not a registered ' + type + ".");
                return item;
            }
        }
        var registry = new Registry;
        class PluginService {
            constructor() {
                this._init = [];
            }
            notify(chart, hook, args, filter) {
                if (hook === "beforeInit") {
                    this._init = this._createDescriptors(chart, true);
                    this._notify(this._init, chart, "install");
                }
                const descriptors = filter ? this._descriptors(chart).filter(filter) : this._descriptors(chart);
                const result = this._notify(descriptors, chart, hook, args);
                if (hook === "afterDestroy") {
                    this._notify(descriptors, chart, "stop");
                    this._notify(this._init, chart, "uninstall");
                }
                return result;
            }
            _notify(descriptors, chart, hook, args) {
                args = args || {};
                for (const descriptor of descriptors) {
                    const plugin = descriptor.plugin;
                    const method = plugin[hook];
                    const params = [ chart, args, descriptor.options ];
                    if (callback(method, params, plugin) === false && args.cancelable) return false;
                }
                return true;
            }
            invalidate() {
                if (!isNullOrUndef(this._cache)) {
                    this._oldCache = this._cache;
                    this._cache = void 0;
                }
            }
            _descriptors(chart) {
                if (this._cache) return this._cache;
                const descriptors = this._cache = this._createDescriptors(chart);
                this._notifyStateChanges(chart);
                return descriptors;
            }
            _createDescriptors(chart, all) {
                const config = chart && chart.config;
                const options = valueOrDefault(config.options && config.options.plugins, {});
                const plugins = allPlugins(config);
                return options === false && !all ? [] : createDescriptors(chart, plugins, options, all);
            }
            _notifyStateChanges(chart) {
                const previousDescriptors = this._oldCache || [];
                const descriptors = this._cache;
                const diff = (a, b) => a.filter((x => !b.some((y => x.plugin.id === y.plugin.id))));
                this._notify(diff(previousDescriptors, descriptors), chart, "stop");
                this._notify(diff(descriptors, previousDescriptors), chart, "start");
            }
        }
        function allPlugins(config) {
            const localIds = {};
            const plugins = [];
            const keys = Object.keys(registry.plugins.items);
            for (let i = 0; i < keys.length; i++) plugins.push(registry.getPlugin(keys[i]));
            const local = config.plugins || [];
            for (let i = 0; i < local.length; i++) {
                const plugin = local[i];
                if (plugins.indexOf(plugin) === -1) {
                    plugins.push(plugin);
                    localIds[plugin.id] = true;
                }
            }
            return {
                plugins,
                localIds
            };
        }
        function getOpts(options, all) {
            if (!all && options === false) return null;
            if (options === true) return {};
            return options;
        }
        function createDescriptors(chart, {plugins, localIds}, options, all) {
            const result = [];
            const context = chart.getContext();
            for (const plugin of plugins) {
                const id = plugin.id;
                const opts = getOpts(options[id], all);
                if (opts === null) continue;
                result.push({
                    plugin,
                    options: pluginOpts(chart.config, {
                        plugin,
                        local: localIds[id]
                    }, opts, context)
                });
            }
            return result;
        }
        function pluginOpts(config, {plugin, local}, opts, context) {
            const keys = config.pluginScopeKeys(plugin);
            const scopes = config.getOptionScopes(opts, keys);
            if (local && plugin.defaults) scopes.push(plugin.defaults);
            return config.createResolver(scopes, context, [ "" ], {
                scriptable: false,
                indexable: false,
                allKeys: true
            });
        }
        function getIndexAxis(type, options) {
            const datasetDefaults = defaults.datasets[type] || {};
            const datasetOptions = (options.datasets || {})[type] || {};
            return datasetOptions.indexAxis || options.indexAxis || datasetDefaults.indexAxis || "x";
        }
        function getAxisFromDefaultScaleID(id, indexAxis) {
            let axis = id;
            if (id === "_index_") axis = indexAxis; else if (id === "_value_") axis = indexAxis === "x" ? "y" : "x";
            return axis;
        }
        function getDefaultScaleIDFromAxis(axis, indexAxis) {
            return axis === indexAxis ? "_index_" : "_value_";
        }
        function idMatchesAxis(id) {
            if (id === "x" || id === "y" || id === "r") return id;
        }
        function axisFromPosition(position) {
            if (position === "top" || position === "bottom") return "x";
            if (position === "left" || position === "right") return "y";
        }
        function determineAxis(id, ...scaleOptions) {
            if (idMatchesAxis(id)) return id;
            for (const opts of scaleOptions) {
                const axis = opts.axis || axisFromPosition(opts.position) || id.length > 1 && idMatchesAxis(id[0].toLowerCase());
                if (axis) return axis;
            }
            throw new Error(`Cannot determine type of '${id}' axis. Please provide 'axis' or 'position' option.`);
        }
        function getAxisFromDataset(id, axis, dataset) {
            if (dataset[axis + "AxisID"] === id) return {
                axis
            };
        }
        function retrieveAxisFromDatasets(id, config) {
            if (config.data && config.data.datasets) {
                const boundDs = config.data.datasets.filter((d => d.xAxisID === id || d.yAxisID === id));
                if (boundDs.length) return getAxisFromDataset(id, "x", boundDs[0]) || getAxisFromDataset(id, "y", boundDs[0]);
            }
            return {};
        }
        function mergeScaleConfig(config, options) {
            const chartDefaults = overrides[config.type] || {
                scales: {}
            };
            const configScales = options.scales || {};
            const chartIndexAxis = getIndexAxis(config.type, options);
            const scales = Object.create(null);
            Object.keys(configScales).forEach((id => {
                const scaleConf = configScales[id];
                if (!helpers_segment_isObject(scaleConf)) return console.error(`Invalid scale configuration for scale: ${id}`);
                if (scaleConf._proxy) return console.warn(`Ignoring resolver passed as options for scale: ${id}`);
                const axis = determineAxis(id, scaleConf, retrieveAxisFromDatasets(id, config), defaults.scales[scaleConf.type]);
                const defaultId = getDefaultScaleIDFromAxis(axis, chartIndexAxis);
                const defaultScaleOptions = chartDefaults.scales || {};
                scales[id] = mergeIf(Object.create(null), [ {
                    axis
                }, scaleConf, defaultScaleOptions[axis], defaultScaleOptions[defaultId] ]);
            }));
            config.data.datasets.forEach((dataset => {
                const type = dataset.type || config.type;
                const indexAxis = dataset.indexAxis || getIndexAxis(type, options);
                const datasetDefaults = overrides[type] || {};
                const defaultScaleOptions = datasetDefaults.scales || {};
                Object.keys(defaultScaleOptions).forEach((defaultID => {
                    const axis = getAxisFromDefaultScaleID(defaultID, indexAxis);
                    const id = dataset[axis + "AxisID"] || axis;
                    scales[id] = scales[id] || Object.create(null);
                    mergeIf(scales[id], [ {
                        axis
                    }, configScales[id], defaultScaleOptions[defaultID] ]);
                }));
            }));
            Object.keys(scales).forEach((key => {
                const scale = scales[key];
                mergeIf(scale, [ defaults.scales[scale.type], defaults.scale ]);
            }));
            return scales;
        }
        function initOptions(config) {
            const options = config.options || (config.options = {});
            options.plugins = valueOrDefault(options.plugins, {});
            options.scales = mergeScaleConfig(config, options);
        }
        function initData(data) {
            data = data || {};
            data.datasets = data.datasets || [];
            data.labels = data.labels || [];
            return data;
        }
        function initConfig(config) {
            config = config || {};
            config.data = initData(config.data);
            initOptions(config);
            return config;
        }
        const keyCache = new Map;
        const keysCached = new Set;
        function cachedKeys(cacheKey, generate) {
            let keys = keyCache.get(cacheKey);
            if (!keys) {
                keys = generate();
                keyCache.set(cacheKey, keys);
                keysCached.add(keys);
            }
            return keys;
        }
        const addIfFound = (set, obj, key) => {
            const opts = resolveObjectKey(obj, key);
            if (opts !== void 0) set.add(opts);
        };
        class Config {
            constructor(config) {
                this._config = initConfig(config);
                this._scopeCache = new Map;
                this._resolverCache = new Map;
            }
            get platform() {
                return this._config.platform;
            }
            get type() {
                return this._config.type;
            }
            set type(type) {
                this._config.type = type;
            }
            get data() {
                return this._config.data;
            }
            set data(data) {
                this._config.data = initData(data);
            }
            get options() {
                return this._config.options;
            }
            set options(options) {
                this._config.options = options;
            }
            get plugins() {
                return this._config.plugins;
            }
            update() {
                const config = this._config;
                this.clearCache();
                initOptions(config);
            }
            clearCache() {
                this._scopeCache.clear();
                this._resolverCache.clear();
            }
            datasetScopeKeys(datasetType) {
                return cachedKeys(datasetType, (() => [ [ `datasets.${datasetType}`, "" ] ]));
            }
            datasetAnimationScopeKeys(datasetType, transition) {
                return cachedKeys(`${datasetType}.transition.${transition}`, (() => [ [ `datasets.${datasetType}.transitions.${transition}`, `transitions.${transition}` ], [ `datasets.${datasetType}`, "" ] ]));
            }
            datasetElementScopeKeys(datasetType, elementType) {
                return cachedKeys(`${datasetType}-${elementType}`, (() => [ [ `datasets.${datasetType}.elements.${elementType}`, `datasets.${datasetType}`, `elements.${elementType}`, "" ] ]));
            }
            pluginScopeKeys(plugin) {
                const id = plugin.id;
                const type = this.type;
                return cachedKeys(`${type}-plugin-${id}`, (() => [ [ `plugins.${id}`, ...plugin.additionalOptionScopes || [] ] ]));
            }
            _cachedScopes(mainScope, resetCache) {
                const _scopeCache = this._scopeCache;
                let cache = _scopeCache.get(mainScope);
                if (!cache || resetCache) {
                    cache = new Map;
                    _scopeCache.set(mainScope, cache);
                }
                return cache;
            }
            getOptionScopes(mainScope, keyLists, resetCache) {
                const {options, type} = this;
                const cache = this._cachedScopes(mainScope, resetCache);
                const cached = cache.get(keyLists);
                if (cached) return cached;
                const scopes = new Set;
                keyLists.forEach((keys => {
                    if (mainScope) {
                        scopes.add(mainScope);
                        keys.forEach((key => addIfFound(scopes, mainScope, key)));
                    }
                    keys.forEach((key => addIfFound(scopes, options, key)));
                    keys.forEach((key => addIfFound(scopes, overrides[type] || {}, key)));
                    keys.forEach((key => addIfFound(scopes, defaults, key)));
                    keys.forEach((key => addIfFound(scopes, descriptors, key)));
                }));
                const array = Array.from(scopes);
                if (array.length === 0) array.push(Object.create(null));
                if (keysCached.has(keyLists)) cache.set(keyLists, array);
                return array;
            }
            chartOptionScopes() {
                const {options, type} = this;
                return [ options, overrides[type] || {}, defaults.datasets[type] || {}, {
                    type
                }, defaults, descriptors ];
            }
            resolveNamedOptions(scopes, names, context, prefixes = [ "" ]) {
                const result = {
                    $shared: true
                };
                const {resolver, subPrefixes} = getResolver(this._resolverCache, scopes, prefixes);
                let options = resolver;
                if (needContext(resolver, names)) {
                    result.$shared = false;
                    context = isFunction(context) ? context() : context;
                    const subResolver = this.createResolver(scopes, context, subPrefixes);
                    options = _attachContext(resolver, context, subResolver);
                }
                for (const prop of names) result[prop] = options[prop];
                return result;
            }
            createResolver(scopes, context, prefixes = [ "" ], descriptorDefaults) {
                const {resolver} = getResolver(this._resolverCache, scopes, prefixes);
                return helpers_segment_isObject(context) ? _attachContext(resolver, context, void 0, descriptorDefaults) : resolver;
            }
        }
        function getResolver(resolverCache, scopes, prefixes) {
            let cache = resolverCache.get(scopes);
            if (!cache) {
                cache = new Map;
                resolverCache.set(scopes, cache);
            }
            const cacheKey = prefixes.join();
            let cached = cache.get(cacheKey);
            if (!cached) {
                const resolver = _createResolver(scopes, prefixes);
                cached = {
                    resolver,
                    subPrefixes: prefixes.filter((p => !p.toLowerCase().includes("hover")))
                };
                cache.set(cacheKey, cached);
            }
            return cached;
        }
        const hasFunction = value => helpers_segment_isObject(value) && Object.getOwnPropertyNames(value).some((key => isFunction(value[key])));
        function needContext(proxy, names) {
            const {isScriptable, isIndexable} = _descriptors(proxy);
            for (const prop of names) {
                const scriptable = isScriptable(prop);
                const indexable = isIndexable(prop);
                const value = (indexable || scriptable) && proxy[prop];
                if (scriptable && (isFunction(value) || hasFunction(value)) || indexable && isArray(value)) return true;
            }
            return false;
        }
        var version = "4.4.7";
        const KNOWN_POSITIONS = [ "top", "bottom", "left", "right", "chartArea" ];
        function positionIsHorizontal(position, axis) {
            return position === "top" || position === "bottom" || KNOWN_POSITIONS.indexOf(position) === -1 && axis === "x";
        }
        function compare2Level(l1, l2) {
            return function(a, b) {
                return a[l1] === b[l1] ? a[l2] - b[l2] : a[l1] - b[l1];
            };
        }
        function onAnimationsComplete(context) {
            const chart = context.chart;
            const animationOptions = chart.options.animation;
            chart.notifyPlugins("afterRender");
            callback(animationOptions && animationOptions.onComplete, [ context ], chart);
        }
        function onAnimationProgress(context) {
            const chart = context.chart;
            const animationOptions = chart.options.animation;
            callback(animationOptions && animationOptions.onProgress, [ context ], chart);
        }
        function getCanvas(item) {
            if (_isDomSupported() && typeof item === "string") item = document.getElementById(item); else if (item && item.length) item = item[0];
            if (item && item.canvas) item = item.canvas;
            return item;
        }
        const chart_instances = {};
        const getChart = key => {
            const canvas = getCanvas(key);
            return Object.values(chart_instances).filter((c => c.canvas === canvas)).pop();
        };
        function moveNumericKeys(obj, start, move) {
            const keys = Object.keys(obj);
            for (const key of keys) {
                const intKey = +key;
                if (intKey >= start) {
                    const value = obj[key];
                    delete obj[key];
                    if (move > 0 || intKey > start) obj[intKey + move] = value;
                }
            }
        }
        function determineLastEvent(e, lastEvent, inChartArea, isClick) {
            if (!inChartArea || e.type === "mouseout") return null;
            if (isClick) return lastEvent;
            return e;
        }
        function getSizeForArea(scale, chartArea, field) {
            return scale.options.clip ? scale[field] : chartArea[field];
        }
        function getDatasetArea(meta, chartArea) {
            const {xScale, yScale} = meta;
            if (xScale && yScale) return {
                left: getSizeForArea(xScale, chartArea, "left"),
                right: getSizeForArea(xScale, chartArea, "right"),
                top: getSizeForArea(yScale, chartArea, "top"),
                bottom: getSizeForArea(yScale, chartArea, "bottom")
            };
            return chartArea;
        }
        class chart_Chart {
            static defaults=defaults;
            static instances=chart_instances;
            static overrides=overrides;
            static registry=registry;
            static version=version;
            static getChart=getChart;
            static register(...items) {
                registry.add(...items);
                invalidatePlugins();
            }
            static unregister(...items) {
                registry.remove(...items);
                invalidatePlugins();
            }
            constructor(item, userConfig) {
                const config = this.config = new Config(userConfig);
                const initialCanvas = getCanvas(item);
                const existingChart = getChart(initialCanvas);
                if (existingChart) throw new Error("Canvas is already in use. Chart with ID '" + existingChart.id + "'" + " must be destroyed before the canvas with ID '" + existingChart.canvas.id + "' can be reused.");
                const options = config.createResolver(config.chartOptionScopes(), this.getContext());
                this.platform = new (config.platform || _detectPlatform(initialCanvas));
                this.platform.updateConfig(config);
                const context = this.platform.acquireContext(initialCanvas, options.aspectRatio);
                const canvas = context && context.canvas;
                const height = canvas && canvas.height;
                const width = canvas && canvas.width;
                this.id = uid();
                this.ctx = context;
                this.canvas = canvas;
                this.width = width;
                this.height = height;
                this._options = options;
                this._aspectRatio = this.aspectRatio;
                this._layers = [];
                this._metasets = [];
                this._stacks = void 0;
                this.boxes = [];
                this.currentDevicePixelRatio = void 0;
                this.chartArea = void 0;
                this._active = [];
                this._lastEvent = void 0;
                this._listeners = {};
                this._responsiveListeners = void 0;
                this._sortedMetasets = [];
                this.scales = {};
                this._plugins = new PluginService;
                this.$proxies = {};
                this._hiddenIndices = {};
                this.attached = false;
                this._animationsDisabled = void 0;
                this.$context = void 0;
                this._doResize = helpers_segment_debounce((mode => this.update(mode)), options.resizeDelay || 0);
                this._dataChanges = [];
                chart_instances[this.id] = this;
                if (!context || !canvas) {
                    console.error("Failed to create chart: can't acquire context from the given item");
                    return;
                }
                animator.listen(this, "complete", onAnimationsComplete);
                animator.listen(this, "progress", onAnimationProgress);
                this._initialize();
                if (this.attached) this.update();
            }
            get aspectRatio() {
                const {options: {aspectRatio, maintainAspectRatio}, width, height, _aspectRatio} = this;
                if (!isNullOrUndef(aspectRatio)) return aspectRatio;
                if (maintainAspectRatio && _aspectRatio) return _aspectRatio;
                return height ? width / height : null;
            }
            get data() {
                return this.config.data;
            }
            set data(data) {
                this.config.data = data;
            }
            get options() {
                return this._options;
            }
            set options(options) {
                this.config.options = options;
            }
            get registry() {
                return registry;
            }
            _initialize() {
                this.notifyPlugins("beforeInit");
                if (this.options.responsive) this.resize(); else retinaScale(this, this.options.devicePixelRatio);
                this.bindEvents();
                this.notifyPlugins("afterInit");
                return this;
            }
            clear() {
                clearCanvas(this.canvas, this.ctx);
                return this;
            }
            stop() {
                animator.stop(this);
                return this;
            }
            resize(width, height) {
                if (!animator.running(this)) this._resize(width, height); else this._resizeBeforeDraw = {
                    width,
                    height
                };
            }
            _resize(width, height) {
                const options = this.options;
                const canvas = this.canvas;
                const aspectRatio = options.maintainAspectRatio && this.aspectRatio;
                const newSize = this.platform.getMaximumSize(canvas, width, height, aspectRatio);
                const newRatio = options.devicePixelRatio || this.platform.getDevicePixelRatio();
                const mode = this.width ? "resize" : "attach";
                this.width = newSize.width;
                this.height = newSize.height;
                this._aspectRatio = this.aspectRatio;
                if (!retinaScale(this, newRatio, true)) return;
                this.notifyPlugins("resize", {
                    size: newSize
                });
                callback(options.onResize, [ this, newSize ], this);
                if (this.attached) if (this._doResize(mode)) this.render();
            }
            ensureScalesHaveIDs() {
                const options = this.options;
                const scalesOptions = options.scales || {};
                each(scalesOptions, ((axisOptions, axisID) => {
                    axisOptions.id = axisID;
                }));
            }
            buildOrUpdateScales() {
                const options = this.options;
                const scaleOpts = options.scales;
                const scales = this.scales;
                const updated = Object.keys(scales).reduce(((obj, id) => {
                    obj[id] = false;
                    return obj;
                }), {});
                let items = [];
                if (scaleOpts) items = items.concat(Object.keys(scaleOpts).map((id => {
                    const scaleOptions = scaleOpts[id];
                    const axis = determineAxis(id, scaleOptions);
                    const isRadial = axis === "r";
                    const isHorizontal = axis === "x";
                    return {
                        options: scaleOptions,
                        dposition: isRadial ? "chartArea" : isHorizontal ? "bottom" : "left",
                        dtype: isRadial ? "radialLinear" : isHorizontal ? "category" : "linear"
                    };
                })));
                each(items, (item => {
                    const scaleOptions = item.options;
                    const id = scaleOptions.id;
                    const axis = determineAxis(id, scaleOptions);
                    const scaleType = valueOrDefault(scaleOptions.type, item.dtype);
                    if (scaleOptions.position === void 0 || positionIsHorizontal(scaleOptions.position, axis) !== positionIsHorizontal(item.dposition)) scaleOptions.position = item.dposition;
                    updated[id] = true;
                    let scale = null;
                    if (id in scales && scales[id].type === scaleType) scale = scales[id]; else {
                        const scaleClass = registry.getScale(scaleType);
                        scale = new scaleClass({
                            id,
                            type: scaleType,
                            ctx: this.ctx,
                            chart: this
                        });
                        scales[scale.id] = scale;
                    }
                    scale.init(scaleOptions, options);
                }));
                each(updated, ((hasUpdated, id) => {
                    if (!hasUpdated) delete scales[id];
                }));
                each(scales, (scale => {
                    layouts.configure(this, scale, scale.options);
                    layouts.addBox(this, scale);
                }));
            }
            _updateMetasets() {
                const metasets = this._metasets;
                const numData = this.data.datasets.length;
                const numMeta = metasets.length;
                metasets.sort(((a, b) => a.index - b.index));
                if (numMeta > numData) {
                    for (let i = numData; i < numMeta; ++i) this._destroyDatasetMeta(i);
                    metasets.splice(numData, numMeta - numData);
                }
                this._sortedMetasets = metasets.slice(0).sort(compare2Level("order", "index"));
            }
            _removeUnreferencedMetasets() {
                const {_metasets: metasets, data: {datasets}} = this;
                if (metasets.length > datasets.length) delete this._stacks;
                metasets.forEach(((meta, index) => {
                    if (datasets.filter((x => x === meta._dataset)).length === 0) this._destroyDatasetMeta(index);
                }));
            }
            buildOrUpdateControllers() {
                const newControllers = [];
                const datasets = this.data.datasets;
                let i, ilen;
                this._removeUnreferencedMetasets();
                for (i = 0, ilen = datasets.length; i < ilen; i++) {
                    const dataset = datasets[i];
                    let meta = this.getDatasetMeta(i);
                    const type = dataset.type || this.config.type;
                    if (meta.type && meta.type !== type) {
                        this._destroyDatasetMeta(i);
                        meta = this.getDatasetMeta(i);
                    }
                    meta.type = type;
                    meta.indexAxis = dataset.indexAxis || getIndexAxis(type, this.options);
                    meta.order = dataset.order || 0;
                    meta.index = i;
                    meta.label = "" + dataset.label;
                    meta.visible = this.isDatasetVisible(i);
                    if (meta.controller) {
                        meta.controller.updateIndex(i);
                        meta.controller.linkScales();
                    } else {
                        const ControllerClass = registry.getController(type);
                        const {datasetElementType, dataElementType} = defaults.datasets[type];
                        Object.assign(ControllerClass, {
                            dataElementType: registry.getElement(dataElementType),
                            datasetElementType: datasetElementType && registry.getElement(datasetElementType)
                        });
                        meta.controller = new ControllerClass(this, i);
                        newControllers.push(meta.controller);
                    }
                }
                this._updateMetasets();
                return newControllers;
            }
            _resetElements() {
                each(this.data.datasets, ((dataset, datasetIndex) => {
                    this.getDatasetMeta(datasetIndex).controller.reset();
                }), this);
            }
            reset() {
                this._resetElements();
                this.notifyPlugins("reset");
            }
            update(mode) {
                const config = this.config;
                config.update();
                const options = this._options = config.createResolver(config.chartOptionScopes(), this.getContext());
                const animsDisabled = this._animationsDisabled = !options.animation;
                this._updateScales();
                this._checkEventBindings();
                this._updateHiddenIndices();
                this._plugins.invalidate();
                if (this.notifyPlugins("beforeUpdate", {
                    mode,
                    cancelable: true
                }) === false) return;
                const newControllers = this.buildOrUpdateControllers();
                this.notifyPlugins("beforeElementsUpdate");
                let minPadding = 0;
                for (let i = 0, ilen = this.data.datasets.length; i < ilen; i++) {
                    const {controller} = this.getDatasetMeta(i);
                    const reset = !animsDisabled && newControllers.indexOf(controller) === -1;
                    controller.buildOrUpdateElements(reset);
                    minPadding = Math.max(+controller.getMaxOverflow(), minPadding);
                }
                minPadding = this._minPadding = options.layout.autoPadding ? minPadding : 0;
                this._updateLayout(minPadding);
                if (!animsDisabled) each(newControllers, (controller => {
                    controller.reset();
                }));
                this._updateDatasets(mode);
                this.notifyPlugins("afterUpdate", {
                    mode
                });
                this._layers.sort(compare2Level("z", "_idx"));
                const {_active, _lastEvent} = this;
                if (_lastEvent) this._eventHandler(_lastEvent, true); else if (_active.length) this._updateHoverStyles(_active, _active, true);
                this.render();
            }
            _updateScales() {
                each(this.scales, (scale => {
                    layouts.removeBox(this, scale);
                }));
                this.ensureScalesHaveIDs();
                this.buildOrUpdateScales();
            }
            _checkEventBindings() {
                const options = this.options;
                const existingEvents = new Set(Object.keys(this._listeners));
                const newEvents = new Set(options.events);
                if (!setsEqual(existingEvents, newEvents) || !!this._responsiveListeners !== options.responsive) {
                    this.unbindEvents();
                    this.bindEvents();
                }
            }
            _updateHiddenIndices() {
                const {_hiddenIndices} = this;
                const changes = this._getUniformDataChanges() || [];
                for (const {method, start, count} of changes) {
                    const move = method === "_removeElements" ? -count : count;
                    moveNumericKeys(_hiddenIndices, start, move);
                }
            }
            _getUniformDataChanges() {
                const _dataChanges = this._dataChanges;
                if (!_dataChanges || !_dataChanges.length) return;
                this._dataChanges = [];
                const datasetCount = this.data.datasets.length;
                const makeSet = idx => new Set(_dataChanges.filter((c => c[0] === idx)).map(((c, i) => i + "," + c.splice(1).join(","))));
                const changeSet = makeSet(0);
                for (let i = 1; i < datasetCount; i++) if (!setsEqual(changeSet, makeSet(i))) return;
                return Array.from(changeSet).map((c => c.split(","))).map((a => ({
                    method: a[1],
                    start: +a[2],
                    count: +a[3]
                })));
            }
            _updateLayout(minPadding) {
                if (this.notifyPlugins("beforeLayout", {
                    cancelable: true
                }) === false) return;
                layouts.update(this, this.width, this.height, minPadding);
                const area = this.chartArea;
                const noArea = area.width <= 0 || area.height <= 0;
                this._layers = [];
                each(this.boxes, (box => {
                    if (noArea && box.position === "chartArea") return;
                    if (box.configure) box.configure();
                    this._layers.push(...box._layers());
                }), this);
                this._layers.forEach(((item, index) => {
                    item._idx = index;
                }));
                this.notifyPlugins("afterLayout");
            }
            _updateDatasets(mode) {
                if (this.notifyPlugins("beforeDatasetsUpdate", {
                    mode,
                    cancelable: true
                }) === false) return;
                for (let i = 0, ilen = this.data.datasets.length; i < ilen; ++i) this.getDatasetMeta(i).controller.configure();
                for (let i = 0, ilen = this.data.datasets.length; i < ilen; ++i) this._updateDataset(i, isFunction(mode) ? mode({
                    datasetIndex: i
                }) : mode);
                this.notifyPlugins("afterDatasetsUpdate", {
                    mode
                });
            }
            _updateDataset(index, mode) {
                const meta = this.getDatasetMeta(index);
                const args = {
                    meta,
                    index,
                    mode,
                    cancelable: true
                };
                if (this.notifyPlugins("beforeDatasetUpdate", args) === false) return;
                meta.controller._update(mode);
                args.cancelable = false;
                this.notifyPlugins("afterDatasetUpdate", args);
            }
            render() {
                if (this.notifyPlugins("beforeRender", {
                    cancelable: true
                }) === false) return;
                if (animator.has(this)) {
                    if (this.attached && !animator.running(this)) animator.start(this);
                } else {
                    this.draw();
                    onAnimationsComplete({
                        chart: this
                    });
                }
            }
            draw() {
                let i;
                if (this._resizeBeforeDraw) {
                    const {width, height} = this._resizeBeforeDraw;
                    this._resizeBeforeDraw = null;
                    this._resize(width, height);
                }
                this.clear();
                if (this.width <= 0 || this.height <= 0) return;
                if (this.notifyPlugins("beforeDraw", {
                    cancelable: true
                }) === false) return;
                const layers = this._layers;
                for (i = 0; i < layers.length && layers[i].z <= 0; ++i) layers[i].draw(this.chartArea);
                this._drawDatasets();
                for (;i < layers.length; ++i) layers[i].draw(this.chartArea);
                this.notifyPlugins("afterDraw");
            }
            _getSortedDatasetMetas(filterVisible) {
                const metasets = this._sortedMetasets;
                const result = [];
                let i, ilen;
                for (i = 0, ilen = metasets.length; i < ilen; ++i) {
                    const meta = metasets[i];
                    if (!filterVisible || meta.visible) result.push(meta);
                }
                return result;
            }
            getSortedVisibleDatasetMetas() {
                return this._getSortedDatasetMetas(true);
            }
            _drawDatasets() {
                if (this.notifyPlugins("beforeDatasetsDraw", {
                    cancelable: true
                }) === false) return;
                const metasets = this.getSortedVisibleDatasetMetas();
                for (let i = metasets.length - 1; i >= 0; --i) this._drawDataset(metasets[i]);
                this.notifyPlugins("afterDatasetsDraw");
            }
            _drawDataset(meta) {
                const ctx = this.ctx;
                const clip = meta._clip;
                const useClip = !clip.disabled;
                const area = getDatasetArea(meta, this.chartArea);
                const args = {
                    meta,
                    index: meta.index,
                    cancelable: true
                };
                if (this.notifyPlugins("beforeDatasetDraw", args) === false) return;
                if (useClip) clipArea(ctx, {
                    left: clip.left === false ? 0 : area.left - clip.left,
                    right: clip.right === false ? this.width : area.right + clip.right,
                    top: clip.top === false ? 0 : area.top - clip.top,
                    bottom: clip.bottom === false ? this.height : area.bottom + clip.bottom
                });
                meta.controller.draw();
                if (useClip) unclipArea(ctx);
                args.cancelable = false;
                this.notifyPlugins("afterDatasetDraw", args);
            }
            isPointInArea(point) {
                return _isPointInArea(point, this.chartArea, this._minPadding);
            }
            getElementsAtEventForMode(e, mode, options, useFinalPosition) {
                const method = Interaction.modes[mode];
                if (typeof method === "function") return method(this, e, options, useFinalPosition);
                return [];
            }
            getDatasetMeta(datasetIndex) {
                const dataset = this.data.datasets[datasetIndex];
                const metasets = this._metasets;
                let meta = metasets.filter((x => x && x._dataset === dataset)).pop();
                if (!meta) {
                    meta = {
                        type: null,
                        data: [],
                        dataset: null,
                        controller: null,
                        hidden: null,
                        xAxisID: null,
                        yAxisID: null,
                        order: dataset && dataset.order || 0,
                        index: datasetIndex,
                        _dataset: dataset,
                        _parsed: [],
                        _sorted: false
                    };
                    metasets.push(meta);
                }
                return meta;
            }
            getContext() {
                return this.$context || (this.$context = createContext(null, {
                    chart: this,
                    type: "chart"
                }));
            }
            getVisibleDatasetCount() {
                return this.getSortedVisibleDatasetMetas().length;
            }
            isDatasetVisible(datasetIndex) {
                const dataset = this.data.datasets[datasetIndex];
                if (!dataset) return false;
                const meta = this.getDatasetMeta(datasetIndex);
                return typeof meta.hidden === "boolean" ? !meta.hidden : !dataset.hidden;
            }
            setDatasetVisibility(datasetIndex, visible) {
                const meta = this.getDatasetMeta(datasetIndex);
                meta.hidden = !visible;
            }
            toggleDataVisibility(index) {
                this._hiddenIndices[index] = !this._hiddenIndices[index];
            }
            getDataVisibility(index) {
                return !this._hiddenIndices[index];
            }
            _updateVisibility(datasetIndex, dataIndex, visible) {
                const mode = visible ? "show" : "hide";
                const meta = this.getDatasetMeta(datasetIndex);
                const anims = meta.controller._resolveAnimations(void 0, mode);
                if (defined(dataIndex)) {
                    meta.data[dataIndex].hidden = !visible;
                    this.update();
                } else {
                    this.setDatasetVisibility(datasetIndex, visible);
                    anims.update(meta, {
                        visible
                    });
                    this.update((ctx => ctx.datasetIndex === datasetIndex ? mode : void 0));
                }
            }
            hide(datasetIndex, dataIndex) {
                this._updateVisibility(datasetIndex, dataIndex, false);
            }
            show(datasetIndex, dataIndex) {
                this._updateVisibility(datasetIndex, dataIndex, true);
            }
            _destroyDatasetMeta(datasetIndex) {
                const meta = this._metasets[datasetIndex];
                if (meta && meta.controller) meta.controller._destroy();
                delete this._metasets[datasetIndex];
            }
            _stop() {
                let i, ilen;
                this.stop();
                animator.remove(this);
                for (i = 0, ilen = this.data.datasets.length; i < ilen; ++i) this._destroyDatasetMeta(i);
            }
            destroy() {
                this.notifyPlugins("beforeDestroy");
                const {canvas, ctx} = this;
                this._stop();
                this.config.clearCache();
                if (canvas) {
                    this.unbindEvents();
                    clearCanvas(canvas, ctx);
                    this.platform.releaseContext(ctx);
                    this.canvas = null;
                    this.ctx = null;
                }
                delete chart_instances[this.id];
                this.notifyPlugins("afterDestroy");
            }
            toBase64Image(...args) {
                return this.canvas.toDataURL(...args);
            }
            bindEvents() {
                this.bindUserEvents();
                if (this.options.responsive) this.bindResponsiveEvents(); else this.attached = true;
            }
            bindUserEvents() {
                const listeners = this._listeners;
                const platform = this.platform;
                const _add = (type, listener) => {
                    platform.addEventListener(this, type, listener);
                    listeners[type] = listener;
                };
                const listener = (e, x, y) => {
                    e.offsetX = x;
                    e.offsetY = y;
                    this._eventHandler(e);
                };
                each(this.options.events, (type => _add(type, listener)));
            }
            bindResponsiveEvents() {
                if (!this._responsiveListeners) this._responsiveListeners = {};
                const listeners = this._responsiveListeners;
                const platform = this.platform;
                const _add = (type, listener) => {
                    platform.addEventListener(this, type, listener);
                    listeners[type] = listener;
                };
                const _remove = (type, listener) => {
                    if (listeners[type]) {
                        platform.removeEventListener(this, type, listener);
                        delete listeners[type];
                    }
                };
                const listener = (width, height) => {
                    if (this.canvas) this.resize(width, height);
                };
                let detached;
                const attached = () => {
                    _remove("attach", attached);
                    this.attached = true;
                    this.resize();
                    _add("resize", listener);
                    _add("detach", detached);
                };
                detached = () => {
                    this.attached = false;
                    _remove("resize", listener);
                    this._stop();
                    this._resize(0, 0);
                    _add("attach", attached);
                };
                if (platform.isAttached(this.canvas)) attached(); else detached();
            }
            unbindEvents() {
                each(this._listeners, ((listener, type) => {
                    this.platform.removeEventListener(this, type, listener);
                }));
                this._listeners = {};
                each(this._responsiveListeners, ((listener, type) => {
                    this.platform.removeEventListener(this, type, listener);
                }));
                this._responsiveListeners = void 0;
            }
            updateHoverStyle(items, mode, enabled) {
                const prefix = enabled ? "set" : "remove";
                let meta, item, i, ilen;
                if (mode === "dataset") {
                    meta = this.getDatasetMeta(items[0].datasetIndex);
                    meta.controller["_" + prefix + "DatasetHoverStyle"]();
                }
                for (i = 0, ilen = items.length; i < ilen; ++i) {
                    item = items[i];
                    const controller = item && this.getDatasetMeta(item.datasetIndex).controller;
                    if (controller) controller[prefix + "HoverStyle"](item.element, item.datasetIndex, item.index);
                }
            }
            getActiveElements() {
                return this._active || [];
            }
            setActiveElements(activeElements) {
                const lastActive = this._active || [];
                const active = activeElements.map((({datasetIndex, index}) => {
                    const meta = this.getDatasetMeta(datasetIndex);
                    if (!meta) throw new Error("No dataset found at index " + datasetIndex);
                    return {
                        datasetIndex,
                        element: meta.data[index],
                        index
                    };
                }));
                const changed = !_elementsEqual(active, lastActive);
                if (changed) {
                    this._active = active;
                    this._lastEvent = null;
                    this._updateHoverStyles(active, lastActive);
                }
            }
            notifyPlugins(hook, args, filter) {
                return this._plugins.notify(this, hook, args, filter);
            }
            isPluginEnabled(pluginId) {
                return this._plugins._cache.filter((p => p.plugin.id === pluginId)).length === 1;
            }
            _updateHoverStyles(active, lastActive, replay) {
                const hoverOptions = this.options.hover;
                const diff = (a, b) => a.filter((x => !b.some((y => x.datasetIndex === y.datasetIndex && x.index === y.index))));
                const deactivated = diff(lastActive, active);
                const activated = replay ? active : diff(active, lastActive);
                if (deactivated.length) this.updateHoverStyle(deactivated, hoverOptions.mode, false);
                if (activated.length && hoverOptions.mode) this.updateHoverStyle(activated, hoverOptions.mode, true);
            }
            _eventHandler(e, replay) {
                const args = {
                    event: e,
                    replay,
                    cancelable: true,
                    inChartArea: this.isPointInArea(e)
                };
                const eventFilter = plugin => (plugin.options.events || this.options.events).includes(e.native.type);
                if (this.notifyPlugins("beforeEvent", args, eventFilter) === false) return;
                const changed = this._handleEvent(e, replay, args.inChartArea);
                args.cancelable = false;
                this.notifyPlugins("afterEvent", args, eventFilter);
                if (changed || args.changed) this.render();
                return this;
            }
            _handleEvent(e, replay, inChartArea) {
                const {_active: lastActive = [], options} = this;
                const useFinalPosition = replay;
                const active = this._getActiveElements(e, lastActive, inChartArea, useFinalPosition);
                const isClick = _isClickEvent(e);
                const lastEvent = determineLastEvent(e, this._lastEvent, inChartArea, isClick);
                if (inChartArea) {
                    this._lastEvent = null;
                    callback(options.onHover, [ e, active, this ], this);
                    if (isClick) callback(options.onClick, [ e, active, this ], this);
                }
                const changed = !_elementsEqual(active, lastActive);
                if (changed || replay) {
                    this._active = active;
                    this._updateHoverStyles(active, lastActive, replay);
                }
                this._lastEvent = lastEvent;
                return changed;
            }
            _getActiveElements(e, lastActive, inChartArea, useFinalPosition) {
                if (e.type === "mouseout") return [];
                if (!inChartArea) return lastActive;
                const hoverOptions = this.options.hover;
                return this.getElementsAtEventForMode(e, hoverOptions.mode, hoverOptions, useFinalPosition);
            }
        }
        function invalidatePlugins() {
            return each(chart_Chart.instances, (chart => chart._plugins.invalidate()));
        }
        function clipArc(ctx, element, endAngle) {
            const {startAngle, pixelMargin, x, y, outerRadius, innerRadius} = element;
            let angleMargin = pixelMargin / outerRadius;
            ctx.beginPath();
            ctx.arc(x, y, outerRadius, startAngle - angleMargin, endAngle + angleMargin);
            if (innerRadius > pixelMargin) {
                angleMargin = pixelMargin / innerRadius;
                ctx.arc(x, y, innerRadius, endAngle + angleMargin, startAngle - angleMargin, true);
            } else ctx.arc(x, y, pixelMargin, endAngle + HALF_PI, startAngle - HALF_PI);
            ctx.closePath();
            ctx.clip();
        }
        function toRadiusCorners(value) {
            return _readValueToProps(value, [ "outerStart", "outerEnd", "innerStart", "innerEnd" ]);
        }
        function parseBorderRadius$1(arc, innerRadius, outerRadius, angleDelta) {
            const o = toRadiusCorners(arc.options.borderRadius);
            const halfThickness = (outerRadius - innerRadius) / 2;
            const innerLimit = Math.min(halfThickness, angleDelta * innerRadius / 2);
            const computeOuterLimit = val => {
                const outerArcLimit = (outerRadius - Math.min(halfThickness, val)) * angleDelta / 2;
                return _limitValue(val, 0, Math.min(halfThickness, outerArcLimit));
            };
            return {
                outerStart: computeOuterLimit(o.outerStart),
                outerEnd: computeOuterLimit(o.outerEnd),
                innerStart: _limitValue(o.innerStart, 0, innerLimit),
                innerEnd: _limitValue(o.innerEnd, 0, innerLimit)
            };
        }
        function rThetaToXY(r, theta, x, y) {
            return {
                x: x + r * Math.cos(theta),
                y: y + r * Math.sin(theta)
            };
        }
        function pathArc(ctx, element, offset, spacing, end, circular) {
            const {x, y, startAngle: start, pixelMargin, innerRadius: innerR} = element;
            const outerRadius = Math.max(element.outerRadius + spacing + offset - pixelMargin, 0);
            const innerRadius = innerR > 0 ? innerR + spacing + offset + pixelMargin : 0;
            let spacingOffset = 0;
            const alpha = end - start;
            if (spacing) {
                const noSpacingInnerRadius = innerR > 0 ? innerR - spacing : 0;
                const noSpacingOuterRadius = outerRadius > 0 ? outerRadius - spacing : 0;
                const avNogSpacingRadius = (noSpacingInnerRadius + noSpacingOuterRadius) / 2;
                const adjustedAngle = avNogSpacingRadius !== 0 ? alpha * avNogSpacingRadius / (avNogSpacingRadius + spacing) : alpha;
                spacingOffset = (alpha - adjustedAngle) / 2;
            }
            const beta = Math.max(.001, alpha * outerRadius - offset / PI) / outerRadius;
            const angleOffset = (alpha - beta) / 2;
            const startAngle = start + angleOffset + spacingOffset;
            const endAngle = end - angleOffset - spacingOffset;
            const {outerStart, outerEnd, innerStart, innerEnd} = parseBorderRadius$1(element, innerRadius, outerRadius, endAngle - startAngle);
            const outerStartAdjustedRadius = outerRadius - outerStart;
            const outerEndAdjustedRadius = outerRadius - outerEnd;
            const outerStartAdjustedAngle = startAngle + outerStart / outerStartAdjustedRadius;
            const outerEndAdjustedAngle = endAngle - outerEnd / outerEndAdjustedRadius;
            const innerStartAdjustedRadius = innerRadius + innerStart;
            const innerEndAdjustedRadius = innerRadius + innerEnd;
            const innerStartAdjustedAngle = startAngle + innerStart / innerStartAdjustedRadius;
            const innerEndAdjustedAngle = endAngle - innerEnd / innerEndAdjustedRadius;
            ctx.beginPath();
            if (circular) {
                const outerMidAdjustedAngle = (outerStartAdjustedAngle + outerEndAdjustedAngle) / 2;
                ctx.arc(x, y, outerRadius, outerStartAdjustedAngle, outerMidAdjustedAngle);
                ctx.arc(x, y, outerRadius, outerMidAdjustedAngle, outerEndAdjustedAngle);
                if (outerEnd > 0) {
                    const pCenter = rThetaToXY(outerEndAdjustedRadius, outerEndAdjustedAngle, x, y);
                    ctx.arc(pCenter.x, pCenter.y, outerEnd, outerEndAdjustedAngle, endAngle + HALF_PI);
                }
                const p4 = rThetaToXY(innerEndAdjustedRadius, endAngle, x, y);
                ctx.lineTo(p4.x, p4.y);
                if (innerEnd > 0) {
                    const pCenter = rThetaToXY(innerEndAdjustedRadius, innerEndAdjustedAngle, x, y);
                    ctx.arc(pCenter.x, pCenter.y, innerEnd, endAngle + HALF_PI, innerEndAdjustedAngle + Math.PI);
                }
                const innerMidAdjustedAngle = (endAngle - innerEnd / innerRadius + (startAngle + innerStart / innerRadius)) / 2;
                ctx.arc(x, y, innerRadius, endAngle - innerEnd / innerRadius, innerMidAdjustedAngle, true);
                ctx.arc(x, y, innerRadius, innerMidAdjustedAngle, startAngle + innerStart / innerRadius, true);
                if (innerStart > 0) {
                    const pCenter = rThetaToXY(innerStartAdjustedRadius, innerStartAdjustedAngle, x, y);
                    ctx.arc(pCenter.x, pCenter.y, innerStart, innerStartAdjustedAngle + Math.PI, startAngle - HALF_PI);
                }
                const p8 = rThetaToXY(outerStartAdjustedRadius, startAngle, x, y);
                ctx.lineTo(p8.x, p8.y);
                if (outerStart > 0) {
                    const pCenter = rThetaToXY(outerStartAdjustedRadius, outerStartAdjustedAngle, x, y);
                    ctx.arc(pCenter.x, pCenter.y, outerStart, startAngle - HALF_PI, outerStartAdjustedAngle);
                }
            } else {
                ctx.moveTo(x, y);
                const outerStartX = Math.cos(outerStartAdjustedAngle) * outerRadius + x;
                const outerStartY = Math.sin(outerStartAdjustedAngle) * outerRadius + y;
                ctx.lineTo(outerStartX, outerStartY);
                const outerEndX = Math.cos(outerEndAdjustedAngle) * outerRadius + x;
                const outerEndY = Math.sin(outerEndAdjustedAngle) * outerRadius + y;
                ctx.lineTo(outerEndX, outerEndY);
            }
            ctx.closePath();
        }
        function drawArc(ctx, element, offset, spacing, circular) {
            const {fullCircles, startAngle, circumference} = element;
            let endAngle = element.endAngle;
            if (fullCircles) {
                pathArc(ctx, element, offset, spacing, endAngle, circular);
                for (let i = 0; i < fullCircles; ++i) ctx.fill();
                if (!isNaN(circumference)) endAngle = startAngle + (circumference % TAU || TAU);
            }
            pathArc(ctx, element, offset, spacing, endAngle, circular);
            ctx.fill();
            return endAngle;
        }
        function drawBorder(ctx, element, offset, spacing, circular) {
            const {fullCircles, startAngle, circumference, options} = element;
            const {borderWidth, borderJoinStyle, borderDash, borderDashOffset} = options;
            const inner = options.borderAlign === "inner";
            if (!borderWidth) return;
            ctx.setLineDash(borderDash || []);
            ctx.lineDashOffset = borderDashOffset;
            if (inner) {
                ctx.lineWidth = borderWidth * 2;
                ctx.lineJoin = borderJoinStyle || "round";
            } else {
                ctx.lineWidth = borderWidth;
                ctx.lineJoin = borderJoinStyle || "bevel";
            }
            let endAngle = element.endAngle;
            if (fullCircles) {
                pathArc(ctx, element, offset, spacing, endAngle, circular);
                for (let i = 0; i < fullCircles; ++i) ctx.stroke();
                if (!isNaN(circumference)) endAngle = startAngle + (circumference % TAU || TAU);
            }
            if (inner) clipArc(ctx, element, endAngle);
            if (!fullCircles) {
                pathArc(ctx, element, offset, spacing, endAngle, circular);
                ctx.stroke();
            }
        }
        class ArcElement extends chart_Element {
            static id="arc";
            static defaults={
                borderAlign: "center",
                borderColor: "#fff",
                borderDash: [],
                borderDashOffset: 0,
                borderJoinStyle: void 0,
                borderRadius: 0,
                borderWidth: 2,
                offset: 0,
                spacing: 0,
                angle: void 0,
                circular: true
            };
            static defaultRoutes={
                backgroundColor: "backgroundColor"
            };
            static descriptors={
                _scriptable: true,
                _indexable: name => name !== "borderDash"
            };
            circumference;
            endAngle;
            fullCircles;
            innerRadius;
            outerRadius;
            pixelMargin;
            startAngle;
            constructor(cfg) {
                super();
                this.options = void 0;
                this.circumference = void 0;
                this.startAngle = void 0;
                this.endAngle = void 0;
                this.innerRadius = void 0;
                this.outerRadius = void 0;
                this.pixelMargin = 0;
                this.fullCircles = 0;
                if (cfg) Object.assign(this, cfg);
            }
            inRange(chartX, chartY, useFinalPosition) {
                const point = this.getProps([ "x", "y" ], useFinalPosition);
                const {angle, distance} = getAngleFromPoint(point, {
                    x: chartX,
                    y: chartY
                });
                const {startAngle, endAngle, innerRadius, outerRadius, circumference} = this.getProps([ "startAngle", "endAngle", "innerRadius", "outerRadius", "circumference" ], useFinalPosition);
                const rAdjust = (this.options.spacing + this.options.borderWidth) / 2;
                const _circumference = valueOrDefault(circumference, endAngle - startAngle);
                const nonZeroBetween = _angleBetween(angle, startAngle, endAngle) && startAngle !== endAngle;
                const betweenAngles = _circumference >= TAU || nonZeroBetween;
                const withinRadius = _isBetween(distance, innerRadius + rAdjust, outerRadius + rAdjust);
                return betweenAngles && withinRadius;
            }
            getCenterPoint(useFinalPosition) {
                const {x, y, startAngle, endAngle, innerRadius, outerRadius} = this.getProps([ "x", "y", "startAngle", "endAngle", "innerRadius", "outerRadius" ], useFinalPosition);
                const {offset, spacing} = this.options;
                const halfAngle = (startAngle + endAngle) / 2;
                const halfRadius = (innerRadius + outerRadius + spacing + offset) / 2;
                return {
                    x: x + Math.cos(halfAngle) * halfRadius,
                    y: y + Math.sin(halfAngle) * halfRadius
                };
            }
            tooltipPosition(useFinalPosition) {
                return this.getCenterPoint(useFinalPosition);
            }
            draw(ctx) {
                const {options, circumference} = this;
                const offset = (options.offset || 0) / 4;
                const spacing = (options.spacing || 0) / 2;
                const circular = options.circular;
                this.pixelMargin = options.borderAlign === "inner" ? .33 : 0;
                this.fullCircles = circumference > TAU ? Math.floor(circumference / TAU) : 0;
                if (circumference === 0 || this.innerRadius < 0 || this.outerRadius < 0) return;
                ctx.save();
                const halfAngle = (this.startAngle + this.endAngle) / 2;
                ctx.translate(Math.cos(halfAngle) * offset, Math.sin(halfAngle) * offset);
                const fix = 1 - Math.sin(Math.min(PI, circumference || 0));
                const radiusOffset = offset * fix;
                ctx.fillStyle = options.backgroundColor;
                ctx.strokeStyle = options.borderColor;
                drawArc(ctx, this, radiusOffset, spacing, circular);
                drawBorder(ctx, this, radiusOffset, spacing, circular);
                ctx.restore();
            }
        }
        function setStyle(ctx, options, style = options) {
            ctx.lineCap = valueOrDefault(style.borderCapStyle, options.borderCapStyle);
            ctx.setLineDash(valueOrDefault(style.borderDash, options.borderDash));
            ctx.lineDashOffset = valueOrDefault(style.borderDashOffset, options.borderDashOffset);
            ctx.lineJoin = valueOrDefault(style.borderJoinStyle, options.borderJoinStyle);
            ctx.lineWidth = valueOrDefault(style.borderWidth, options.borderWidth);
            ctx.strokeStyle = valueOrDefault(style.borderColor, options.borderColor);
        }
        function lineTo(ctx, previous, target) {
            ctx.lineTo(target.x, target.y);
        }
        function getLineMethod(options) {
            if (options.stepped) return _steppedLineTo;
            if (options.tension || options.cubicInterpolationMode === "monotone") return _bezierCurveTo;
            return lineTo;
        }
        function pathVars(points, segment, params = {}) {
            const count = points.length;
            const {start: paramsStart = 0, end: paramsEnd = count - 1} = params;
            const {start: segmentStart, end: segmentEnd} = segment;
            const start = Math.max(paramsStart, segmentStart);
            const end = Math.min(paramsEnd, segmentEnd);
            const outside = paramsStart < segmentStart && paramsEnd < segmentStart || paramsStart > segmentEnd && paramsEnd > segmentEnd;
            return {
                count,
                start,
                loop: segment.loop,
                ilen: end < start && !outside ? count + end - start : end - start
            };
        }
        function pathSegment(ctx, line, segment, params) {
            const {points, options} = line;
            const {count, start, loop, ilen} = pathVars(points, segment, params);
            const lineMethod = getLineMethod(options);
            let {move = true, reverse} = params || {};
            let i, point, prev;
            for (i = 0; i <= ilen; ++i) {
                point = points[(start + (reverse ? ilen - i : i)) % count];
                if (point.skip) continue; else if (move) {
                    ctx.moveTo(point.x, point.y);
                    move = false;
                } else lineMethod(ctx, prev, point, reverse, options.stepped);
                prev = point;
            }
            if (loop) {
                point = points[(start + (reverse ? ilen : 0)) % count];
                lineMethod(ctx, prev, point, reverse, options.stepped);
            }
            return !!loop;
        }
        function fastPathSegment(ctx, line, segment, params) {
            const points = line.points;
            const {count, start, ilen} = pathVars(points, segment, params);
            const {move = true, reverse} = params || {};
            let avgX = 0;
            let countX = 0;
            let i, point, prevX, minY, maxY, lastY;
            const pointIndex = index => (start + (reverse ? ilen - index : index)) % count;
            const drawX = () => {
                if (minY !== maxY) {
                    ctx.lineTo(avgX, maxY);
                    ctx.lineTo(avgX, minY);
                    ctx.lineTo(avgX, lastY);
                }
            };
            if (move) {
                point = points[pointIndex(0)];
                ctx.moveTo(point.x, point.y);
            }
            for (i = 0; i <= ilen; ++i) {
                point = points[pointIndex(i)];
                if (point.skip) continue;
                const x = point.x;
                const y = point.y;
                const truncX = x | 0;
                if (truncX === prevX) {
                    if (y < minY) minY = y; else if (y > maxY) maxY = y;
                    avgX = (countX * avgX + x) / ++countX;
                } else {
                    drawX();
                    ctx.lineTo(x, y);
                    prevX = truncX;
                    countX = 0;
                    minY = maxY = y;
                }
                lastY = y;
            }
            drawX();
        }
        function _getSegmentMethod(line) {
            const opts = line.options;
            const borderDash = opts.borderDash && opts.borderDash.length;
            const useFastPath = !line._decimated && !line._loop && !opts.tension && opts.cubicInterpolationMode !== "monotone" && !opts.stepped && !borderDash;
            return useFastPath ? fastPathSegment : pathSegment;
        }
        function _getInterpolationMethod(options) {
            if (options.stepped) return _steppedInterpolation;
            if (options.tension || options.cubicInterpolationMode === "monotone") return _bezierInterpolation;
            return _pointInLine;
        }
        function strokePathWithCache(ctx, line, start, count) {
            let path = line._path;
            if (!path) {
                path = line._path = new Path2D;
                if (line.path(path, start, count)) path.closePath();
            }
            setStyle(ctx, line.options);
            ctx.stroke(path);
        }
        function strokePathDirect(ctx, line, start, count) {
            const {segments, options} = line;
            const segmentMethod = _getSegmentMethod(line);
            for (const segment of segments) {
                setStyle(ctx, options, segment.style);
                ctx.beginPath();
                if (segmentMethod(ctx, line, segment, {
                    start,
                    end: start + count - 1
                })) ctx.closePath();
                ctx.stroke();
            }
        }
        const usePath2D = typeof Path2D === "function";
        function draw(ctx, line, start, count) {
            if (usePath2D && !line.options.segment) strokePathWithCache(ctx, line, start, count); else strokePathDirect(ctx, line, start, count);
        }
        class LineElement extends chart_Element {
            static id="line";
            static defaults={
                borderCapStyle: "butt",
                borderDash: [],
                borderDashOffset: 0,
                borderJoinStyle: "miter",
                borderWidth: 3,
                capBezierPoints: true,
                cubicInterpolationMode: "default",
                fill: false,
                spanGaps: false,
                stepped: false,
                tension: 0
            };
            static defaultRoutes={
                backgroundColor: "backgroundColor",
                borderColor: "borderColor"
            };
            static descriptors={
                _scriptable: true,
                _indexable: name => name !== "borderDash" && name !== "fill"
            };
            constructor(cfg) {
                super();
                this.animated = true;
                this.options = void 0;
                this._chart = void 0;
                this._loop = void 0;
                this._fullLoop = void 0;
                this._path = void 0;
                this._points = void 0;
                this._segments = void 0;
                this._decimated = false;
                this._pointsUpdated = false;
                this._datasetIndex = void 0;
                if (cfg) Object.assign(this, cfg);
            }
            updateControlPoints(chartArea, indexAxis) {
                const options = this.options;
                if ((options.tension || options.cubicInterpolationMode === "monotone") && !options.stepped && !this._pointsUpdated) {
                    const loop = options.spanGaps ? this._loop : this._fullLoop;
                    _updateBezierControlPoints(this._points, options, chartArea, loop, indexAxis);
                    this._pointsUpdated = true;
                }
            }
            set points(points) {
                this._points = points;
                delete this._segments;
                delete this._path;
                this._pointsUpdated = false;
            }
            get points() {
                return this._points;
            }
            get segments() {
                return this._segments || (this._segments = _computeSegments(this, this.options.segment));
            }
            first() {
                const segments = this.segments;
                const points = this.points;
                return segments.length && points[segments[0].start];
            }
            last() {
                const segments = this.segments;
                const points = this.points;
                const count = segments.length;
                return count && points[segments[count - 1].end];
            }
            interpolate(point, property) {
                const options = this.options;
                const value = point[property];
                const points = this.points;
                const segments = _boundSegments(this, {
                    property,
                    start: value,
                    end: value
                });
                if (!segments.length) return;
                const result = [];
                const _interpolate = _getInterpolationMethod(options);
                let i, ilen;
                for (i = 0, ilen = segments.length; i < ilen; ++i) {
                    const {start, end} = segments[i];
                    const p1 = points[start];
                    const p2 = points[end];
                    if (p1 === p2) {
                        result.push(p1);
                        continue;
                    }
                    const t = Math.abs((value - p1[property]) / (p2[property] - p1[property]));
                    const interpolated = _interpolate(p1, p2, t, options.stepped);
                    interpolated[property] = point[property];
                    result.push(interpolated);
                }
                return result.length === 1 ? result[0] : result;
            }
            pathSegment(ctx, segment, params) {
                const segmentMethod = _getSegmentMethod(this);
                return segmentMethod(ctx, this, segment, params);
            }
            path(ctx, start, count) {
                const segments = this.segments;
                const segmentMethod = _getSegmentMethod(this);
                let loop = this._loop;
                start = start || 0;
                count = count || this.points.length - start;
                for (const segment of segments) loop &= segmentMethod(ctx, this, segment, {
                    start,
                    end: start + count - 1
                });
                return !!loop;
            }
            draw(ctx, chartArea, start, count) {
                const options = this.options || {};
                const points = this.points || [];
                if (points.length && options.borderWidth) {
                    ctx.save();
                    draw(ctx, this, start, count);
                    ctx.restore();
                }
                if (this.animated) {
                    this._pointsUpdated = false;
                    this._path = void 0;
                }
            }
        }
        function inRange$1(el, pos, axis, useFinalPosition) {
            const options = el.options;
            const {[axis]: value} = el.getProps([ axis ], useFinalPosition);
            return Math.abs(pos - value) < options.radius + options.hitRadius;
        }
        class PointElement extends chart_Element {
            static id="point";
            parsed;
            skip;
            stop;
            static defaults={
                borderWidth: 1,
                hitRadius: 1,
                hoverBorderWidth: 1,
                hoverRadius: 4,
                pointStyle: "circle",
                radius: 3,
                rotation: 0
            };
            static defaultRoutes={
                backgroundColor: "backgroundColor",
                borderColor: "borderColor"
            };
            constructor(cfg) {
                super();
                this.options = void 0;
                this.parsed = void 0;
                this.skip = void 0;
                this.stop = void 0;
                if (cfg) Object.assign(this, cfg);
            }
            inRange(mouseX, mouseY, useFinalPosition) {
                const options = this.options;
                const {x, y} = this.getProps([ "x", "y" ], useFinalPosition);
                return Math.pow(mouseX - x, 2) + Math.pow(mouseY - y, 2) < Math.pow(options.hitRadius + options.radius, 2);
            }
            inXRange(mouseX, useFinalPosition) {
                return inRange$1(this, mouseX, "x", useFinalPosition);
            }
            inYRange(mouseY, useFinalPosition) {
                return inRange$1(this, mouseY, "y", useFinalPosition);
            }
            getCenterPoint(useFinalPosition) {
                const {x, y} = this.getProps([ "x", "y" ], useFinalPosition);
                return {
                    x,
                    y
                };
            }
            size(options) {
                options = options || this.options || {};
                let radius = options.radius || 0;
                radius = Math.max(radius, radius && options.hoverRadius || 0);
                const borderWidth = radius && options.borderWidth || 0;
                return (radius + borderWidth) * 2;
            }
            draw(ctx, area) {
                const options = this.options;
                if (this.skip || options.radius < .1 || !_isPointInArea(this, area, this.size(options) / 2)) return;
                ctx.strokeStyle = options.borderColor;
                ctx.lineWidth = options.borderWidth;
                ctx.fillStyle = options.backgroundColor;
                drawPoint(ctx, options, this.x, this.y);
            }
            getRange() {
                const options = this.options || {};
                return options.radius + options.hitRadius;
            }
        }
        function getBarBounds(bar, useFinalPosition) {
            const {x, y, base, width, height} = bar.getProps([ "x", "y", "base", "width", "height" ], useFinalPosition);
            let left, right, top, bottom, half;
            if (bar.horizontal) {
                half = height / 2;
                left = Math.min(x, base);
                right = Math.max(x, base);
                top = y - half;
                bottom = y + half;
            } else {
                half = width / 2;
                left = x - half;
                right = x + half;
                top = Math.min(y, base);
                bottom = Math.max(y, base);
            }
            return {
                left,
                top,
                right,
                bottom
            };
        }
        function skipOrLimit(skip, value, min, max) {
            return skip ? 0 : _limitValue(value, min, max);
        }
        function parseBorderWidth(bar, maxW, maxH) {
            const value = bar.options.borderWidth;
            const skip = bar.borderSkipped;
            const o = toTRBL(value);
            return {
                t: skipOrLimit(skip.top, o.top, 0, maxH),
                r: skipOrLimit(skip.right, o.right, 0, maxW),
                b: skipOrLimit(skip.bottom, o.bottom, 0, maxH),
                l: skipOrLimit(skip.left, o.left, 0, maxW)
            };
        }
        function parseBorderRadius(bar, maxW, maxH) {
            const {enableBorderRadius} = bar.getProps([ "enableBorderRadius" ]);
            const value = bar.options.borderRadius;
            const o = toTRBLCorners(value);
            const maxR = Math.min(maxW, maxH);
            const skip = bar.borderSkipped;
            const enableBorder = enableBorderRadius || helpers_segment_isObject(value);
            return {
                topLeft: skipOrLimit(!enableBorder || skip.top || skip.left, o.topLeft, 0, maxR),
                topRight: skipOrLimit(!enableBorder || skip.top || skip.right, o.topRight, 0, maxR),
                bottomLeft: skipOrLimit(!enableBorder || skip.bottom || skip.left, o.bottomLeft, 0, maxR),
                bottomRight: skipOrLimit(!enableBorder || skip.bottom || skip.right, o.bottomRight, 0, maxR)
            };
        }
        function boundingRects(bar) {
            const bounds = getBarBounds(bar);
            const width = bounds.right - bounds.left;
            const height = bounds.bottom - bounds.top;
            const border = parseBorderWidth(bar, width / 2, height / 2);
            const radius = parseBorderRadius(bar, width / 2, height / 2);
            return {
                outer: {
                    x: bounds.left,
                    y: bounds.top,
                    w: width,
                    h: height,
                    radius
                },
                inner: {
                    x: bounds.left + border.l,
                    y: bounds.top + border.t,
                    w: width - border.l - border.r,
                    h: height - border.t - border.b,
                    radius: {
                        topLeft: Math.max(0, radius.topLeft - Math.max(border.t, border.l)),
                        topRight: Math.max(0, radius.topRight - Math.max(border.t, border.r)),
                        bottomLeft: Math.max(0, radius.bottomLeft - Math.max(border.b, border.l)),
                        bottomRight: Math.max(0, radius.bottomRight - Math.max(border.b, border.r))
                    }
                }
            };
        }
        function inRange(bar, x, y, useFinalPosition) {
            const skipX = x === null;
            const skipY = y === null;
            const skipBoth = skipX && skipY;
            const bounds = bar && !skipBoth && getBarBounds(bar, useFinalPosition);
            return bounds && (skipX || _isBetween(x, bounds.left, bounds.right)) && (skipY || _isBetween(y, bounds.top, bounds.bottom));
        }
        function hasRadius(radius) {
            return radius.topLeft || radius.topRight || radius.bottomLeft || radius.bottomRight;
        }
        function addNormalRectPath(ctx, rect) {
            ctx.rect(rect.x, rect.y, rect.w, rect.h);
        }
        function inflateRect(rect, amount, refRect = {}) {
            const x = rect.x !== refRect.x ? -amount : 0;
            const y = rect.y !== refRect.y ? -amount : 0;
            const w = (rect.x + rect.w !== refRect.x + refRect.w ? amount : 0) - x;
            const h = (rect.y + rect.h !== refRect.y + refRect.h ? amount : 0) - y;
            return {
                x: rect.x + x,
                y: rect.y + y,
                w: rect.w + w,
                h: rect.h + h,
                radius: rect.radius
            };
        }
        class BarElement extends chart_Element {
            static id="bar";
            static defaults={
                borderSkipped: "start",
                borderWidth: 0,
                borderRadius: 0,
                inflateAmount: "auto",
                pointStyle: void 0
            };
            static defaultRoutes={
                backgroundColor: "backgroundColor",
                borderColor: "borderColor"
            };
            constructor(cfg) {
                super();
                this.options = void 0;
                this.horizontal = void 0;
                this.base = void 0;
                this.width = void 0;
                this.height = void 0;
                this.inflateAmount = void 0;
                if (cfg) Object.assign(this, cfg);
            }
            draw(ctx) {
                const {inflateAmount, options: {borderColor, backgroundColor}} = this;
                const {inner, outer} = boundingRects(this);
                const addRectPath = hasRadius(outer.radius) ? addRoundedRectPath : addNormalRectPath;
                ctx.save();
                if (outer.w !== inner.w || outer.h !== inner.h) {
                    ctx.beginPath();
                    addRectPath(ctx, inflateRect(outer, inflateAmount, inner));
                    ctx.clip();
                    addRectPath(ctx, inflateRect(inner, -inflateAmount, outer));
                    ctx.fillStyle = borderColor;
                    ctx.fill("evenodd");
                }
                ctx.beginPath();
                addRectPath(ctx, inflateRect(inner, inflateAmount));
                ctx.fillStyle = backgroundColor;
                ctx.fill();
                ctx.restore();
            }
            inRange(mouseX, mouseY, useFinalPosition) {
                return inRange(this, mouseX, mouseY, useFinalPosition);
            }
            inXRange(mouseX, useFinalPosition) {
                return inRange(this, mouseX, null, useFinalPosition);
            }
            inYRange(mouseY, useFinalPosition) {
                return inRange(this, null, mouseY, useFinalPosition);
            }
            getCenterPoint(useFinalPosition) {
                const {x, y, base, horizontal} = this.getProps([ "x", "y", "base", "horizontal" ], useFinalPosition);
                return {
                    x: horizontal ? (x + base) / 2 : x,
                    y: horizontal ? y : (y + base) / 2
                };
            }
            getRange(axis) {
                return axis === "x" ? this.width / 2 : this.height / 2;
            }
        }
        var chart_elements = Object.freeze({
            __proto__: null,
            ArcElement,
            BarElement,
            LineElement,
            PointElement
        });
        const BORDER_COLORS = [ "rgb(54, 162, 235)", "rgb(255, 99, 132)", "rgb(255, 159, 64)", "rgb(255, 205, 86)", "rgb(75, 192, 192)", "rgb(153, 102, 255)", "rgb(201, 203, 207)" ];
        const BACKGROUND_COLORS = BORDER_COLORS.map((color => color.replace("rgb(", "rgba(").replace(")", ", 0.5)")));
        function getBorderColor(i) {
            return BORDER_COLORS[i % BORDER_COLORS.length];
        }
        function getBackgroundColor(i) {
            return BACKGROUND_COLORS[i % BACKGROUND_COLORS.length];
        }
        function colorizeDefaultDataset(dataset, i) {
            dataset.borderColor = getBorderColor(i);
            dataset.backgroundColor = getBackgroundColor(i);
            return ++i;
        }
        function colorizeDoughnutDataset(dataset, i) {
            dataset.backgroundColor = dataset.data.map((() => getBorderColor(i++)));
            return i;
        }
        function colorizePolarAreaDataset(dataset, i) {
            dataset.backgroundColor = dataset.data.map((() => getBackgroundColor(i++)));
            return i;
        }
        function getColorizer(chart) {
            let i = 0;
            return (dataset, datasetIndex) => {
                const controller = chart.getDatasetMeta(datasetIndex).controller;
                if (controller instanceof DoughnutController) i = colorizeDoughnutDataset(dataset, i); else if (controller instanceof PolarAreaController) i = colorizePolarAreaDataset(dataset, i); else if (controller) i = colorizeDefaultDataset(dataset, i);
            };
        }
        function containsColorsDefinitions(descriptors) {
            let k;
            for (k in descriptors) if (descriptors[k].borderColor || descriptors[k].backgroundColor) return true;
            return false;
        }
        function containsColorsDefinition(descriptor) {
            return descriptor && (descriptor.borderColor || descriptor.backgroundColor);
        }
        function containsDefaultColorsDefenitions() {
            return defaults.borderColor !== "rgba(0,0,0,0.1)" || defaults.backgroundColor !== "rgba(0,0,0,0.1)";
        }
        var plugin_colors = {
            id: "colors",
            defaults: {
                enabled: true,
                forceOverride: false
            },
            beforeLayout(chart, _args, options) {
                if (!options.enabled) return;
                const {data: {datasets}, options: chartOptions} = chart.config;
                const {elements} = chartOptions;
                const containsColorDefenition = containsColorsDefinitions(datasets) || containsColorsDefinition(chartOptions) || elements && containsColorsDefinitions(elements) || containsDefaultColorsDefenitions();
                if (!options.forceOverride && containsColorDefenition) return;
                const colorizer = getColorizer(chart);
                datasets.forEach(colorizer);
            }
        };
        function lttbDecimation(data, start, count, availableWidth, options) {
            const samples = options.samples || availableWidth;
            if (samples >= count) return data.slice(start, start + count);
            const decimated = [];
            const bucketWidth = (count - 2) / (samples - 2);
            let sampledIndex = 0;
            const endIndex = start + count - 1;
            let a = start;
            let i, maxAreaPoint, maxArea, area, nextA;
            decimated[sampledIndex++] = data[a];
            for (i = 0; i < samples - 2; i++) {
                let avgX = 0;
                let avgY = 0;
                let j;
                const avgRangeStart = Math.floor((i + 1) * bucketWidth) + 1 + start;
                const avgRangeEnd = Math.min(Math.floor((i + 2) * bucketWidth) + 1, count) + start;
                const avgRangeLength = avgRangeEnd - avgRangeStart;
                for (j = avgRangeStart; j < avgRangeEnd; j++) {
                    avgX += data[j].x;
                    avgY += data[j].y;
                }
                avgX /= avgRangeLength;
                avgY /= avgRangeLength;
                const rangeOffs = Math.floor(i * bucketWidth) + 1 + start;
                const rangeTo = Math.min(Math.floor((i + 1) * bucketWidth) + 1, count) + start;
                const {x: pointAx, y: pointAy} = data[a];
                maxArea = area = -1;
                for (j = rangeOffs; j < rangeTo; j++) {
                    area = .5 * Math.abs((pointAx - avgX) * (data[j].y - pointAy) - (pointAx - data[j].x) * (avgY - pointAy));
                    if (area > maxArea) {
                        maxArea = area;
                        maxAreaPoint = data[j];
                        nextA = j;
                    }
                }
                decimated[sampledIndex++] = maxAreaPoint;
                a = nextA;
            }
            decimated[sampledIndex++] = data[endIndex];
            return decimated;
        }
        function minMaxDecimation(data, start, count, availableWidth) {
            let avgX = 0;
            let countX = 0;
            let i, point, x, y, prevX, minIndex, maxIndex, startIndex, minY, maxY;
            const decimated = [];
            const endIndex = start + count - 1;
            const xMin = data[start].x;
            const xMax = data[endIndex].x;
            const dx = xMax - xMin;
            for (i = start; i < start + count; ++i) {
                point = data[i];
                x = (point.x - xMin) / dx * availableWidth;
                y = point.y;
                const truncX = x | 0;
                if (truncX === prevX) {
                    if (y < minY) {
                        minY = y;
                        minIndex = i;
                    } else if (y > maxY) {
                        maxY = y;
                        maxIndex = i;
                    }
                    avgX = (countX * avgX + point.x) / ++countX;
                } else {
                    const lastIndex = i - 1;
                    if (!isNullOrUndef(minIndex) && !isNullOrUndef(maxIndex)) {
                        const intermediateIndex1 = Math.min(minIndex, maxIndex);
                        const intermediateIndex2 = Math.max(minIndex, maxIndex);
                        if (intermediateIndex1 !== startIndex && intermediateIndex1 !== lastIndex) decimated.push({
                            ...data[intermediateIndex1],
                            x: avgX
                        });
                        if (intermediateIndex2 !== startIndex && intermediateIndex2 !== lastIndex) decimated.push({
                            ...data[intermediateIndex2],
                            x: avgX
                        });
                    }
                    if (i > 0 && lastIndex !== startIndex) decimated.push(data[lastIndex]);
                    decimated.push(point);
                    prevX = truncX;
                    countX = 0;
                    minY = maxY = y;
                    minIndex = maxIndex = startIndex = i;
                }
            }
            return decimated;
        }
        function cleanDecimatedDataset(dataset) {
            if (dataset._decimated) {
                const data = dataset._data;
                delete dataset._decimated;
                delete dataset._data;
                Object.defineProperty(dataset, "data", {
                    configurable: true,
                    enumerable: true,
                    writable: true,
                    value: data
                });
            }
        }
        function cleanDecimatedData(chart) {
            chart.data.datasets.forEach((dataset => {
                cleanDecimatedDataset(dataset);
            }));
        }
        function getStartAndCountOfVisiblePointsSimplified(meta, points) {
            const pointCount = points.length;
            let start = 0;
            let count;
            const {iScale} = meta;
            const {min, max, minDefined, maxDefined} = iScale.getUserBounds();
            if (minDefined) start = _limitValue(_lookupByKey(points, iScale.axis, min).lo, 0, pointCount - 1);
            if (maxDefined) count = _limitValue(_lookupByKey(points, iScale.axis, max).hi + 1, start, pointCount) - start; else count = pointCount - start;
            return {
                start,
                count
            };
        }
        var plugin_decimation = {
            id: "decimation",
            defaults: {
                algorithm: "min-max",
                enabled: false
            },
            beforeElementsUpdate: (chart, args, options) => {
                if (!options.enabled) {
                    cleanDecimatedData(chart);
                    return;
                }
                const availableWidth = chart.width;
                chart.data.datasets.forEach(((dataset, datasetIndex) => {
                    const {_data, indexAxis} = dataset;
                    const meta = chart.getDatasetMeta(datasetIndex);
                    const data = _data || dataset.data;
                    if (resolve([ indexAxis, chart.options.indexAxis ]) === "y") return;
                    if (!meta.controller.supportsDecimation) return;
                    const xAxis = chart.scales[meta.xAxisID];
                    if (xAxis.type !== "linear" && xAxis.type !== "time") return;
                    if (chart.options.parsing) return;
                    let {start, count} = getStartAndCountOfVisiblePointsSimplified(meta, data);
                    const threshold = options.threshold || 4 * availableWidth;
                    if (count <= threshold) {
                        cleanDecimatedDataset(dataset);
                        return;
                    }
                    if (isNullOrUndef(_data)) {
                        dataset._data = data;
                        delete dataset.data;
                        Object.defineProperty(dataset, "data", {
                            configurable: true,
                            enumerable: true,
                            get: function() {
                                return this._decimated;
                            },
                            set: function(d) {
                                this._data = d;
                            }
                        });
                    }
                    let decimated;
                    switch (options.algorithm) {
                      case "lttb":
                        decimated = lttbDecimation(data, start, count, availableWidth, options);
                        break;

                      case "min-max":
                        decimated = minMaxDecimation(data, start, count, availableWidth);
                        break;

                      default:
                        throw new Error(`Unsupported decimation algorithm '${options.algorithm}'`);
                    }
                    dataset._decimated = decimated;
                }));
            },
            destroy(chart) {
                cleanDecimatedData(chart);
            }
        };
        function _segments(line, target, property) {
            const segments = line.segments;
            const points = line.points;
            const tpoints = target.points;
            const parts = [];
            for (const segment of segments) {
                let {start, end} = segment;
                end = _findSegmentEnd(start, end, points);
                const bounds = _getBounds(property, points[start], points[end], segment.loop);
                if (!target.segments) {
                    parts.push({
                        source: segment,
                        target: bounds,
                        start: points[start],
                        end: points[end]
                    });
                    continue;
                }
                const targetSegments = _boundSegments(target, bounds);
                for (const tgt of targetSegments) {
                    const subBounds = _getBounds(property, tpoints[tgt.start], tpoints[tgt.end], tgt.loop);
                    const fillSources = _boundSegment(segment, points, subBounds);
                    for (const fillSource of fillSources) parts.push({
                        source: fillSource,
                        target: tgt,
                        start: {
                            [property]: _getEdge(bounds, subBounds, "start", Math.max)
                        },
                        end: {
                            [property]: _getEdge(bounds, subBounds, "end", Math.min)
                        }
                    });
                }
            }
            return parts;
        }
        function _getBounds(property, first, last, loop) {
            if (loop) return;
            let start = first[property];
            let end = last[property];
            if (property === "angle") {
                start = _normalizeAngle(start);
                end = _normalizeAngle(end);
            }
            return {
                property,
                start,
                end
            };
        }
        function _pointsFromSegments(boundary, line) {
            const {x = null, y = null} = boundary || {};
            const linePoints = line.points;
            const points = [];
            line.segments.forEach((({start, end}) => {
                end = _findSegmentEnd(start, end, linePoints);
                const first = linePoints[start];
                const last = linePoints[end];
                if (y !== null) {
                    points.push({
                        x: first.x,
                        y
                    });
                    points.push({
                        x: last.x,
                        y
                    });
                } else if (x !== null) {
                    points.push({
                        x,
                        y: first.y
                    });
                    points.push({
                        x,
                        y: last.y
                    });
                }
            }));
            return points;
        }
        function _findSegmentEnd(start, end, points) {
            for (;end > start; end--) {
                const point = points[end];
                if (!isNaN(point.x) && !isNaN(point.y)) break;
            }
            return end;
        }
        function _getEdge(a, b, prop, fn) {
            if (a && b) return fn(a[prop], b[prop]);
            return a ? a[prop] : b ? b[prop] : 0;
        }
        function _createBoundaryLine(boundary, line) {
            let points = [];
            let _loop = false;
            if (isArray(boundary)) {
                _loop = true;
                points = boundary;
            } else points = _pointsFromSegments(boundary, line);
            return points.length ? new LineElement({
                points,
                options: {
                    tension: 0
                },
                _loop,
                _fullLoop: _loop
            }) : null;
        }
        function _shouldApplyFill(source) {
            return source && source.fill !== false;
        }
        function _resolveTarget(sources, index, propagate) {
            const source = sources[index];
            let fill = source.fill;
            const visited = [ index ];
            let target;
            if (!propagate) return fill;
            while (fill !== false && visited.indexOf(fill) === -1) {
                if (!isNumberFinite(fill)) return fill;
                target = sources[fill];
                if (!target) return false;
                if (target.visible) return fill;
                visited.push(fill);
                fill = target.fill;
            }
            return false;
        }
        function _decodeFill(line, index, count) {
            const fill = parseFillOption(line);
            if (helpers_segment_isObject(fill)) return isNaN(fill.value) ? false : fill;
            let target = parseFloat(fill);
            if (isNumberFinite(target) && Math.floor(target) === target) return decodeTargetIndex(fill[0], index, target, count);
            return [ "origin", "start", "end", "stack", "shape" ].indexOf(fill) >= 0 && fill;
        }
        function decodeTargetIndex(firstCh, index, target, count) {
            if (firstCh === "-" || firstCh === "+") target = index + target;
            if (target === index || target < 0 || target >= count) return false;
            return target;
        }
        function _getTargetPixel(fill, scale) {
            let pixel = null;
            if (fill === "start") pixel = scale.bottom; else if (fill === "end") pixel = scale.top; else if (helpers_segment_isObject(fill)) pixel = scale.getPixelForValue(fill.value); else if (scale.getBasePixel) pixel = scale.getBasePixel();
            return pixel;
        }
        function _getTargetValue(fill, scale, startValue) {
            let value;
            if (fill === "start") value = startValue; else if (fill === "end") value = scale.options.reverse ? scale.min : scale.max; else if (helpers_segment_isObject(fill)) value = fill.value; else value = scale.getBaseValue();
            return value;
        }
        function parseFillOption(line) {
            const options = line.options;
            const fillOption = options.fill;
            let fill = valueOrDefault(fillOption && fillOption.target, fillOption);
            if (fill === void 0) fill = !!options.backgroundColor;
            if (fill === false || fill === null) return false;
            if (fill === true) return "origin";
            return fill;
        }
        function _buildStackLine(source) {
            const {scale, index, line} = source;
            const points = [];
            const segments = line.segments;
            const sourcePoints = line.points;
            const linesBelow = getLinesBelow(scale, index);
            linesBelow.push(_createBoundaryLine({
                x: null,
                y: scale.bottom
            }, line));
            for (let i = 0; i < segments.length; i++) {
                const segment = segments[i];
                for (let j = segment.start; j <= segment.end; j++) addPointsBelow(points, sourcePoints[j], linesBelow);
            }
            return new LineElement({
                points,
                options: {}
            });
        }
        function getLinesBelow(scale, index) {
            const below = [];
            const metas = scale.getMatchingVisibleMetas("line");
            for (let i = 0; i < metas.length; i++) {
                const meta = metas[i];
                if (meta.index === index) break;
                if (!meta.hidden) below.unshift(meta.dataset);
            }
            return below;
        }
        function addPointsBelow(points, sourcePoint, linesBelow) {
            const postponed = [];
            for (let j = 0; j < linesBelow.length; j++) {
                const line = linesBelow[j];
                const {first, last, point} = findPoint(line, sourcePoint, "x");
                if (!point || first && last) continue;
                if (first) postponed.unshift(point); else {
                    points.push(point);
                    if (!last) break;
                }
            }
            points.push(...postponed);
        }
        function findPoint(line, sourcePoint, property) {
            const point = line.interpolate(sourcePoint, property);
            if (!point) return {};
            const pointValue = point[property];
            const segments = line.segments;
            const linePoints = line.points;
            let first = false;
            let last = false;
            for (let i = 0; i < segments.length; i++) {
                const segment = segments[i];
                const firstValue = linePoints[segment.start][property];
                const lastValue = linePoints[segment.end][property];
                if (_isBetween(pointValue, firstValue, lastValue)) {
                    first = pointValue === firstValue;
                    last = pointValue === lastValue;
                    break;
                }
            }
            return {
                first,
                last,
                point
            };
        }
        class simpleArc {
            constructor(opts) {
                this.x = opts.x;
                this.y = opts.y;
                this.radius = opts.radius;
            }
            pathSegment(ctx, bounds, opts) {
                const {x, y, radius} = this;
                bounds = bounds || {
                    start: 0,
                    end: TAU
                };
                ctx.arc(x, y, radius, bounds.end, bounds.start, true);
                return !opts.bounds;
            }
            interpolate(point) {
                const {x, y, radius} = this;
                const angle = point.angle;
                return {
                    x: x + Math.cos(angle) * radius,
                    y: y + Math.sin(angle) * radius,
                    angle
                };
            }
        }
        function _getTarget(source) {
            const {chart, fill, line} = source;
            if (isNumberFinite(fill)) return getLineByIndex(chart, fill);
            if (fill === "stack") return _buildStackLine(source);
            if (fill === "shape") return true;
            const boundary = computeBoundary(source);
            if (boundary instanceof simpleArc) return boundary;
            return _createBoundaryLine(boundary, line);
        }
        function getLineByIndex(chart, index) {
            const meta = chart.getDatasetMeta(index);
            const visible = meta && chart.isDatasetVisible(index);
            return visible ? meta.dataset : null;
        }
        function computeBoundary(source) {
            const scale = source.scale || {};
            if (scale.getPointPositionForValue) return computeCircularBoundary(source);
            return computeLinearBoundary(source);
        }
        function computeLinearBoundary(source) {
            const {scale = {}, fill} = source;
            const pixel = _getTargetPixel(fill, scale);
            if (isNumberFinite(pixel)) {
                const horizontal = scale.isHorizontal();
                return {
                    x: horizontal ? pixel : null,
                    y: horizontal ? null : pixel
                };
            }
            return null;
        }
        function computeCircularBoundary(source) {
            const {scale, fill} = source;
            const options = scale.options;
            const length = scale.getLabels().length;
            const start = options.reverse ? scale.max : scale.min;
            const value = _getTargetValue(fill, scale, start);
            const target = [];
            if (options.grid.circular) {
                const center = scale.getPointPositionForValue(0, start);
                return new simpleArc({
                    x: center.x,
                    y: center.y,
                    radius: scale.getDistanceFromCenterForValue(value)
                });
            }
            for (let i = 0; i < length; ++i) target.push(scale.getPointPositionForValue(i, value));
            return target;
        }
        function _drawfill(ctx, source, area) {
            const target = _getTarget(source);
            const {line, scale, axis} = source;
            const lineOpts = line.options;
            const fillOption = lineOpts.fill;
            const color = lineOpts.backgroundColor;
            const {above = color, below = color} = fillOption || {};
            if (target && line.points.length) {
                clipArea(ctx, area);
                doFill(ctx, {
                    line,
                    target,
                    above,
                    below,
                    area,
                    scale,
                    axis
                });
                unclipArea(ctx);
            }
        }
        function doFill(ctx, cfg) {
            const {line, target, above, below, area, scale} = cfg;
            const property = line._loop ? "angle" : cfg.axis;
            ctx.save();
            if (property === "x" && below !== above) {
                clipVertical(ctx, target, area.top);
                fill(ctx, {
                    line,
                    target,
                    color: above,
                    scale,
                    property
                });
                ctx.restore();
                ctx.save();
                clipVertical(ctx, target, area.bottom);
            }
            fill(ctx, {
                line,
                target,
                color: below,
                scale,
                property
            });
            ctx.restore();
        }
        function clipVertical(ctx, target, clipY) {
            const {segments, points} = target;
            let first = true;
            let lineLoop = false;
            ctx.beginPath();
            for (const segment of segments) {
                const {start, end} = segment;
                const firstPoint = points[start];
                const lastPoint = points[_findSegmentEnd(start, end, points)];
                if (first) {
                    ctx.moveTo(firstPoint.x, firstPoint.y);
                    first = false;
                } else {
                    ctx.lineTo(firstPoint.x, clipY);
                    ctx.lineTo(firstPoint.x, firstPoint.y);
                }
                lineLoop = !!target.pathSegment(ctx, segment, {
                    move: lineLoop
                });
                if (lineLoop) ctx.closePath(); else ctx.lineTo(lastPoint.x, clipY);
            }
            ctx.lineTo(target.first().x, clipY);
            ctx.closePath();
            ctx.clip();
        }
        function fill(ctx, cfg) {
            const {line, target, property, color, scale} = cfg;
            const segments = _segments(line, target, property);
            for (const {source: src, target: tgt, start, end} of segments) {
                const {style: {backgroundColor = color} = {}} = src;
                const notShape = target !== true;
                ctx.save();
                ctx.fillStyle = backgroundColor;
                clipBounds(ctx, scale, notShape && _getBounds(property, start, end));
                ctx.beginPath();
                const lineLoop = !!line.pathSegment(ctx, src);
                let loop;
                if (notShape) {
                    if (lineLoop) ctx.closePath(); else interpolatedLineTo(ctx, target, end, property);
                    const targetLoop = !!target.pathSegment(ctx, tgt, {
                        move: lineLoop,
                        reverse: true
                    });
                    loop = lineLoop && targetLoop;
                    if (!loop) interpolatedLineTo(ctx, target, start, property);
                }
                ctx.closePath();
                ctx.fill(loop ? "evenodd" : "nonzero");
                ctx.restore();
            }
        }
        function clipBounds(ctx, scale, bounds) {
            const {top, bottom} = scale.chart.chartArea;
            const {property, start, end} = bounds || {};
            if (property === "x") {
                ctx.beginPath();
                ctx.rect(start, top, end - start, bottom - top);
                ctx.clip();
            }
        }
        function interpolatedLineTo(ctx, target, point, property) {
            const interpolatedPoint = target.interpolate(point, property);
            if (interpolatedPoint) ctx.lineTo(interpolatedPoint.x, interpolatedPoint.y);
        }
        var index = {
            id: "filler",
            afterDatasetsUpdate(chart, _args, options) {
                const count = (chart.data.datasets || []).length;
                const sources = [];
                let meta, i, line, source;
                for (i = 0; i < count; ++i) {
                    meta = chart.getDatasetMeta(i);
                    line = meta.dataset;
                    source = null;
                    if (line && line.options && line instanceof LineElement) source = {
                        visible: chart.isDatasetVisible(i),
                        index: i,
                        fill: _decodeFill(line, i, count),
                        chart,
                        axis: meta.controller.options.indexAxis,
                        scale: meta.vScale,
                        line
                    };
                    meta.$filler = source;
                    sources.push(source);
                }
                for (i = 0; i < count; ++i) {
                    source = sources[i];
                    if (!source || source.fill === false) continue;
                    source.fill = _resolveTarget(sources, i, options.propagate);
                }
            },
            beforeDraw(chart, _args, options) {
                const draw = options.drawTime === "beforeDraw";
                const metasets = chart.getSortedVisibleDatasetMetas();
                const area = chart.chartArea;
                for (let i = metasets.length - 1; i >= 0; --i) {
                    const source = metasets[i].$filler;
                    if (!source) continue;
                    source.line.updateControlPoints(area, source.axis);
                    if (draw && source.fill) _drawfill(chart.ctx, source, area);
                }
            },
            beforeDatasetsDraw(chart, _args, options) {
                if (options.drawTime !== "beforeDatasetsDraw") return;
                const metasets = chart.getSortedVisibleDatasetMetas();
                for (let i = metasets.length - 1; i >= 0; --i) {
                    const source = metasets[i].$filler;
                    if (_shouldApplyFill(source)) _drawfill(chart.ctx, source, chart.chartArea);
                }
            },
            beforeDatasetDraw(chart, args, options) {
                const source = args.meta.$filler;
                if (!_shouldApplyFill(source) || options.drawTime !== "beforeDatasetDraw") return;
                _drawfill(chart.ctx, source, chart.chartArea);
            },
            defaults: {
                propagate: true,
                drawTime: "beforeDatasetDraw"
            }
        };
        const getBoxSize = (labelOpts, fontSize) => {
            let {boxHeight = fontSize, boxWidth = fontSize} = labelOpts;
            if (labelOpts.usePointStyle) {
                boxHeight = Math.min(boxHeight, fontSize);
                boxWidth = labelOpts.pointStyleWidth || Math.min(boxWidth, fontSize);
            }
            return {
                boxWidth,
                boxHeight,
                itemHeight: Math.max(fontSize, boxHeight)
            };
        };
        const itemsEqual = (a, b) => a !== null && b !== null && a.datasetIndex === b.datasetIndex && a.index === b.index;
        class Legend extends chart_Element {
            constructor(config) {
                super();
                this._added = false;
                this.legendHitBoxes = [];
                this._hoveredItem = null;
                this.doughnutMode = false;
                this.chart = config.chart;
                this.options = config.options;
                this.ctx = config.ctx;
                this.legendItems = void 0;
                this.columnSizes = void 0;
                this.lineWidths = void 0;
                this.maxHeight = void 0;
                this.maxWidth = void 0;
                this.top = void 0;
                this.bottom = void 0;
                this.left = void 0;
                this.right = void 0;
                this.height = void 0;
                this.width = void 0;
                this._margins = void 0;
                this.position = void 0;
                this.weight = void 0;
                this.fullSize = void 0;
            }
            update(maxWidth, maxHeight, margins) {
                this.maxWidth = maxWidth;
                this.maxHeight = maxHeight;
                this._margins = margins;
                this.setDimensions();
                this.buildLabels();
                this.fit();
            }
            setDimensions() {
                if (this.isHorizontal()) {
                    this.width = this.maxWidth;
                    this.left = this._margins.left;
                    this.right = this.width;
                } else {
                    this.height = this.maxHeight;
                    this.top = this._margins.top;
                    this.bottom = this.height;
                }
            }
            buildLabels() {
                const labelOpts = this.options.labels || {};
                let legendItems = callback(labelOpts.generateLabels, [ this.chart ], this) || [];
                if (labelOpts.filter) legendItems = legendItems.filter((item => labelOpts.filter(item, this.chart.data)));
                if (labelOpts.sort) legendItems = legendItems.sort(((a, b) => labelOpts.sort(a, b, this.chart.data)));
                if (this.options.reverse) legendItems.reverse();
                this.legendItems = legendItems;
            }
            fit() {
                const {options, ctx} = this;
                if (!options.display) {
                    this.width = this.height = 0;
                    return;
                }
                const labelOpts = options.labels;
                const labelFont = toFont(labelOpts.font);
                const fontSize = labelFont.size;
                const titleHeight = this._computeTitleHeight();
                const {boxWidth, itemHeight} = getBoxSize(labelOpts, fontSize);
                let width, height;
                ctx.font = labelFont.string;
                if (this.isHorizontal()) {
                    width = this.maxWidth;
                    height = this._fitRows(titleHeight, fontSize, boxWidth, itemHeight) + 10;
                } else {
                    height = this.maxHeight;
                    width = this._fitCols(titleHeight, labelFont, boxWidth, itemHeight) + 10;
                }
                this.width = Math.min(width, options.maxWidth || this.maxWidth);
                this.height = Math.min(height, options.maxHeight || this.maxHeight);
            }
            _fitRows(titleHeight, fontSize, boxWidth, itemHeight) {
                const {ctx, maxWidth, options: {labels: {padding}}} = this;
                const hitboxes = this.legendHitBoxes = [];
                const lineWidths = this.lineWidths = [ 0 ];
                const lineHeight = itemHeight + padding;
                let totalHeight = titleHeight;
                ctx.textAlign = "left";
                ctx.textBaseline = "middle";
                let row = -1;
                let top = -lineHeight;
                this.legendItems.forEach(((legendItem, i) => {
                    const itemWidth = boxWidth + fontSize / 2 + ctx.measureText(legendItem.text).width;
                    if (i === 0 || lineWidths[lineWidths.length - 1] + itemWidth + 2 * padding > maxWidth) {
                        totalHeight += lineHeight;
                        lineWidths[lineWidths.length - (i > 0 ? 0 : 1)] = 0;
                        top += lineHeight;
                        row++;
                    }
                    hitboxes[i] = {
                        left: 0,
                        top,
                        row,
                        width: itemWidth,
                        height: itemHeight
                    };
                    lineWidths[lineWidths.length - 1] += itemWidth + padding;
                }));
                return totalHeight;
            }
            _fitCols(titleHeight, labelFont, boxWidth, _itemHeight) {
                const {ctx, maxHeight, options: {labels: {padding}}} = this;
                const hitboxes = this.legendHitBoxes = [];
                const columnSizes = this.columnSizes = [];
                const heightLimit = maxHeight - titleHeight;
                let totalWidth = padding;
                let currentColWidth = 0;
                let currentColHeight = 0;
                let left = 0;
                let col = 0;
                this.legendItems.forEach(((legendItem, i) => {
                    const {itemWidth, itemHeight} = calculateItemSize(boxWidth, labelFont, ctx, legendItem, _itemHeight);
                    if (i > 0 && currentColHeight + itemHeight + 2 * padding > heightLimit) {
                        totalWidth += currentColWidth + padding;
                        columnSizes.push({
                            width: currentColWidth,
                            height: currentColHeight
                        });
                        left += currentColWidth + padding;
                        col++;
                        currentColWidth = currentColHeight = 0;
                    }
                    hitboxes[i] = {
                        left,
                        top: currentColHeight,
                        col,
                        width: itemWidth,
                        height: itemHeight
                    };
                    currentColWidth = Math.max(currentColWidth, itemWidth);
                    currentColHeight += itemHeight + padding;
                }));
                totalWidth += currentColWidth;
                columnSizes.push({
                    width: currentColWidth,
                    height: currentColHeight
                });
                return totalWidth;
            }
            adjustHitBoxes() {
                if (!this.options.display) return;
                const titleHeight = this._computeTitleHeight();
                const {legendHitBoxes: hitboxes, options: {align, labels: {padding}, rtl}} = this;
                const rtlHelper = getRtlAdapter(rtl, this.left, this.width);
                if (this.isHorizontal()) {
                    let row = 0;
                    let left = _alignStartEnd(align, this.left + padding, this.right - this.lineWidths[row]);
                    for (const hitbox of hitboxes) {
                        if (row !== hitbox.row) {
                            row = hitbox.row;
                            left = _alignStartEnd(align, this.left + padding, this.right - this.lineWidths[row]);
                        }
                        hitbox.top += this.top + titleHeight + padding;
                        hitbox.left = rtlHelper.leftForLtr(rtlHelper.x(left), hitbox.width);
                        left += hitbox.width + padding;
                    }
                } else {
                    let col = 0;
                    let top = _alignStartEnd(align, this.top + titleHeight + padding, this.bottom - this.columnSizes[col].height);
                    for (const hitbox of hitboxes) {
                        if (hitbox.col !== col) {
                            col = hitbox.col;
                            top = _alignStartEnd(align, this.top + titleHeight + padding, this.bottom - this.columnSizes[col].height);
                        }
                        hitbox.top = top;
                        hitbox.left += this.left + padding;
                        hitbox.left = rtlHelper.leftForLtr(rtlHelper.x(hitbox.left), hitbox.width);
                        top += hitbox.height + padding;
                    }
                }
            }
            isHorizontal() {
                return this.options.position === "top" || this.options.position === "bottom";
            }
            draw() {
                if (this.options.display) {
                    const ctx = this.ctx;
                    clipArea(ctx, this);
                    this._draw();
                    unclipArea(ctx);
                }
            }
            _draw() {
                const {options: opts, columnSizes, lineWidths, ctx} = this;
                const {align, labels: labelOpts} = opts;
                const defaultColor = defaults.color;
                const rtlHelper = getRtlAdapter(opts.rtl, this.left, this.width);
                const labelFont = toFont(labelOpts.font);
                const {padding} = labelOpts;
                const fontSize = labelFont.size;
                const halfFontSize = fontSize / 2;
                let cursor;
                this.drawTitle();
                ctx.textAlign = rtlHelper.textAlign("left");
                ctx.textBaseline = "middle";
                ctx.lineWidth = .5;
                ctx.font = labelFont.string;
                const {boxWidth, boxHeight, itemHeight} = getBoxSize(labelOpts, fontSize);
                const drawLegendBox = function(x, y, legendItem) {
                    if (isNaN(boxWidth) || boxWidth <= 0 || isNaN(boxHeight) || boxHeight < 0) return;
                    ctx.save();
                    const lineWidth = valueOrDefault(legendItem.lineWidth, 1);
                    ctx.fillStyle = valueOrDefault(legendItem.fillStyle, defaultColor);
                    ctx.lineCap = valueOrDefault(legendItem.lineCap, "butt");
                    ctx.lineDashOffset = valueOrDefault(legendItem.lineDashOffset, 0);
                    ctx.lineJoin = valueOrDefault(legendItem.lineJoin, "miter");
                    ctx.lineWidth = lineWidth;
                    ctx.strokeStyle = valueOrDefault(legendItem.strokeStyle, defaultColor);
                    ctx.setLineDash(valueOrDefault(legendItem.lineDash, []));
                    if (labelOpts.usePointStyle) {
                        const drawOptions = {
                            radius: boxHeight * Math.SQRT2 / 2,
                            pointStyle: legendItem.pointStyle,
                            rotation: legendItem.rotation,
                            borderWidth: lineWidth
                        };
                        const centerX = rtlHelper.xPlus(x, boxWidth / 2);
                        const centerY = y + halfFontSize;
                        drawPointLegend(ctx, drawOptions, centerX, centerY, labelOpts.pointStyleWidth && boxWidth);
                    } else {
                        const yBoxTop = y + Math.max((fontSize - boxHeight) / 2, 0);
                        const xBoxLeft = rtlHelper.leftForLtr(x, boxWidth);
                        const borderRadius = toTRBLCorners(legendItem.borderRadius);
                        ctx.beginPath();
                        if (Object.values(borderRadius).some((v => v !== 0))) addRoundedRectPath(ctx, {
                            x: xBoxLeft,
                            y: yBoxTop,
                            w: boxWidth,
                            h: boxHeight,
                            radius: borderRadius
                        }); else ctx.rect(xBoxLeft, yBoxTop, boxWidth, boxHeight);
                        ctx.fill();
                        if (lineWidth !== 0) ctx.stroke();
                    }
                    ctx.restore();
                };
                const fillText = function(x, y, legendItem) {
                    renderText(ctx, legendItem.text, x, y + itemHeight / 2, labelFont, {
                        strikethrough: legendItem.hidden,
                        textAlign: rtlHelper.textAlign(legendItem.textAlign)
                    });
                };
                const isHorizontal = this.isHorizontal();
                const titleHeight = this._computeTitleHeight();
                if (isHorizontal) cursor = {
                    x: _alignStartEnd(align, this.left + padding, this.right - lineWidths[0]),
                    y: this.top + padding + titleHeight,
                    line: 0
                }; else cursor = {
                    x: this.left + padding,
                    y: _alignStartEnd(align, this.top + titleHeight + padding, this.bottom - columnSizes[0].height),
                    line: 0
                };
                overrideTextDirection(this.ctx, opts.textDirection);
                const lineHeight = itemHeight + padding;
                this.legendItems.forEach(((legendItem, i) => {
                    ctx.strokeStyle = legendItem.fontColor;
                    ctx.fillStyle = legendItem.fontColor;
                    const textWidth = ctx.measureText(legendItem.text).width;
                    const textAlign = rtlHelper.textAlign(legendItem.textAlign || (legendItem.textAlign = labelOpts.textAlign));
                    const width = boxWidth + halfFontSize + textWidth;
                    let x = cursor.x;
                    let y = cursor.y;
                    rtlHelper.setWidth(this.width);
                    if (isHorizontal) {
                        if (i > 0 && x + width + padding > this.right) {
                            y = cursor.y += lineHeight;
                            cursor.line++;
                            x = cursor.x = _alignStartEnd(align, this.left + padding, this.right - lineWidths[cursor.line]);
                        }
                    } else if (i > 0 && y + lineHeight > this.bottom) {
                        x = cursor.x = x + columnSizes[cursor.line].width + padding;
                        cursor.line++;
                        y = cursor.y = _alignStartEnd(align, this.top + titleHeight + padding, this.bottom - columnSizes[cursor.line].height);
                    }
                    const realX = rtlHelper.x(x);
                    drawLegendBox(realX, y, legendItem);
                    x = _textX(textAlign, x + boxWidth + halfFontSize, isHorizontal ? x + width : this.right, opts.rtl);
                    fillText(rtlHelper.x(x), y, legendItem);
                    if (isHorizontal) cursor.x += width + padding; else if (typeof legendItem.text !== "string") {
                        const fontLineHeight = labelFont.lineHeight;
                        cursor.y += calculateLegendItemHeight(legendItem, fontLineHeight) + padding;
                    } else cursor.y += lineHeight;
                }));
                restoreTextDirection(this.ctx, opts.textDirection);
            }
            drawTitle() {
                const opts = this.options;
                const titleOpts = opts.title;
                const titleFont = toFont(titleOpts.font);
                const titlePadding = toPadding(titleOpts.padding);
                if (!titleOpts.display) return;
                const rtlHelper = getRtlAdapter(opts.rtl, this.left, this.width);
                const ctx = this.ctx;
                const position = titleOpts.position;
                const halfFontSize = titleFont.size / 2;
                const topPaddingPlusHalfFontSize = titlePadding.top + halfFontSize;
                let y;
                let left = this.left;
                let maxWidth = this.width;
                if (this.isHorizontal()) {
                    maxWidth = Math.max(...this.lineWidths);
                    y = this.top + topPaddingPlusHalfFontSize;
                    left = _alignStartEnd(opts.align, left, this.right - maxWidth);
                } else {
                    const maxHeight = this.columnSizes.reduce(((acc, size) => Math.max(acc, size.height)), 0);
                    y = topPaddingPlusHalfFontSize + _alignStartEnd(opts.align, this.top, this.bottom - maxHeight - opts.labels.padding - this._computeTitleHeight());
                }
                const x = _alignStartEnd(position, left, left + maxWidth);
                ctx.textAlign = rtlHelper.textAlign(_toLeftRightCenter(position));
                ctx.textBaseline = "middle";
                ctx.strokeStyle = titleOpts.color;
                ctx.fillStyle = titleOpts.color;
                ctx.font = titleFont.string;
                renderText(ctx, titleOpts.text, x, y, titleFont);
            }
            _computeTitleHeight() {
                const titleOpts = this.options.title;
                const titleFont = toFont(titleOpts.font);
                const titlePadding = toPadding(titleOpts.padding);
                return titleOpts.display ? titleFont.lineHeight + titlePadding.height : 0;
            }
            _getLegendItemAt(x, y) {
                let i, hitBox, lh;
                if (_isBetween(x, this.left, this.right) && _isBetween(y, this.top, this.bottom)) {
                    lh = this.legendHitBoxes;
                    for (i = 0; i < lh.length; ++i) {
                        hitBox = lh[i];
                        if (_isBetween(x, hitBox.left, hitBox.left + hitBox.width) && _isBetween(y, hitBox.top, hitBox.top + hitBox.height)) return this.legendItems[i];
                    }
                }
                return null;
            }
            handleEvent(e) {
                const opts = this.options;
                if (!isListened(e.type, opts)) return;
                const hoveredItem = this._getLegendItemAt(e.x, e.y);
                if (e.type === "mousemove" || e.type === "mouseout") {
                    const previous = this._hoveredItem;
                    const sameItem = itemsEqual(previous, hoveredItem);
                    if (previous && !sameItem) callback(opts.onLeave, [ e, previous, this ], this);
                    this._hoveredItem = hoveredItem;
                    if (hoveredItem && !sameItem) callback(opts.onHover, [ e, hoveredItem, this ], this);
                } else if (hoveredItem) callback(opts.onClick, [ e, hoveredItem, this ], this);
            }
        }
        function calculateItemSize(boxWidth, labelFont, ctx, legendItem, _itemHeight) {
            const itemWidth = calculateItemWidth(legendItem, boxWidth, labelFont, ctx);
            const itemHeight = calculateItemHeight(_itemHeight, legendItem, labelFont.lineHeight);
            return {
                itemWidth,
                itemHeight
            };
        }
        function calculateItemWidth(legendItem, boxWidth, labelFont, ctx) {
            let legendItemText = legendItem.text;
            if (legendItemText && typeof legendItemText !== "string") legendItemText = legendItemText.reduce(((a, b) => a.length > b.length ? a : b));
            return boxWidth + labelFont.size / 2 + ctx.measureText(legendItemText).width;
        }
        function calculateItemHeight(_itemHeight, legendItem, fontLineHeight) {
            let itemHeight = _itemHeight;
            if (typeof legendItem.text !== "string") itemHeight = calculateLegendItemHeight(legendItem, fontLineHeight);
            return itemHeight;
        }
        function calculateLegendItemHeight(legendItem, fontLineHeight) {
            const labelHeight = legendItem.text ? legendItem.text.length : 0;
            return fontLineHeight * labelHeight;
        }
        function isListened(type, opts) {
            if ((type === "mousemove" || type === "mouseout") && (opts.onHover || opts.onLeave)) return true;
            if (opts.onClick && (type === "click" || type === "mouseup")) return true;
            return false;
        }
        var plugin_legend = {
            id: "legend",
            _element: Legend,
            start(chart, _args, options) {
                const legend = chart.legend = new Legend({
                    ctx: chart.ctx,
                    options,
                    chart
                });
                layouts.configure(chart, legend, options);
                layouts.addBox(chart, legend);
            },
            stop(chart) {
                layouts.removeBox(chart, chart.legend);
                delete chart.legend;
            },
            beforeUpdate(chart, _args, options) {
                const legend = chart.legend;
                layouts.configure(chart, legend, options);
                legend.options = options;
            },
            afterUpdate(chart) {
                const legend = chart.legend;
                legend.buildLabels();
                legend.adjustHitBoxes();
            },
            afterEvent(chart, args) {
                if (!args.replay) chart.legend.handleEvent(args.event);
            },
            defaults: {
                display: true,
                position: "top",
                align: "center",
                fullSize: true,
                reverse: false,
                weight: 1e3,
                onClick(e, legendItem, legend) {
                    const index = legendItem.datasetIndex;
                    const ci = legend.chart;
                    if (ci.isDatasetVisible(index)) {
                        ci.hide(index);
                        legendItem.hidden = true;
                    } else {
                        ci.show(index);
                        legendItem.hidden = false;
                    }
                },
                onHover: null,
                onLeave: null,
                labels: {
                    color: ctx => ctx.chart.options.color,
                    boxWidth: 40,
                    padding: 10,
                    generateLabels(chart) {
                        const datasets = chart.data.datasets;
                        const {labels: {usePointStyle, pointStyle, textAlign, color, useBorderRadius, borderRadius}} = chart.legend.options;
                        return chart._getSortedDatasetMetas().map((meta => {
                            const style = meta.controller.getStyle(usePointStyle ? 0 : void 0);
                            const borderWidth = toPadding(style.borderWidth);
                            return {
                                text: datasets[meta.index].label,
                                fillStyle: style.backgroundColor,
                                fontColor: color,
                                hidden: !meta.visible,
                                lineCap: style.borderCapStyle,
                                lineDash: style.borderDash,
                                lineDashOffset: style.borderDashOffset,
                                lineJoin: style.borderJoinStyle,
                                lineWidth: (borderWidth.width + borderWidth.height) / 4,
                                strokeStyle: style.borderColor,
                                pointStyle: pointStyle || style.pointStyle,
                                rotation: style.rotation,
                                textAlign: textAlign || style.textAlign,
                                borderRadius: useBorderRadius && (borderRadius || style.borderRadius),
                                datasetIndex: meta.index
                            };
                        }), this);
                    }
                },
                title: {
                    color: ctx => ctx.chart.options.color,
                    display: false,
                    position: "center",
                    text: ""
                }
            },
            descriptors: {
                _scriptable: name => !name.startsWith("on"),
                labels: {
                    _scriptable: name => ![ "generateLabels", "filter", "sort" ].includes(name)
                }
            }
        };
        class Title extends chart_Element {
            constructor(config) {
                super();
                this.chart = config.chart;
                this.options = config.options;
                this.ctx = config.ctx;
                this._padding = void 0;
                this.top = void 0;
                this.bottom = void 0;
                this.left = void 0;
                this.right = void 0;
                this.width = void 0;
                this.height = void 0;
                this.position = void 0;
                this.weight = void 0;
                this.fullSize = void 0;
            }
            update(maxWidth, maxHeight) {
                const opts = this.options;
                this.left = 0;
                this.top = 0;
                if (!opts.display) {
                    this.width = this.height = this.right = this.bottom = 0;
                    return;
                }
                this.width = this.right = maxWidth;
                this.height = this.bottom = maxHeight;
                const lineCount = isArray(opts.text) ? opts.text.length : 1;
                this._padding = toPadding(opts.padding);
                const textSize = lineCount * toFont(opts.font).lineHeight + this._padding.height;
                if (this.isHorizontal()) this.height = textSize; else this.width = textSize;
            }
            isHorizontal() {
                const pos = this.options.position;
                return pos === "top" || pos === "bottom";
            }
            _drawArgs(offset) {
                const {top, left, bottom, right, options} = this;
                const align = options.align;
                let rotation = 0;
                let maxWidth, titleX, titleY;
                if (this.isHorizontal()) {
                    titleX = _alignStartEnd(align, left, right);
                    titleY = top + offset;
                    maxWidth = right - left;
                } else {
                    if (options.position === "left") {
                        titleX = left + offset;
                        titleY = _alignStartEnd(align, bottom, top);
                        rotation = PI * -.5;
                    } else {
                        titleX = right - offset;
                        titleY = _alignStartEnd(align, top, bottom);
                        rotation = PI * .5;
                    }
                    maxWidth = bottom - top;
                }
                return {
                    titleX,
                    titleY,
                    maxWidth,
                    rotation
                };
            }
            draw() {
                const ctx = this.ctx;
                const opts = this.options;
                if (!opts.display) return;
                const fontOpts = toFont(opts.font);
                const lineHeight = fontOpts.lineHeight;
                const offset = lineHeight / 2 + this._padding.top;
                const {titleX, titleY, maxWidth, rotation} = this._drawArgs(offset);
                renderText(ctx, opts.text, 0, 0, fontOpts, {
                    color: opts.color,
                    maxWidth,
                    rotation,
                    textAlign: _toLeftRightCenter(opts.align),
                    textBaseline: "middle",
                    translation: [ titleX, titleY ]
                });
            }
        }
        function createTitle(chart, titleOpts) {
            const title = new Title({
                ctx: chart.ctx,
                options: titleOpts,
                chart
            });
            layouts.configure(chart, title, titleOpts);
            layouts.addBox(chart, title);
            chart.titleBlock = title;
        }
        var plugin_title = {
            id: "title",
            _element: Title,
            start(chart, _args, options) {
                createTitle(chart, options);
            },
            stop(chart) {
                const titleBlock = chart.titleBlock;
                layouts.removeBox(chart, titleBlock);
                delete chart.titleBlock;
            },
            beforeUpdate(chart, _args, options) {
                const title = chart.titleBlock;
                layouts.configure(chart, title, options);
                title.options = options;
            },
            defaults: {
                align: "center",
                display: false,
                font: {
                    weight: "bold"
                },
                fullSize: true,
                padding: 10,
                position: "top",
                text: "",
                weight: 2e3
            },
            defaultRoutes: {
                color: "color"
            },
            descriptors: {
                _scriptable: true,
                _indexable: false
            }
        };
        const chart_map = new WeakMap;
        var plugin_subtitle = {
            id: "subtitle",
            start(chart, _args, options) {
                const title = new Title({
                    ctx: chart.ctx,
                    options,
                    chart
                });
                layouts.configure(chart, title, options);
                layouts.addBox(chart, title);
                chart_map.set(chart, title);
            },
            stop(chart) {
                layouts.removeBox(chart, chart_map.get(chart));
                chart_map.delete(chart);
            },
            beforeUpdate(chart, _args, options) {
                const title = chart_map.get(chart);
                layouts.configure(chart, title, options);
                title.options = options;
            },
            defaults: {
                align: "center",
                display: false,
                font: {
                    weight: "normal"
                },
                fullSize: true,
                padding: 0,
                position: "top",
                text: "",
                weight: 1500
            },
            defaultRoutes: {
                color: "color"
            },
            descriptors: {
                _scriptable: true,
                _indexable: false
            }
        };
        const positioners = {
            average(items) {
                if (!items.length) return false;
                let i, len;
                let xSet = new Set;
                let y = 0;
                let count = 0;
                for (i = 0, len = items.length; i < len; ++i) {
                    const el = items[i].element;
                    if (el && el.hasValue()) {
                        const pos = el.tooltipPosition();
                        xSet.add(pos.x);
                        y += pos.y;
                        ++count;
                    }
                }
                if (count === 0 || xSet.size === 0) return false;
                const xAverage = [ ...xSet ].reduce(((a, b) => a + b)) / xSet.size;
                return {
                    x: xAverage,
                    y: y / count
                };
            },
            nearest(items, eventPosition) {
                if (!items.length) return false;
                let x = eventPosition.x;
                let y = eventPosition.y;
                let minDistance = Number.POSITIVE_INFINITY;
                let i, len, nearestElement;
                for (i = 0, len = items.length; i < len; ++i) {
                    const el = items[i].element;
                    if (el && el.hasValue()) {
                        const center = el.getCenterPoint();
                        const d = distanceBetweenPoints(eventPosition, center);
                        if (d < minDistance) {
                            minDistance = d;
                            nearestElement = el;
                        }
                    }
                }
                if (nearestElement) {
                    const tp = nearestElement.tooltipPosition();
                    x = tp.x;
                    y = tp.y;
                }
                return {
                    x,
                    y
                };
            }
        };
        function pushOrConcat(base, toPush) {
            if (toPush) if (isArray(toPush)) Array.prototype.push.apply(base, toPush); else base.push(toPush);
            return base;
        }
        function splitNewlines(str) {
            if ((typeof str === "string" || str instanceof String) && str.indexOf("\n") > -1) return str.split("\n");
            return str;
        }
        function createTooltipItem(chart, item) {
            const {element, datasetIndex, index} = item;
            const controller = chart.getDatasetMeta(datasetIndex).controller;
            const {label, value} = controller.getLabelAndValue(index);
            return {
                chart,
                label,
                parsed: controller.getParsed(index),
                raw: chart.data.datasets[datasetIndex].data[index],
                formattedValue: value,
                dataset: controller.getDataset(),
                dataIndex: index,
                datasetIndex,
                element
            };
        }
        function getTooltipSize(tooltip, options) {
            const ctx = tooltip.chart.ctx;
            const {body, footer, title} = tooltip;
            const {boxWidth, boxHeight} = options;
            const bodyFont = toFont(options.bodyFont);
            const titleFont = toFont(options.titleFont);
            const footerFont = toFont(options.footerFont);
            const titleLineCount = title.length;
            const footerLineCount = footer.length;
            const bodyLineItemCount = body.length;
            const padding = toPadding(options.padding);
            let height = padding.height;
            let width = 0;
            let combinedBodyLength = body.reduce(((count, bodyItem) => count + bodyItem.before.length + bodyItem.lines.length + bodyItem.after.length), 0);
            combinedBodyLength += tooltip.beforeBody.length + tooltip.afterBody.length;
            if (titleLineCount) height += titleLineCount * titleFont.lineHeight + (titleLineCount - 1) * options.titleSpacing + options.titleMarginBottom;
            if (combinedBodyLength) {
                const bodyLineHeight = options.displayColors ? Math.max(boxHeight, bodyFont.lineHeight) : bodyFont.lineHeight;
                height += bodyLineItemCount * bodyLineHeight + (combinedBodyLength - bodyLineItemCount) * bodyFont.lineHeight + (combinedBodyLength - 1) * options.bodySpacing;
            }
            if (footerLineCount) height += options.footerMarginTop + footerLineCount * footerFont.lineHeight + (footerLineCount - 1) * options.footerSpacing;
            let widthPadding = 0;
            const maxLineWidth = function(line) {
                width = Math.max(width, ctx.measureText(line).width + widthPadding);
            };
            ctx.save();
            ctx.font = titleFont.string;
            each(tooltip.title, maxLineWidth);
            ctx.font = bodyFont.string;
            each(tooltip.beforeBody.concat(tooltip.afterBody), maxLineWidth);
            widthPadding = options.displayColors ? boxWidth + 2 + options.boxPadding : 0;
            each(body, (bodyItem => {
                each(bodyItem.before, maxLineWidth);
                each(bodyItem.lines, maxLineWidth);
                each(bodyItem.after, maxLineWidth);
            }));
            widthPadding = 0;
            ctx.font = footerFont.string;
            each(tooltip.footer, maxLineWidth);
            ctx.restore();
            width += padding.width;
            return {
                width,
                height
            };
        }
        function determineYAlign(chart, size) {
            const {y, height} = size;
            if (y < height / 2) return "top"; else if (y > chart.height - height / 2) return "bottom";
            return "center";
        }
        function doesNotFitWithAlign(xAlign, chart, options, size) {
            const {x, width} = size;
            const caret = options.caretSize + options.caretPadding;
            if (xAlign === "left" && x + width + caret > chart.width) return true;
            if (xAlign === "right" && x - width - caret < 0) return true;
        }
        function determineXAlign(chart, options, size, yAlign) {
            const {x, width} = size;
            const {width: chartWidth, chartArea: {left, right}} = chart;
            let xAlign = "center";
            if (yAlign === "center") xAlign = x <= (left + right) / 2 ? "left" : "right"; else if (x <= width / 2) xAlign = "left"; else if (x >= chartWidth - width / 2) xAlign = "right";
            if (doesNotFitWithAlign(xAlign, chart, options, size)) xAlign = "center";
            return xAlign;
        }
        function determineAlignment(chart, options, size) {
            const yAlign = size.yAlign || options.yAlign || determineYAlign(chart, size);
            return {
                xAlign: size.xAlign || options.xAlign || determineXAlign(chart, options, size, yAlign),
                yAlign
            };
        }
        function alignX(size, xAlign) {
            let {x, width} = size;
            if (xAlign === "right") x -= width; else if (xAlign === "center") x -= width / 2;
            return x;
        }
        function alignY(size, yAlign, paddingAndSize) {
            let {y, height} = size;
            if (yAlign === "top") y += paddingAndSize; else if (yAlign === "bottom") y -= height + paddingAndSize; else y -= height / 2;
            return y;
        }
        function getBackgroundPoint(options, size, alignment, chart) {
            const {caretSize, caretPadding, cornerRadius} = options;
            const {xAlign, yAlign} = alignment;
            const paddingAndSize = caretSize + caretPadding;
            const {topLeft, topRight, bottomLeft, bottomRight} = toTRBLCorners(cornerRadius);
            let x = alignX(size, xAlign);
            const y = alignY(size, yAlign, paddingAndSize);
            if (yAlign === "center") {
                if (xAlign === "left") x += paddingAndSize; else if (xAlign === "right") x -= paddingAndSize;
            } else if (xAlign === "left") x -= Math.max(topLeft, bottomLeft) + caretSize; else if (xAlign === "right") x += Math.max(topRight, bottomRight) + caretSize;
            return {
                x: _limitValue(x, 0, chart.width - size.width),
                y: _limitValue(y, 0, chart.height - size.height)
            };
        }
        function getAlignedX(tooltip, align, options) {
            const padding = toPadding(options.padding);
            return align === "center" ? tooltip.x + tooltip.width / 2 : align === "right" ? tooltip.x + tooltip.width - padding.right : tooltip.x + padding.left;
        }
        function getBeforeAfterBodyLines(callback) {
            return pushOrConcat([], splitNewlines(callback));
        }
        function createTooltipContext(parent, tooltip, tooltipItems) {
            return createContext(parent, {
                tooltip,
                tooltipItems,
                type: "tooltip"
            });
        }
        function overrideCallbacks(callbacks, context) {
            const override = context && context.dataset && context.dataset.tooltip && context.dataset.tooltip.callbacks;
            return override ? callbacks.override(override) : callbacks;
        }
        const defaultCallbacks = {
            beforeTitle: noop,
            title(tooltipItems) {
                if (tooltipItems.length > 0) {
                    const item = tooltipItems[0];
                    const labels = item.chart.data.labels;
                    const labelCount = labels ? labels.length : 0;
                    if (this && this.options && this.options.mode === "dataset") return item.dataset.label || ""; else if (item.label) return item.label; else if (labelCount > 0 && item.dataIndex < labelCount) return labels[item.dataIndex];
                }
                return "";
            },
            afterTitle: noop,
            beforeBody: noop,
            beforeLabel: noop,
            label(tooltipItem) {
                if (this && this.options && this.options.mode === "dataset") return tooltipItem.label + ": " + tooltipItem.formattedValue || tooltipItem.formattedValue;
                let label = tooltipItem.dataset.label || "";
                if (label) label += ": ";
                const value = tooltipItem.formattedValue;
                if (!isNullOrUndef(value)) label += value;
                return label;
            },
            labelColor(tooltipItem) {
                const meta = tooltipItem.chart.getDatasetMeta(tooltipItem.datasetIndex);
                const options = meta.controller.getStyle(tooltipItem.dataIndex);
                return {
                    borderColor: options.borderColor,
                    backgroundColor: options.backgroundColor,
                    borderWidth: options.borderWidth,
                    borderDash: options.borderDash,
                    borderDashOffset: options.borderDashOffset,
                    borderRadius: 0
                };
            },
            labelTextColor() {
                return this.options.bodyColor;
            },
            labelPointStyle(tooltipItem) {
                const meta = tooltipItem.chart.getDatasetMeta(tooltipItem.datasetIndex);
                const options = meta.controller.getStyle(tooltipItem.dataIndex);
                return {
                    pointStyle: options.pointStyle,
                    rotation: options.rotation
                };
            },
            afterLabel: noop,
            afterBody: noop,
            beforeFooter: noop,
            footer: noop,
            afterFooter: noop
        };
        function invokeCallbackWithFallback(callbacks, name, ctx, arg) {
            const result = callbacks[name].call(ctx, arg);
            if (typeof result === "undefined") return defaultCallbacks[name].call(ctx, arg);
            return result;
        }
        class chart_Tooltip extends chart_Element {
            static positioners=positioners;
            constructor(config) {
                super();
                this.opacity = 0;
                this._active = [];
                this._eventPosition = void 0;
                this._size = void 0;
                this._cachedAnimations = void 0;
                this._tooltipItems = [];
                this.$animations = void 0;
                this.$context = void 0;
                this.chart = config.chart;
                this.options = config.options;
                this.dataPoints = void 0;
                this.title = void 0;
                this.beforeBody = void 0;
                this.body = void 0;
                this.afterBody = void 0;
                this.footer = void 0;
                this.xAlign = void 0;
                this.yAlign = void 0;
                this.x = void 0;
                this.y = void 0;
                this.height = void 0;
                this.width = void 0;
                this.caretX = void 0;
                this.caretY = void 0;
                this.labelColors = void 0;
                this.labelPointStyles = void 0;
                this.labelTextColors = void 0;
            }
            initialize(options) {
                this.options = options;
                this._cachedAnimations = void 0;
                this.$context = void 0;
            }
            _resolveAnimations() {
                const cached = this._cachedAnimations;
                if (cached) return cached;
                const chart = this.chart;
                const options = this.options.setContext(this.getContext());
                const opts = options.enabled && chart.options.animation && options.animations;
                const animations = new Animations(this.chart, opts);
                if (opts._cacheable) this._cachedAnimations = Object.freeze(animations);
                return animations;
            }
            getContext() {
                return this.$context || (this.$context = createTooltipContext(this.chart.getContext(), this, this._tooltipItems));
            }
            getTitle(context, options) {
                const {callbacks} = options;
                const beforeTitle = invokeCallbackWithFallback(callbacks, "beforeTitle", this, context);
                const title = invokeCallbackWithFallback(callbacks, "title", this, context);
                const afterTitle = invokeCallbackWithFallback(callbacks, "afterTitle", this, context);
                let lines = [];
                lines = pushOrConcat(lines, splitNewlines(beforeTitle));
                lines = pushOrConcat(lines, splitNewlines(title));
                lines = pushOrConcat(lines, splitNewlines(afterTitle));
                return lines;
            }
            getBeforeBody(tooltipItems, options) {
                return getBeforeAfterBodyLines(invokeCallbackWithFallback(options.callbacks, "beforeBody", this, tooltipItems));
            }
            getBody(tooltipItems, options) {
                const {callbacks} = options;
                const bodyItems = [];
                each(tooltipItems, (context => {
                    const bodyItem = {
                        before: [],
                        lines: [],
                        after: []
                    };
                    const scoped = overrideCallbacks(callbacks, context);
                    pushOrConcat(bodyItem.before, splitNewlines(invokeCallbackWithFallback(scoped, "beforeLabel", this, context)));
                    pushOrConcat(bodyItem.lines, invokeCallbackWithFallback(scoped, "label", this, context));
                    pushOrConcat(bodyItem.after, splitNewlines(invokeCallbackWithFallback(scoped, "afterLabel", this, context)));
                    bodyItems.push(bodyItem);
                }));
                return bodyItems;
            }
            getAfterBody(tooltipItems, options) {
                return getBeforeAfterBodyLines(invokeCallbackWithFallback(options.callbacks, "afterBody", this, tooltipItems));
            }
            getFooter(tooltipItems, options) {
                const {callbacks} = options;
                const beforeFooter = invokeCallbackWithFallback(callbacks, "beforeFooter", this, tooltipItems);
                const footer = invokeCallbackWithFallback(callbacks, "footer", this, tooltipItems);
                const afterFooter = invokeCallbackWithFallback(callbacks, "afterFooter", this, tooltipItems);
                let lines = [];
                lines = pushOrConcat(lines, splitNewlines(beforeFooter));
                lines = pushOrConcat(lines, splitNewlines(footer));
                lines = pushOrConcat(lines, splitNewlines(afterFooter));
                return lines;
            }
            _createItems(options) {
                const active = this._active;
                const data = this.chart.data;
                const labelColors = [];
                const labelPointStyles = [];
                const labelTextColors = [];
                let tooltipItems = [];
                let i, len;
                for (i = 0, len = active.length; i < len; ++i) tooltipItems.push(createTooltipItem(this.chart, active[i]));
                if (options.filter) tooltipItems = tooltipItems.filter(((element, index, array) => options.filter(element, index, array, data)));
                if (options.itemSort) tooltipItems = tooltipItems.sort(((a, b) => options.itemSort(a, b, data)));
                each(tooltipItems, (context => {
                    const scoped = overrideCallbacks(options.callbacks, context);
                    labelColors.push(invokeCallbackWithFallback(scoped, "labelColor", this, context));
                    labelPointStyles.push(invokeCallbackWithFallback(scoped, "labelPointStyle", this, context));
                    labelTextColors.push(invokeCallbackWithFallback(scoped, "labelTextColor", this, context));
                }));
                this.labelColors = labelColors;
                this.labelPointStyles = labelPointStyles;
                this.labelTextColors = labelTextColors;
                this.dataPoints = tooltipItems;
                return tooltipItems;
            }
            update(changed, replay) {
                const options = this.options.setContext(this.getContext());
                const active = this._active;
                let properties;
                let tooltipItems = [];
                if (!active.length) {
                    if (this.opacity !== 0) properties = {
                        opacity: 0
                    };
                } else {
                    const position = positioners[options.position].call(this, active, this._eventPosition);
                    tooltipItems = this._createItems(options);
                    this.title = this.getTitle(tooltipItems, options);
                    this.beforeBody = this.getBeforeBody(tooltipItems, options);
                    this.body = this.getBody(tooltipItems, options);
                    this.afterBody = this.getAfterBody(tooltipItems, options);
                    this.footer = this.getFooter(tooltipItems, options);
                    const size = this._size = getTooltipSize(this, options);
                    const positionAndSize = Object.assign({}, position, size);
                    const alignment = determineAlignment(this.chart, options, positionAndSize);
                    const backgroundPoint = getBackgroundPoint(options, positionAndSize, alignment, this.chart);
                    this.xAlign = alignment.xAlign;
                    this.yAlign = alignment.yAlign;
                    properties = {
                        opacity: 1,
                        x: backgroundPoint.x,
                        y: backgroundPoint.y,
                        width: size.width,
                        height: size.height,
                        caretX: position.x,
                        caretY: position.y
                    };
                }
                this._tooltipItems = tooltipItems;
                this.$context = void 0;
                if (properties) this._resolveAnimations().update(this, properties);
                if (changed && options.external) options.external.call(this, {
                    chart: this.chart,
                    tooltip: this,
                    replay
                });
            }
            drawCaret(tooltipPoint, ctx, size, options) {
                const caretPosition = this.getCaretPosition(tooltipPoint, size, options);
                ctx.lineTo(caretPosition.x1, caretPosition.y1);
                ctx.lineTo(caretPosition.x2, caretPosition.y2);
                ctx.lineTo(caretPosition.x3, caretPosition.y3);
            }
            getCaretPosition(tooltipPoint, size, options) {
                const {xAlign, yAlign} = this;
                const {caretSize, cornerRadius} = options;
                const {topLeft, topRight, bottomLeft, bottomRight} = toTRBLCorners(cornerRadius);
                const {x: ptX, y: ptY} = tooltipPoint;
                const {width, height} = size;
                let x1, x2, x3, y1, y2, y3;
                if (yAlign === "center") {
                    y2 = ptY + height / 2;
                    if (xAlign === "left") {
                        x1 = ptX;
                        x2 = x1 - caretSize;
                        y1 = y2 + caretSize;
                        y3 = y2 - caretSize;
                    } else {
                        x1 = ptX + width;
                        x2 = x1 + caretSize;
                        y1 = y2 - caretSize;
                        y3 = y2 + caretSize;
                    }
                    x3 = x1;
                } else {
                    if (xAlign === "left") x2 = ptX + Math.max(topLeft, bottomLeft) + caretSize; else if (xAlign === "right") x2 = ptX + width - Math.max(topRight, bottomRight) - caretSize; else x2 = this.caretX;
                    if (yAlign === "top") {
                        y1 = ptY;
                        y2 = y1 - caretSize;
                        x1 = x2 - caretSize;
                        x3 = x2 + caretSize;
                    } else {
                        y1 = ptY + height;
                        y2 = y1 + caretSize;
                        x1 = x2 + caretSize;
                        x3 = x2 - caretSize;
                    }
                    y3 = y1;
                }
                return {
                    x1,
                    x2,
                    x3,
                    y1,
                    y2,
                    y3
                };
            }
            drawTitle(pt, ctx, options) {
                const title = this.title;
                const length = title.length;
                let titleFont, titleSpacing, i;
                if (length) {
                    const rtlHelper = getRtlAdapter(options.rtl, this.x, this.width);
                    pt.x = getAlignedX(this, options.titleAlign, options);
                    ctx.textAlign = rtlHelper.textAlign(options.titleAlign);
                    ctx.textBaseline = "middle";
                    titleFont = toFont(options.titleFont);
                    titleSpacing = options.titleSpacing;
                    ctx.fillStyle = options.titleColor;
                    ctx.font = titleFont.string;
                    for (i = 0; i < length; ++i) {
                        ctx.fillText(title[i], rtlHelper.x(pt.x), pt.y + titleFont.lineHeight / 2);
                        pt.y += titleFont.lineHeight + titleSpacing;
                        if (i + 1 === length) pt.y += options.titleMarginBottom - titleSpacing;
                    }
                }
            }
            _drawColorBox(ctx, pt, i, rtlHelper, options) {
                const labelColor = this.labelColors[i];
                const labelPointStyle = this.labelPointStyles[i];
                const {boxHeight, boxWidth} = options;
                const bodyFont = toFont(options.bodyFont);
                const colorX = getAlignedX(this, "left", options);
                const rtlColorX = rtlHelper.x(colorX);
                const yOffSet = boxHeight < bodyFont.lineHeight ? (bodyFont.lineHeight - boxHeight) / 2 : 0;
                const colorY = pt.y + yOffSet;
                if (options.usePointStyle) {
                    const drawOptions = {
                        radius: Math.min(boxWidth, boxHeight) / 2,
                        pointStyle: labelPointStyle.pointStyle,
                        rotation: labelPointStyle.rotation,
                        borderWidth: 1
                    };
                    const centerX = rtlHelper.leftForLtr(rtlColorX, boxWidth) + boxWidth / 2;
                    const centerY = colorY + boxHeight / 2;
                    ctx.strokeStyle = options.multiKeyBackground;
                    ctx.fillStyle = options.multiKeyBackground;
                    drawPoint(ctx, drawOptions, centerX, centerY);
                    ctx.strokeStyle = labelColor.borderColor;
                    ctx.fillStyle = labelColor.backgroundColor;
                    drawPoint(ctx, drawOptions, centerX, centerY);
                } else {
                    ctx.lineWidth = helpers_segment_isObject(labelColor.borderWidth) ? Math.max(...Object.values(labelColor.borderWidth)) : labelColor.borderWidth || 1;
                    ctx.strokeStyle = labelColor.borderColor;
                    ctx.setLineDash(labelColor.borderDash || []);
                    ctx.lineDashOffset = labelColor.borderDashOffset || 0;
                    const outerX = rtlHelper.leftForLtr(rtlColorX, boxWidth);
                    const innerX = rtlHelper.leftForLtr(rtlHelper.xPlus(rtlColorX, 1), boxWidth - 2);
                    const borderRadius = toTRBLCorners(labelColor.borderRadius);
                    if (Object.values(borderRadius).some((v => v !== 0))) {
                        ctx.beginPath();
                        ctx.fillStyle = options.multiKeyBackground;
                        addRoundedRectPath(ctx, {
                            x: outerX,
                            y: colorY,
                            w: boxWidth,
                            h: boxHeight,
                            radius: borderRadius
                        });
                        ctx.fill();
                        ctx.stroke();
                        ctx.fillStyle = labelColor.backgroundColor;
                        ctx.beginPath();
                        addRoundedRectPath(ctx, {
                            x: innerX,
                            y: colorY + 1,
                            w: boxWidth - 2,
                            h: boxHeight - 2,
                            radius: borderRadius
                        });
                        ctx.fill();
                    } else {
                        ctx.fillStyle = options.multiKeyBackground;
                        ctx.fillRect(outerX, colorY, boxWidth, boxHeight);
                        ctx.strokeRect(outerX, colorY, boxWidth, boxHeight);
                        ctx.fillStyle = labelColor.backgroundColor;
                        ctx.fillRect(innerX, colorY + 1, boxWidth - 2, boxHeight - 2);
                    }
                }
                ctx.fillStyle = this.labelTextColors[i];
            }
            drawBody(pt, ctx, options) {
                const {body} = this;
                const {bodySpacing, bodyAlign, displayColors, boxHeight, boxWidth, boxPadding} = options;
                const bodyFont = toFont(options.bodyFont);
                let bodyLineHeight = bodyFont.lineHeight;
                let xLinePadding = 0;
                const rtlHelper = getRtlAdapter(options.rtl, this.x, this.width);
                const fillLineOfText = function(line) {
                    ctx.fillText(line, rtlHelper.x(pt.x + xLinePadding), pt.y + bodyLineHeight / 2);
                    pt.y += bodyLineHeight + bodySpacing;
                };
                const bodyAlignForCalculation = rtlHelper.textAlign(bodyAlign);
                let bodyItem, textColor, lines, i, j, ilen, jlen;
                ctx.textAlign = bodyAlign;
                ctx.textBaseline = "middle";
                ctx.font = bodyFont.string;
                pt.x = getAlignedX(this, bodyAlignForCalculation, options);
                ctx.fillStyle = options.bodyColor;
                each(this.beforeBody, fillLineOfText);
                xLinePadding = displayColors && bodyAlignForCalculation !== "right" ? bodyAlign === "center" ? boxWidth / 2 + boxPadding : boxWidth + 2 + boxPadding : 0;
                for (i = 0, ilen = body.length; i < ilen; ++i) {
                    bodyItem = body[i];
                    textColor = this.labelTextColors[i];
                    ctx.fillStyle = textColor;
                    each(bodyItem.before, fillLineOfText);
                    lines = bodyItem.lines;
                    if (displayColors && lines.length) {
                        this._drawColorBox(ctx, pt, i, rtlHelper, options);
                        bodyLineHeight = Math.max(bodyFont.lineHeight, boxHeight);
                    }
                    for (j = 0, jlen = lines.length; j < jlen; ++j) {
                        fillLineOfText(lines[j]);
                        bodyLineHeight = bodyFont.lineHeight;
                    }
                    each(bodyItem.after, fillLineOfText);
                }
                xLinePadding = 0;
                bodyLineHeight = bodyFont.lineHeight;
                each(this.afterBody, fillLineOfText);
                pt.y -= bodySpacing;
            }
            drawFooter(pt, ctx, options) {
                const footer = this.footer;
                const length = footer.length;
                let footerFont, i;
                if (length) {
                    const rtlHelper = getRtlAdapter(options.rtl, this.x, this.width);
                    pt.x = getAlignedX(this, options.footerAlign, options);
                    pt.y += options.footerMarginTop;
                    ctx.textAlign = rtlHelper.textAlign(options.footerAlign);
                    ctx.textBaseline = "middle";
                    footerFont = toFont(options.footerFont);
                    ctx.fillStyle = options.footerColor;
                    ctx.font = footerFont.string;
                    for (i = 0; i < length; ++i) {
                        ctx.fillText(footer[i], rtlHelper.x(pt.x), pt.y + footerFont.lineHeight / 2);
                        pt.y += footerFont.lineHeight + options.footerSpacing;
                    }
                }
            }
            drawBackground(pt, ctx, tooltipSize, options) {
                const {xAlign, yAlign} = this;
                const {x, y} = pt;
                const {width, height} = tooltipSize;
                const {topLeft, topRight, bottomLeft, bottomRight} = toTRBLCorners(options.cornerRadius);
                ctx.fillStyle = options.backgroundColor;
                ctx.strokeStyle = options.borderColor;
                ctx.lineWidth = options.borderWidth;
                ctx.beginPath();
                ctx.moveTo(x + topLeft, y);
                if (yAlign === "top") this.drawCaret(pt, ctx, tooltipSize, options);
                ctx.lineTo(x + width - topRight, y);
                ctx.quadraticCurveTo(x + width, y, x + width, y + topRight);
                if (yAlign === "center" && xAlign === "right") this.drawCaret(pt, ctx, tooltipSize, options);
                ctx.lineTo(x + width, y + height - bottomRight);
                ctx.quadraticCurveTo(x + width, y + height, x + width - bottomRight, y + height);
                if (yAlign === "bottom") this.drawCaret(pt, ctx, tooltipSize, options);
                ctx.lineTo(x + bottomLeft, y + height);
                ctx.quadraticCurveTo(x, y + height, x, y + height - bottomLeft);
                if (yAlign === "center" && xAlign === "left") this.drawCaret(pt, ctx, tooltipSize, options);
                ctx.lineTo(x, y + topLeft);
                ctx.quadraticCurveTo(x, y, x + topLeft, y);
                ctx.closePath();
                ctx.fill();
                if (options.borderWidth > 0) ctx.stroke();
            }
            _updateAnimationTarget(options) {
                const chart = this.chart;
                const anims = this.$animations;
                const animX = anims && anims.x;
                const animY = anims && anims.y;
                if (animX || animY) {
                    const position = positioners[options.position].call(this, this._active, this._eventPosition);
                    if (!position) return;
                    const size = this._size = getTooltipSize(this, options);
                    const positionAndSize = Object.assign({}, position, this._size);
                    const alignment = determineAlignment(chart, options, positionAndSize);
                    const point = getBackgroundPoint(options, positionAndSize, alignment, chart);
                    if (animX._to !== point.x || animY._to !== point.y) {
                        this.xAlign = alignment.xAlign;
                        this.yAlign = alignment.yAlign;
                        this.width = size.width;
                        this.height = size.height;
                        this.caretX = position.x;
                        this.caretY = position.y;
                        this._resolveAnimations().update(this, point);
                    }
                }
            }
            _willRender() {
                return !!this.opacity;
            }
            draw(ctx) {
                const options = this.options.setContext(this.getContext());
                let opacity = this.opacity;
                if (!opacity) return;
                this._updateAnimationTarget(options);
                const tooltipSize = {
                    width: this.width,
                    height: this.height
                };
                const pt = {
                    x: this.x,
                    y: this.y
                };
                opacity = Math.abs(opacity) < .001 ? 0 : opacity;
                const padding = toPadding(options.padding);
                const hasTooltipContent = this.title.length || this.beforeBody.length || this.body.length || this.afterBody.length || this.footer.length;
                if (options.enabled && hasTooltipContent) {
                    ctx.save();
                    ctx.globalAlpha = opacity;
                    this.drawBackground(pt, ctx, tooltipSize, options);
                    overrideTextDirection(ctx, options.textDirection);
                    pt.y += padding.top;
                    this.drawTitle(pt, ctx, options);
                    this.drawBody(pt, ctx, options);
                    this.drawFooter(pt, ctx, options);
                    restoreTextDirection(ctx, options.textDirection);
                    ctx.restore();
                }
            }
            getActiveElements() {
                return this._active || [];
            }
            setActiveElements(activeElements, eventPosition) {
                const lastActive = this._active;
                const active = activeElements.map((({datasetIndex, index}) => {
                    const meta = this.chart.getDatasetMeta(datasetIndex);
                    if (!meta) throw new Error("Cannot find a dataset at index " + datasetIndex);
                    return {
                        datasetIndex,
                        element: meta.data[index],
                        index
                    };
                }));
                const changed = !_elementsEqual(lastActive, active);
                const positionChanged = this._positionChanged(active, eventPosition);
                if (changed || positionChanged) {
                    this._active = active;
                    this._eventPosition = eventPosition;
                    this._ignoreReplayEvents = true;
                    this.update(true);
                }
            }
            handleEvent(e, replay, inChartArea = true) {
                if (replay && this._ignoreReplayEvents) return false;
                this._ignoreReplayEvents = false;
                const options = this.options;
                const lastActive = this._active || [];
                const active = this._getActiveElements(e, lastActive, replay, inChartArea);
                const positionChanged = this._positionChanged(active, e);
                const changed = replay || !_elementsEqual(active, lastActive) || positionChanged;
                if (changed) {
                    this._active = active;
                    if (options.enabled || options.external) {
                        this._eventPosition = {
                            x: e.x,
                            y: e.y
                        };
                        this.update(true, replay);
                    }
                }
                return changed;
            }
            _getActiveElements(e, lastActive, replay, inChartArea) {
                const options = this.options;
                if (e.type === "mouseout") return [];
                if (!inChartArea) return lastActive.filter((i => this.chart.data.datasets[i.datasetIndex] && this.chart.getDatasetMeta(i.datasetIndex).controller.getParsed(i.index) !== void 0));
                const active = this.chart.getElementsAtEventForMode(e, options.mode, options, replay);
                if (options.reverse) active.reverse();
                return active;
            }
            _positionChanged(active, e) {
                const {caretX, caretY, options} = this;
                const position = positioners[options.position].call(this, active, e);
                return position !== false && (caretX !== position.x || caretY !== position.y);
            }
        }
        var plugin_tooltip = {
            id: "tooltip",
            _element: chart_Tooltip,
            positioners,
            afterInit(chart, _args, options) {
                if (options) chart.tooltip = new chart_Tooltip({
                    chart,
                    options
                });
            },
            beforeUpdate(chart, _args, options) {
                if (chart.tooltip) chart.tooltip.initialize(options);
            },
            reset(chart, _args, options) {
                if (chart.tooltip) chart.tooltip.initialize(options);
            },
            afterDraw(chart) {
                const tooltip = chart.tooltip;
                if (tooltip && tooltip._willRender()) {
                    const args = {
                        tooltip
                    };
                    if (chart.notifyPlugins("beforeTooltipDraw", {
                        ...args,
                        cancelable: true
                    }) === false) return;
                    tooltip.draw(chart.ctx);
                    chart.notifyPlugins("afterTooltipDraw", args);
                }
            },
            afterEvent(chart, args) {
                if (chart.tooltip) {
                    const useFinalPosition = args.replay;
                    if (chart.tooltip.handleEvent(args.event, useFinalPosition, args.inChartArea)) args.changed = true;
                }
            },
            defaults: {
                enabled: true,
                external: null,
                position: "average",
                backgroundColor: "rgba(0,0,0,0.8)",
                titleColor: "#fff",
                titleFont: {
                    weight: "bold"
                },
                titleSpacing: 2,
                titleMarginBottom: 6,
                titleAlign: "left",
                bodyColor: "#fff",
                bodySpacing: 2,
                bodyFont: {},
                bodyAlign: "left",
                footerColor: "#fff",
                footerSpacing: 2,
                footerMarginTop: 6,
                footerFont: {
                    weight: "bold"
                },
                footerAlign: "left",
                padding: 6,
                caretPadding: 2,
                caretSize: 5,
                cornerRadius: 6,
                boxHeight: (ctx, opts) => opts.bodyFont.size,
                boxWidth: (ctx, opts) => opts.bodyFont.size,
                multiKeyBackground: "#fff",
                displayColors: true,
                boxPadding: 0,
                borderColor: "rgba(0,0,0,0)",
                borderWidth: 0,
                animation: {
                    duration: 400,
                    easing: "easeOutQuart"
                },
                animations: {
                    numbers: {
                        type: "number",
                        properties: [ "x", "y", "width", "height", "caretX", "caretY" ]
                    },
                    opacity: {
                        easing: "linear",
                        duration: 200
                    }
                },
                callbacks: defaultCallbacks
            },
            defaultRoutes: {
                bodyFont: "font",
                footerFont: "font",
                titleFont: "font"
            },
            descriptors: {
                _scriptable: name => name !== "filter" && name !== "itemSort" && name !== "external",
                _indexable: false,
                callbacks: {
                    _scriptable: false,
                    _indexable: false
                },
                animation: {
                    _fallback: false
                },
                animations: {
                    _fallback: "animation"
                }
            },
            additionalOptionScopes: [ "interaction" ]
        };
        var plugins = Object.freeze({
            __proto__: null,
            Colors: plugin_colors,
            Decimation: plugin_decimation,
            Filler: index,
            Legend: plugin_legend,
            SubTitle: plugin_subtitle,
            Title: plugin_title,
            Tooltip: plugin_tooltip
        });
        const addIfString = (labels, raw, index, addedLabels) => {
            if (typeof raw === "string") {
                index = labels.push(raw) - 1;
                addedLabels.unshift({
                    index,
                    label: raw
                });
            } else if (isNaN(raw)) index = null;
            return index;
        };
        function findOrAddLabel(labels, raw, index, addedLabels) {
            const first = labels.indexOf(raw);
            if (first === -1) return addIfString(labels, raw, index, addedLabels);
            const last = labels.lastIndexOf(raw);
            return first !== last ? index : first;
        }
        const validIndex = (index, max) => index === null ? null : _limitValue(Math.round(index), 0, max);
        function _getLabelForValue(value) {
            const labels = this.getLabels();
            if (value >= 0 && value < labels.length) return labels[value];
            return value;
        }
        class CategoryScale extends Scale {
            static id="category";
            static defaults={
                ticks: {
                    callback: _getLabelForValue
                }
            };
            constructor(cfg) {
                super(cfg);
                this._startValue = void 0;
                this._valueRange = 0;
                this._addedLabels = [];
            }
            init(scaleOptions) {
                const added = this._addedLabels;
                if (added.length) {
                    const labels = this.getLabels();
                    for (const {index, label} of added) if (labels[index] === label) labels.splice(index, 1);
                    this._addedLabels = [];
                }
                super.init(scaleOptions);
            }
            parse(raw, index) {
                if (isNullOrUndef(raw)) return null;
                const labels = this.getLabels();
                index = isFinite(index) && labels[index] === raw ? index : findOrAddLabel(labels, raw, valueOrDefault(index, raw), this._addedLabels);
                return validIndex(index, labels.length - 1);
            }
            determineDataLimits() {
                const {minDefined, maxDefined} = this.getUserBounds();
                let {min, max} = this.getMinMax(true);
                if (this.options.bounds === "ticks") {
                    if (!minDefined) min = 0;
                    if (!maxDefined) max = this.getLabels().length - 1;
                }
                this.min = min;
                this.max = max;
            }
            buildTicks() {
                const min = this.min;
                const max = this.max;
                const offset = this.options.offset;
                const ticks = [];
                let labels = this.getLabels();
                labels = min === 0 && max === labels.length - 1 ? labels : labels.slice(min, max + 1);
                this._valueRange = Math.max(labels.length - (offset ? 0 : 1), 1);
                this._startValue = this.min - (offset ? .5 : 0);
                for (let value = min; value <= max; value++) ticks.push({
                    value
                });
                return ticks;
            }
            getLabelForValue(value) {
                return _getLabelForValue.call(this, value);
            }
            configure() {
                super.configure();
                if (!this.isHorizontal()) this._reversePixels = !this._reversePixels;
            }
            getPixelForValue(value) {
                if (typeof value !== "number") value = this.parse(value);
                return value === null ? NaN : this.getPixelForDecimal((value - this._startValue) / this._valueRange);
            }
            getPixelForTick(index) {
                const ticks = this.ticks;
                if (index < 0 || index > ticks.length - 1) return null;
                return this.getPixelForValue(ticks[index].value);
            }
            getValueForPixel(pixel) {
                return Math.round(this._startValue + this.getDecimalForPixel(pixel) * this._valueRange);
            }
            getBasePixel() {
                return this.bottom;
            }
        }
        function generateTicks$1(generationOptions, dataRange) {
            const ticks = [];
            const MIN_SPACING = 1e-14;
            const {bounds, step, min, max, precision, count, maxTicks, maxDigits, includeBounds} = generationOptions;
            const unit = step || 1;
            const maxSpaces = maxTicks - 1;
            const {min: rmin, max: rmax} = dataRange;
            const minDefined = !isNullOrUndef(min);
            const maxDefined = !isNullOrUndef(max);
            const countDefined = !isNullOrUndef(count);
            const minSpacing = (rmax - rmin) / (maxDigits + 1);
            let spacing = niceNum((rmax - rmin) / maxSpaces / unit) * unit;
            let factor, niceMin, niceMax, numSpaces;
            if (spacing < MIN_SPACING && !minDefined && !maxDefined) return [ {
                value: rmin
            }, {
                value: rmax
            } ];
            numSpaces = Math.ceil(rmax / spacing) - Math.floor(rmin / spacing);
            if (numSpaces > maxSpaces) spacing = niceNum(numSpaces * spacing / maxSpaces / unit) * unit;
            if (!isNullOrUndef(precision)) {
                factor = Math.pow(10, precision);
                spacing = Math.ceil(spacing * factor) / factor;
            }
            if (bounds === "ticks") {
                niceMin = Math.floor(rmin / spacing) * spacing;
                niceMax = Math.ceil(rmax / spacing) * spacing;
            } else {
                niceMin = rmin;
                niceMax = rmax;
            }
            if (minDefined && maxDefined && step && almostWhole((max - min) / step, spacing / 1e3)) {
                numSpaces = Math.round(Math.min((max - min) / spacing, maxTicks));
                spacing = (max - min) / numSpaces;
                niceMin = min;
                niceMax = max;
            } else if (countDefined) {
                niceMin = minDefined ? min : niceMin;
                niceMax = maxDefined ? max : niceMax;
                numSpaces = count - 1;
                spacing = (niceMax - niceMin) / numSpaces;
            } else {
                numSpaces = (niceMax - niceMin) / spacing;
                if (almostEquals(numSpaces, Math.round(numSpaces), spacing / 1e3)) numSpaces = Math.round(numSpaces); else numSpaces = Math.ceil(numSpaces);
            }
            const decimalPlaces = Math.max(_decimalPlaces(spacing), _decimalPlaces(niceMin));
            factor = Math.pow(10, isNullOrUndef(precision) ? decimalPlaces : precision);
            niceMin = Math.round(niceMin * factor) / factor;
            niceMax = Math.round(niceMax * factor) / factor;
            let j = 0;
            if (minDefined) if (includeBounds && niceMin !== min) {
                ticks.push({
                    value: min
                });
                if (niceMin < min) j++;
                if (almostEquals(Math.round((niceMin + j * spacing) * factor) / factor, min, relativeLabelSize(min, minSpacing, generationOptions))) j++;
            } else if (niceMin < min) j++;
            for (;j < numSpaces; ++j) {
                const tickValue = Math.round((niceMin + j * spacing) * factor) / factor;
                if (maxDefined && tickValue > max) break;
                ticks.push({
                    value: tickValue
                });
            }
            if (maxDefined && includeBounds && niceMax !== max) if (ticks.length && almostEquals(ticks[ticks.length - 1].value, max, relativeLabelSize(max, minSpacing, generationOptions))) ticks[ticks.length - 1].value = max; else ticks.push({
                value: max
            }); else if (!maxDefined || niceMax === max) ticks.push({
                value: niceMax
            });
            return ticks;
        }
        function relativeLabelSize(value, minSpacing, {horizontal, minRotation}) {
            const rad = toRadians(minRotation);
            const ratio = (horizontal ? Math.sin(rad) : Math.cos(rad)) || .001;
            const length = .75 * minSpacing * ("" + value).length;
            return Math.min(minSpacing / ratio, length);
        }
        class LinearScaleBase extends Scale {
            constructor(cfg) {
                super(cfg);
                this.start = void 0;
                this.end = void 0;
                this._startValue = void 0;
                this._endValue = void 0;
                this._valueRange = 0;
            }
            parse(raw, index) {
                if (isNullOrUndef(raw)) return null;
                if ((typeof raw === "number" || raw instanceof Number) && !isFinite(+raw)) return null;
                return +raw;
            }
            handleTickRangeOptions() {
                const {beginAtZero} = this.options;
                const {minDefined, maxDefined} = this.getUserBounds();
                let {min, max} = this;
                const setMin = v => min = minDefined ? min : v;
                const setMax = v => max = maxDefined ? max : v;
                if (beginAtZero) {
                    const minSign = sign(min);
                    const maxSign = sign(max);
                    if (minSign < 0 && maxSign < 0) setMax(0); else if (minSign > 0 && maxSign > 0) setMin(0);
                }
                if (min === max) {
                    let offset = max === 0 ? 1 : Math.abs(max * .05);
                    setMax(max + offset);
                    if (!beginAtZero) setMin(min - offset);
                }
                this.min = min;
                this.max = max;
            }
            getTickLimit() {
                const tickOpts = this.options.ticks;
                let {maxTicksLimit, stepSize} = tickOpts;
                let maxTicks;
                if (stepSize) {
                    maxTicks = Math.ceil(this.max / stepSize) - Math.floor(this.min / stepSize) + 1;
                    if (maxTicks > 1e3) {
                        console.warn(`scales.${this.id}.ticks.stepSize: ${stepSize} would result generating up to ${maxTicks} ticks. Limiting to 1000.`);
                        maxTicks = 1e3;
                    }
                } else {
                    maxTicks = this.computeTickLimit();
                    maxTicksLimit = maxTicksLimit || 11;
                }
                if (maxTicksLimit) maxTicks = Math.min(maxTicksLimit, maxTicks);
                return maxTicks;
            }
            computeTickLimit() {
                return Number.POSITIVE_INFINITY;
            }
            buildTicks() {
                const opts = this.options;
                const tickOpts = opts.ticks;
                let maxTicks = this.getTickLimit();
                maxTicks = Math.max(2, maxTicks);
                const numericGeneratorOptions = {
                    maxTicks,
                    bounds: opts.bounds,
                    min: opts.min,
                    max: opts.max,
                    precision: tickOpts.precision,
                    step: tickOpts.stepSize,
                    count: tickOpts.count,
                    maxDigits: this._maxDigits(),
                    horizontal: this.isHorizontal(),
                    minRotation: tickOpts.minRotation || 0,
                    includeBounds: tickOpts.includeBounds !== false
                };
                const dataRange = this._range || this;
                const ticks = generateTicks$1(numericGeneratorOptions, dataRange);
                if (opts.bounds === "ticks") _setMinAndMaxByKey(ticks, this, "value");
                if (opts.reverse) {
                    ticks.reverse();
                    this.start = this.max;
                    this.end = this.min;
                } else {
                    this.start = this.min;
                    this.end = this.max;
                }
                return ticks;
            }
            configure() {
                const ticks = this.ticks;
                let start = this.min;
                let end = this.max;
                super.configure();
                if (this.options.offset && ticks.length) {
                    const offset = (end - start) / Math.max(ticks.length - 1, 1) / 2;
                    start -= offset;
                    end += offset;
                }
                this._startValue = start;
                this._endValue = end;
                this._valueRange = end - start;
            }
            getLabelForValue(value) {
                return formatNumber(value, this.chart.options.locale, this.options.ticks.format);
            }
        }
        class LinearScale extends LinearScaleBase {
            static id="linear";
            static defaults={
                ticks: {
                    callback: Ticks.formatters.numeric
                }
            };
            determineDataLimits() {
                const {min, max} = this.getMinMax(true);
                this.min = isNumberFinite(min) ? min : 0;
                this.max = isNumberFinite(max) ? max : 1;
                this.handleTickRangeOptions();
            }
            computeTickLimit() {
                const horizontal = this.isHorizontal();
                const length = horizontal ? this.width : this.height;
                const minRotation = toRadians(this.options.ticks.minRotation);
                const ratio = (horizontal ? Math.sin(minRotation) : Math.cos(minRotation)) || .001;
                const tickFont = this._resolveTickFontOptions(0);
                return Math.ceil(length / Math.min(40, tickFont.lineHeight / ratio));
            }
            getPixelForValue(value) {
                return value === null ? NaN : this.getPixelForDecimal((value - this._startValue) / this._valueRange);
            }
            getValueForPixel(pixel) {
                return this._startValue + this.getDecimalForPixel(pixel) * this._valueRange;
            }
        }
        const log10Floor = v => Math.floor(log10(v));
        const changeExponent = (v, m) => Math.pow(10, log10Floor(v) + m);
        function isMajor(tickVal) {
            const remain = tickVal / Math.pow(10, log10Floor(tickVal));
            return remain === 1;
        }
        function steps(min, max, rangeExp) {
            const rangeStep = Math.pow(10, rangeExp);
            const start = Math.floor(min / rangeStep);
            const end = Math.ceil(max / rangeStep);
            return end - start;
        }
        function startExp(min, max) {
            const range = max - min;
            let rangeExp = log10Floor(range);
            while (steps(min, max, rangeExp) > 10) rangeExp++;
            while (steps(min, max, rangeExp) < 10) rangeExp--;
            return Math.min(rangeExp, log10Floor(min));
        }
        function generateTicks(generationOptions, {min, max}) {
            min = finiteOrDefault(generationOptions.min, min);
            const ticks = [];
            const minExp = log10Floor(min);
            let exp = startExp(min, max);
            let precision = exp < 0 ? Math.pow(10, Math.abs(exp)) : 1;
            const stepSize = Math.pow(10, exp);
            const base = minExp > exp ? Math.pow(10, minExp) : 0;
            const start = Math.round((min - base) * precision) / precision;
            const offset = Math.floor((min - base) / stepSize / 10) * stepSize * 10;
            let significand = Math.floor((start - offset) / Math.pow(10, exp));
            let value = finiteOrDefault(generationOptions.min, Math.round((base + offset + significand * Math.pow(10, exp)) * precision) / precision);
            while (value < max) {
                ticks.push({
                    value,
                    major: isMajor(value),
                    significand
                });
                if (significand >= 10) significand = significand < 15 ? 15 : 20; else significand++;
                if (significand >= 20) {
                    exp++;
                    significand = 2;
                    precision = exp >= 0 ? 1 : precision;
                }
                value = Math.round((base + offset + significand * Math.pow(10, exp)) * precision) / precision;
            }
            const lastTick = finiteOrDefault(generationOptions.max, value);
            ticks.push({
                value: lastTick,
                major: isMajor(lastTick),
                significand
            });
            return ticks;
        }
        class LogarithmicScale extends Scale {
            static id="logarithmic";
            static defaults={
                ticks: {
                    callback: Ticks.formatters.logarithmic,
                    major: {
                        enabled: true
                    }
                }
            };
            constructor(cfg) {
                super(cfg);
                this.start = void 0;
                this.end = void 0;
                this._startValue = void 0;
                this._valueRange = 0;
            }
            parse(raw, index) {
                const value = LinearScaleBase.prototype.parse.apply(this, [ raw, index ]);
                if (value === 0) {
                    this._zero = true;
                    return;
                }
                return isNumberFinite(value) && value > 0 ? value : null;
            }
            determineDataLimits() {
                const {min, max} = this.getMinMax(true);
                this.min = isNumberFinite(min) ? Math.max(0, min) : null;
                this.max = isNumberFinite(max) ? Math.max(0, max) : null;
                if (this.options.beginAtZero) this._zero = true;
                if (this._zero && this.min !== this._suggestedMin && !isNumberFinite(this._userMin)) this.min = min === changeExponent(this.min, 0) ? changeExponent(this.min, -1) : changeExponent(this.min, 0);
                this.handleTickRangeOptions();
            }
            handleTickRangeOptions() {
                const {minDefined, maxDefined} = this.getUserBounds();
                let min = this.min;
                let max = this.max;
                const setMin = v => min = minDefined ? min : v;
                const setMax = v => max = maxDefined ? max : v;
                if (min === max) if (min <= 0) {
                    setMin(1);
                    setMax(10);
                } else {
                    setMin(changeExponent(min, -1));
                    setMax(changeExponent(max, +1));
                }
                if (min <= 0) setMin(changeExponent(max, -1));
                if (max <= 0) setMax(changeExponent(min, +1));
                this.min = min;
                this.max = max;
            }
            buildTicks() {
                const opts = this.options;
                const generationOptions = {
                    min: this._userMin,
                    max: this._userMax
                };
                const ticks = generateTicks(generationOptions, this);
                if (opts.bounds === "ticks") _setMinAndMaxByKey(ticks, this, "value");
                if (opts.reverse) {
                    ticks.reverse();
                    this.start = this.max;
                    this.end = this.min;
                } else {
                    this.start = this.min;
                    this.end = this.max;
                }
                return ticks;
            }
            getLabelForValue(value) {
                return value === void 0 ? "0" : formatNumber(value, this.chart.options.locale, this.options.ticks.format);
            }
            configure() {
                const start = this.min;
                super.configure();
                this._startValue = log10(start);
                this._valueRange = log10(this.max) - log10(start);
            }
            getPixelForValue(value) {
                if (value === void 0 || value === 0) value = this.min;
                if (value === null || isNaN(value)) return NaN;
                return this.getPixelForDecimal(value === this.min ? 0 : (log10(value) - this._startValue) / this._valueRange);
            }
            getValueForPixel(pixel) {
                const decimal = this.getDecimalForPixel(pixel);
                return Math.pow(10, this._startValue + decimal * this._valueRange);
            }
        }
        function getTickBackdropHeight(opts) {
            const tickOpts = opts.ticks;
            if (tickOpts.display && opts.display) {
                const padding = toPadding(tickOpts.backdropPadding);
                return valueOrDefault(tickOpts.font && tickOpts.font.size, defaults.font.size) + padding.height;
            }
            return 0;
        }
        function measureLabelSize(ctx, font, label) {
            label = isArray(label) ? label : [ label ];
            return {
                w: _longestText(ctx, font.string, label),
                h: label.length * font.lineHeight
            };
        }
        function determineLimits(angle, pos, size, min, max) {
            if (angle === min || angle === max) return {
                start: pos - size / 2,
                end: pos + size / 2
            }; else if (angle < min || angle > max) return {
                start: pos - size,
                end: pos
            };
            return {
                start: pos,
                end: pos + size
            };
        }
        function fitWithPointLabels(scale) {
            const orig = {
                l: scale.left + scale._padding.left,
                r: scale.right - scale._padding.right,
                t: scale.top + scale._padding.top,
                b: scale.bottom - scale._padding.bottom
            };
            const limits = Object.assign({}, orig);
            const labelSizes = [];
            const padding = [];
            const valueCount = scale._pointLabels.length;
            const pointLabelOpts = scale.options.pointLabels;
            const additionalAngle = pointLabelOpts.centerPointLabels ? PI / valueCount : 0;
            for (let i = 0; i < valueCount; i++) {
                const opts = pointLabelOpts.setContext(scale.getPointLabelContext(i));
                padding[i] = opts.padding;
                const pointPosition = scale.getPointPosition(i, scale.drawingArea + padding[i], additionalAngle);
                const plFont = toFont(opts.font);
                const textSize = measureLabelSize(scale.ctx, plFont, scale._pointLabels[i]);
                labelSizes[i] = textSize;
                const angleRadians = _normalizeAngle(scale.getIndexAngle(i) + additionalAngle);
                const angle = Math.round(toDegrees(angleRadians));
                const hLimits = determineLimits(angle, pointPosition.x, textSize.w, 0, 180);
                const vLimits = determineLimits(angle, pointPosition.y, textSize.h, 90, 270);
                updateLimits(limits, orig, angleRadians, hLimits, vLimits);
            }
            scale.setCenterPoint(orig.l - limits.l, limits.r - orig.r, orig.t - limits.t, limits.b - orig.b);
            scale._pointLabelItems = buildPointLabelItems(scale, labelSizes, padding);
        }
        function updateLimits(limits, orig, angle, hLimits, vLimits) {
            const sin = Math.abs(Math.sin(angle));
            const cos = Math.abs(Math.cos(angle));
            let x = 0;
            let y = 0;
            if (hLimits.start < orig.l) {
                x = (orig.l - hLimits.start) / sin;
                limits.l = Math.min(limits.l, orig.l - x);
            } else if (hLimits.end > orig.r) {
                x = (hLimits.end - orig.r) / sin;
                limits.r = Math.max(limits.r, orig.r + x);
            }
            if (vLimits.start < orig.t) {
                y = (orig.t - vLimits.start) / cos;
                limits.t = Math.min(limits.t, orig.t - y);
            } else if (vLimits.end > orig.b) {
                y = (vLimits.end - orig.b) / cos;
                limits.b = Math.max(limits.b, orig.b + y);
            }
        }
        function createPointLabelItem(scale, index, itemOpts) {
            const outerDistance = scale.drawingArea;
            const {extra, additionalAngle, padding, size} = itemOpts;
            const pointLabelPosition = scale.getPointPosition(index, outerDistance + extra + padding, additionalAngle);
            const angle = Math.round(toDegrees(_normalizeAngle(pointLabelPosition.angle + HALF_PI)));
            const y = yForAngle(pointLabelPosition.y, size.h, angle);
            const textAlign = getTextAlignForAngle(angle);
            const left = leftForTextAlign(pointLabelPosition.x, size.w, textAlign);
            return {
                visible: true,
                x: pointLabelPosition.x,
                y,
                textAlign,
                left,
                top: y,
                right: left + size.w,
                bottom: y + size.h
            };
        }
        function isNotOverlapped(item, area) {
            if (!area) return true;
            const {left, top, right, bottom} = item;
            const apexesInArea = _isPointInArea({
                x: left,
                y: top
            }, area) || _isPointInArea({
                x: left,
                y: bottom
            }, area) || _isPointInArea({
                x: right,
                y: top
            }, area) || _isPointInArea({
                x: right,
                y: bottom
            }, area);
            return !apexesInArea;
        }
        function buildPointLabelItems(scale, labelSizes, padding) {
            const items = [];
            const valueCount = scale._pointLabels.length;
            const opts = scale.options;
            const {centerPointLabels, display} = opts.pointLabels;
            const itemOpts = {
                extra: getTickBackdropHeight(opts) / 2,
                additionalAngle: centerPointLabels ? PI / valueCount : 0
            };
            let area;
            for (let i = 0; i < valueCount; i++) {
                itemOpts.padding = padding[i];
                itemOpts.size = labelSizes[i];
                const item = createPointLabelItem(scale, i, itemOpts);
                items.push(item);
                if (display === "auto") {
                    item.visible = isNotOverlapped(item, area);
                    if (item.visible) area = item;
                }
            }
            return items;
        }
        function getTextAlignForAngle(angle) {
            if (angle === 0 || angle === 180) return "center"; else if (angle < 180) return "left";
            return "right";
        }
        function leftForTextAlign(x, w, align) {
            if (align === "right") x -= w; else if (align === "center") x -= w / 2;
            return x;
        }
        function yForAngle(y, h, angle) {
            if (angle === 90 || angle === 270) y -= h / 2; else if (angle > 270 || angle < 90) y -= h;
            return y;
        }
        function drawPointLabelBox(ctx, opts, item) {
            const {left, top, right, bottom} = item;
            const {backdropColor} = opts;
            if (!isNullOrUndef(backdropColor)) {
                const borderRadius = toTRBLCorners(opts.borderRadius);
                const padding = toPadding(opts.backdropPadding);
                ctx.fillStyle = backdropColor;
                const backdropLeft = left - padding.left;
                const backdropTop = top - padding.top;
                const backdropWidth = right - left + padding.width;
                const backdropHeight = bottom - top + padding.height;
                if (Object.values(borderRadius).some((v => v !== 0))) {
                    ctx.beginPath();
                    addRoundedRectPath(ctx, {
                        x: backdropLeft,
                        y: backdropTop,
                        w: backdropWidth,
                        h: backdropHeight,
                        radius: borderRadius
                    });
                    ctx.fill();
                } else ctx.fillRect(backdropLeft, backdropTop, backdropWidth, backdropHeight);
            }
        }
        function drawPointLabels(scale, labelCount) {
            const {ctx, options: {pointLabels}} = scale;
            for (let i = labelCount - 1; i >= 0; i--) {
                const item = scale._pointLabelItems[i];
                if (!item.visible) continue;
                const optsAtIndex = pointLabels.setContext(scale.getPointLabelContext(i));
                drawPointLabelBox(ctx, optsAtIndex, item);
                const plFont = toFont(optsAtIndex.font);
                const {x, y, textAlign} = item;
                renderText(ctx, scale._pointLabels[i], x, y + plFont.lineHeight / 2, plFont, {
                    color: optsAtIndex.color,
                    textAlign,
                    textBaseline: "middle"
                });
            }
        }
        function pathRadiusLine(scale, radius, circular, labelCount) {
            const {ctx} = scale;
            if (circular) ctx.arc(scale.xCenter, scale.yCenter, radius, 0, TAU); else {
                let pointPosition = scale.getPointPosition(0, radius);
                ctx.moveTo(pointPosition.x, pointPosition.y);
                for (let i = 1; i < labelCount; i++) {
                    pointPosition = scale.getPointPosition(i, radius);
                    ctx.lineTo(pointPosition.x, pointPosition.y);
                }
            }
        }
        function drawRadiusLine(scale, gridLineOpts, radius, labelCount, borderOpts) {
            const ctx = scale.ctx;
            const circular = gridLineOpts.circular;
            const {color, lineWidth} = gridLineOpts;
            if (!circular && !labelCount || !color || !lineWidth || radius < 0) return;
            ctx.save();
            ctx.strokeStyle = color;
            ctx.lineWidth = lineWidth;
            ctx.setLineDash(borderOpts.dash || []);
            ctx.lineDashOffset = borderOpts.dashOffset;
            ctx.beginPath();
            pathRadiusLine(scale, radius, circular, labelCount);
            ctx.closePath();
            ctx.stroke();
            ctx.restore();
        }
        function createPointLabelContext(parent, index, label) {
            return createContext(parent, {
                label,
                index,
                type: "pointLabel"
            });
        }
        class RadialLinearScale extends LinearScaleBase {
            static id="radialLinear";
            static defaults={
                display: true,
                animate: true,
                position: "chartArea",
                angleLines: {
                    display: true,
                    lineWidth: 1,
                    borderDash: [],
                    borderDashOffset: 0
                },
                grid: {
                    circular: false
                },
                startAngle: 0,
                ticks: {
                    showLabelBackdrop: true,
                    callback: Ticks.formatters.numeric
                },
                pointLabels: {
                    backdropColor: void 0,
                    backdropPadding: 2,
                    display: true,
                    font: {
                        size: 10
                    },
                    callback(label) {
                        return label;
                    },
                    padding: 5,
                    centerPointLabels: false
                }
            };
            static defaultRoutes={
                "angleLines.color": "borderColor",
                "pointLabels.color": "color",
                "ticks.color": "color"
            };
            static descriptors={
                angleLines: {
                    _fallback: "grid"
                }
            };
            constructor(cfg) {
                super(cfg);
                this.xCenter = void 0;
                this.yCenter = void 0;
                this.drawingArea = void 0;
                this._pointLabels = [];
                this._pointLabelItems = [];
            }
            setDimensions() {
                const padding = this._padding = toPadding(getTickBackdropHeight(this.options) / 2);
                const w = this.width = this.maxWidth - padding.width;
                const h = this.height = this.maxHeight - padding.height;
                this.xCenter = Math.floor(this.left + w / 2 + padding.left);
                this.yCenter = Math.floor(this.top + h / 2 + padding.top);
                this.drawingArea = Math.floor(Math.min(w, h) / 2);
            }
            determineDataLimits() {
                const {min, max} = this.getMinMax(false);
                this.min = isNumberFinite(min) && !isNaN(min) ? min : 0;
                this.max = isNumberFinite(max) && !isNaN(max) ? max : 0;
                this.handleTickRangeOptions();
            }
            computeTickLimit() {
                return Math.ceil(this.drawingArea / getTickBackdropHeight(this.options));
            }
            generateTickLabels(ticks) {
                LinearScaleBase.prototype.generateTickLabels.call(this, ticks);
                this._pointLabels = this.getLabels().map(((value, index) => {
                    const label = callback(this.options.pointLabels.callback, [ value, index ], this);
                    return label || label === 0 ? label : "";
                })).filter(((v, i) => this.chart.getDataVisibility(i)));
            }
            fit() {
                const opts = this.options;
                if (opts.display && opts.pointLabels.display) fitWithPointLabels(this); else this.setCenterPoint(0, 0, 0, 0);
            }
            setCenterPoint(leftMovement, rightMovement, topMovement, bottomMovement) {
                this.xCenter += Math.floor((leftMovement - rightMovement) / 2);
                this.yCenter += Math.floor((topMovement - bottomMovement) / 2);
                this.drawingArea -= Math.min(this.drawingArea / 2, Math.max(leftMovement, rightMovement, topMovement, bottomMovement));
            }
            getIndexAngle(index) {
                const angleMultiplier = TAU / (this._pointLabels.length || 1);
                const startAngle = this.options.startAngle || 0;
                return _normalizeAngle(index * angleMultiplier + toRadians(startAngle));
            }
            getDistanceFromCenterForValue(value) {
                if (isNullOrUndef(value)) return NaN;
                const scalingFactor = this.drawingArea / (this.max - this.min);
                if (this.options.reverse) return (this.max - value) * scalingFactor;
                return (value - this.min) * scalingFactor;
            }
            getValueForDistanceFromCenter(distance) {
                if (isNullOrUndef(distance)) return NaN;
                const scaledDistance = distance / (this.drawingArea / (this.max - this.min));
                return this.options.reverse ? this.max - scaledDistance : this.min + scaledDistance;
            }
            getPointLabelContext(index) {
                const pointLabels = this._pointLabels || [];
                if (index >= 0 && index < pointLabels.length) {
                    const pointLabel = pointLabels[index];
                    return createPointLabelContext(this.getContext(), index, pointLabel);
                }
            }
            getPointPosition(index, distanceFromCenter, additionalAngle = 0) {
                const angle = this.getIndexAngle(index) - HALF_PI + additionalAngle;
                return {
                    x: Math.cos(angle) * distanceFromCenter + this.xCenter,
                    y: Math.sin(angle) * distanceFromCenter + this.yCenter,
                    angle
                };
            }
            getPointPositionForValue(index, value) {
                return this.getPointPosition(index, this.getDistanceFromCenterForValue(value));
            }
            getBasePosition(index) {
                return this.getPointPositionForValue(index || 0, this.getBaseValue());
            }
            getPointLabelPosition(index) {
                const {left, top, right, bottom} = this._pointLabelItems[index];
                return {
                    left,
                    top,
                    right,
                    bottom
                };
            }
            drawBackground() {
                const {backgroundColor, grid: {circular}} = this.options;
                if (backgroundColor) {
                    const ctx = this.ctx;
                    ctx.save();
                    ctx.beginPath();
                    pathRadiusLine(this, this.getDistanceFromCenterForValue(this._endValue), circular, this._pointLabels.length);
                    ctx.closePath();
                    ctx.fillStyle = backgroundColor;
                    ctx.fill();
                    ctx.restore();
                }
            }
            drawGrid() {
                const ctx = this.ctx;
                const opts = this.options;
                const {angleLines, grid, border} = opts;
                const labelCount = this._pointLabels.length;
                let i, offset, position;
                if (opts.pointLabels.display) drawPointLabels(this, labelCount);
                if (grid.display) this.ticks.forEach(((tick, index) => {
                    if (index !== 0 || index === 0 && this.min < 0) {
                        offset = this.getDistanceFromCenterForValue(tick.value);
                        const context = this.getContext(index);
                        const optsAtIndex = grid.setContext(context);
                        const optsAtIndexBorder = border.setContext(context);
                        drawRadiusLine(this, optsAtIndex, offset, labelCount, optsAtIndexBorder);
                    }
                }));
                if (angleLines.display) {
                    ctx.save();
                    for (i = labelCount - 1; i >= 0; i--) {
                        const optsAtIndex = angleLines.setContext(this.getPointLabelContext(i));
                        const {color, lineWidth} = optsAtIndex;
                        if (!lineWidth || !color) continue;
                        ctx.lineWidth = lineWidth;
                        ctx.strokeStyle = color;
                        ctx.setLineDash(optsAtIndex.borderDash);
                        ctx.lineDashOffset = optsAtIndex.borderDashOffset;
                        offset = this.getDistanceFromCenterForValue(opts.reverse ? this.min : this.max);
                        position = this.getPointPosition(i, offset);
                        ctx.beginPath();
                        ctx.moveTo(this.xCenter, this.yCenter);
                        ctx.lineTo(position.x, position.y);
                        ctx.stroke();
                    }
                    ctx.restore();
                }
            }
            drawBorder() {}
            drawLabels() {
                const ctx = this.ctx;
                const opts = this.options;
                const tickOpts = opts.ticks;
                if (!tickOpts.display) return;
                const startAngle = this.getIndexAngle(0);
                let offset, width;
                ctx.save();
                ctx.translate(this.xCenter, this.yCenter);
                ctx.rotate(startAngle);
                ctx.textAlign = "center";
                ctx.textBaseline = "middle";
                this.ticks.forEach(((tick, index) => {
                    if (index === 0 && this.min >= 0 && !opts.reverse) return;
                    const optsAtIndex = tickOpts.setContext(this.getContext(index));
                    const tickFont = toFont(optsAtIndex.font);
                    offset = this.getDistanceFromCenterForValue(this.ticks[index].value);
                    if (optsAtIndex.showLabelBackdrop) {
                        ctx.font = tickFont.string;
                        width = ctx.measureText(tick.label).width;
                        ctx.fillStyle = optsAtIndex.backdropColor;
                        const padding = toPadding(optsAtIndex.backdropPadding);
                        ctx.fillRect(-width / 2 - padding.left, -offset - tickFont.size / 2 - padding.top, width + padding.width, tickFont.size + padding.height);
                    }
                    renderText(ctx, tick.label, 0, -offset, tickFont, {
                        color: optsAtIndex.color,
                        strokeColor: optsAtIndex.textStrokeColor,
                        strokeWidth: optsAtIndex.textStrokeWidth
                    });
                }));
                ctx.restore();
            }
            drawTitle() {}
        }
        const INTERVALS = {
            millisecond: {
                common: true,
                size: 1,
                steps: 1e3
            },
            second: {
                common: true,
                size: 1e3,
                steps: 60
            },
            minute: {
                common: true,
                size: 6e4,
                steps: 60
            },
            hour: {
                common: true,
                size: 36e5,
                steps: 24
            },
            day: {
                common: true,
                size: 864e5,
                steps: 30
            },
            week: {
                common: false,
                size: 6048e5,
                steps: 4
            },
            month: {
                common: true,
                size: 2628e6,
                steps: 12
            },
            quarter: {
                common: false,
                size: 7884e6,
                steps: 4
            },
            year: {
                common: true,
                size: 3154e7
            }
        };
        const UNITS = Object.keys(INTERVALS);
        function sorter(a, b) {
            return a - b;
        }
        function parse(scale, input) {
            if (isNullOrUndef(input)) return null;
            const adapter = scale._adapter;
            const {parser, round, isoWeekday} = scale._parseOpts;
            let value = input;
            if (typeof parser === "function") value = parser(value);
            if (!isNumberFinite(value)) value = typeof parser === "string" ? adapter.parse(value, parser) : adapter.parse(value);
            if (value === null) return null;
            if (round) value = round === "week" && (isNumber(isoWeekday) || isoWeekday === true) ? adapter.startOf(value, "isoWeek", isoWeekday) : adapter.startOf(value, round);
            return +value;
        }
        function determineUnitForAutoTicks(minUnit, min, max, capacity) {
            const ilen = UNITS.length;
            for (let i = UNITS.indexOf(minUnit); i < ilen - 1; ++i) {
                const interval = INTERVALS[UNITS[i]];
                const factor = interval.steps ? interval.steps : Number.MAX_SAFE_INTEGER;
                if (interval.common && Math.ceil((max - min) / (factor * interval.size)) <= capacity) return UNITS[i];
            }
            return UNITS[ilen - 1];
        }
        function determineUnitForFormatting(scale, numTicks, minUnit, min, max) {
            for (let i = UNITS.length - 1; i >= UNITS.indexOf(minUnit); i--) {
                const unit = UNITS[i];
                if (INTERVALS[unit].common && scale._adapter.diff(max, min, unit) >= numTicks - 1) return unit;
            }
            return UNITS[minUnit ? UNITS.indexOf(minUnit) : 0];
        }
        function determineMajorUnit(unit) {
            for (let i = UNITS.indexOf(unit) + 1, ilen = UNITS.length; i < ilen; ++i) if (INTERVALS[UNITS[i]].common) return UNITS[i];
        }
        function addTick(ticks, time, timestamps) {
            if (!timestamps) ticks[time] = true; else if (timestamps.length) {
                const {lo, hi} = _lookup(timestamps, time);
                const timestamp = timestamps[lo] >= time ? timestamps[lo] : timestamps[hi];
                ticks[timestamp] = true;
            }
        }
        function setMajorTicks(scale, ticks, map, majorUnit) {
            const adapter = scale._adapter;
            const first = +adapter.startOf(ticks[0].value, majorUnit);
            const last = ticks[ticks.length - 1].value;
            let major, index;
            for (major = first; major <= last; major = +adapter.add(major, 1, majorUnit)) {
                index = map[major];
                if (index >= 0) ticks[index].major = true;
            }
            return ticks;
        }
        function ticksFromTimestamps(scale, values, majorUnit) {
            const ticks = [];
            const map = {};
            const ilen = values.length;
            let i, value;
            for (i = 0; i < ilen; ++i) {
                value = values[i];
                map[value] = i;
                ticks.push({
                    value,
                    major: false
                });
            }
            return ilen === 0 || !majorUnit ? ticks : setMajorTicks(scale, ticks, map, majorUnit);
        }
        class TimeScale extends Scale {
            static id="time";
            static defaults={
                bounds: "data",
                adapters: {},
                time: {
                    parser: false,
                    unit: false,
                    round: false,
                    isoWeekday: false,
                    minUnit: "millisecond",
                    displayFormats: {}
                },
                ticks: {
                    source: "auto",
                    callback: false,
                    major: {
                        enabled: false
                    }
                }
            };
            constructor(props) {
                super(props);
                this._cache = {
                    data: [],
                    labels: [],
                    all: []
                };
                this._unit = "day";
                this._majorUnit = void 0;
                this._offsets = {};
                this._normalized = false;
                this._parseOpts = void 0;
            }
            init(scaleOpts, opts = {}) {
                const time = scaleOpts.time || (scaleOpts.time = {});
                const adapter = this._adapter = new adapters._date(scaleOpts.adapters.date);
                adapter.init(opts);
                mergeIf(time.displayFormats, adapter.formats());
                this._parseOpts = {
                    parser: time.parser,
                    round: time.round,
                    isoWeekday: time.isoWeekday
                };
                super.init(scaleOpts);
                this._normalized = opts.normalized;
            }
            parse(raw, index) {
                if (raw === void 0) return null;
                return parse(this, raw);
            }
            beforeLayout() {
                super.beforeLayout();
                this._cache = {
                    data: [],
                    labels: [],
                    all: []
                };
            }
            determineDataLimits() {
                const options = this.options;
                const adapter = this._adapter;
                const unit = options.time.unit || "day";
                let {min, max, minDefined, maxDefined} = this.getUserBounds();
                function _applyBounds(bounds) {
                    if (!minDefined && !isNaN(bounds.min)) min = Math.min(min, bounds.min);
                    if (!maxDefined && !isNaN(bounds.max)) max = Math.max(max, bounds.max);
                }
                if (!minDefined || !maxDefined) {
                    _applyBounds(this._getLabelBounds());
                    if (options.bounds !== "ticks" || options.ticks.source !== "labels") _applyBounds(this.getMinMax(false));
                }
                min = isNumberFinite(min) && !isNaN(min) ? min : +adapter.startOf(Date.now(), unit);
                max = isNumberFinite(max) && !isNaN(max) ? max : +adapter.endOf(Date.now(), unit) + 1;
                this.min = Math.min(min, max - 1);
                this.max = Math.max(min + 1, max);
            }
            _getLabelBounds() {
                const arr = this.getLabelTimestamps();
                let min = Number.POSITIVE_INFINITY;
                let max = Number.NEGATIVE_INFINITY;
                if (arr.length) {
                    min = arr[0];
                    max = arr[arr.length - 1];
                }
                return {
                    min,
                    max
                };
            }
            buildTicks() {
                const options = this.options;
                const timeOpts = options.time;
                const tickOpts = options.ticks;
                const timestamps = tickOpts.source === "labels" ? this.getLabelTimestamps() : this._generate();
                if (options.bounds === "ticks" && timestamps.length) {
                    this.min = this._userMin || timestamps[0];
                    this.max = this._userMax || timestamps[timestamps.length - 1];
                }
                const min = this.min;
                const max = this.max;
                const ticks = _filterBetween(timestamps, min, max);
                this._unit = timeOpts.unit || (tickOpts.autoSkip ? determineUnitForAutoTicks(timeOpts.minUnit, this.min, this.max, this._getLabelCapacity(min)) : determineUnitForFormatting(this, ticks.length, timeOpts.minUnit, this.min, this.max));
                this._majorUnit = !tickOpts.major.enabled || this._unit === "year" ? void 0 : determineMajorUnit(this._unit);
                this.initOffsets(timestamps);
                if (options.reverse) ticks.reverse();
                return ticksFromTimestamps(this, ticks, this._majorUnit);
            }
            afterAutoSkip() {
                if (this.options.offsetAfterAutoskip) this.initOffsets(this.ticks.map((tick => +tick.value)));
            }
            initOffsets(timestamps = []) {
                let start = 0;
                let end = 0;
                let first, last;
                if (this.options.offset && timestamps.length) {
                    first = this.getDecimalForValue(timestamps[0]);
                    if (timestamps.length === 1) start = 1 - first; else start = (this.getDecimalForValue(timestamps[1]) - first) / 2;
                    last = this.getDecimalForValue(timestamps[timestamps.length - 1]);
                    if (timestamps.length === 1) end = last; else end = (last - this.getDecimalForValue(timestamps[timestamps.length - 2])) / 2;
                }
                const limit = timestamps.length < 3 ? .5 : .25;
                start = _limitValue(start, 0, limit);
                end = _limitValue(end, 0, limit);
                this._offsets = {
                    start,
                    end,
                    factor: 1 / (start + 1 + end)
                };
            }
            _generate() {
                const adapter = this._adapter;
                const min = this.min;
                const max = this.max;
                const options = this.options;
                const timeOpts = options.time;
                const minor = timeOpts.unit || determineUnitForAutoTicks(timeOpts.minUnit, min, max, this._getLabelCapacity(min));
                const stepSize = valueOrDefault(options.ticks.stepSize, 1);
                const weekday = minor === "week" ? timeOpts.isoWeekday : false;
                const hasWeekday = isNumber(weekday) || weekday === true;
                const ticks = {};
                let first = min;
                let time, count;
                if (hasWeekday) first = +adapter.startOf(first, "isoWeek", weekday);
                first = +adapter.startOf(first, hasWeekday ? "day" : minor);
                if (adapter.diff(max, min, minor) > 1e5 * stepSize) throw new Error(min + " and " + max + " are too far apart with stepSize of " + stepSize + " " + minor);
                const timestamps = options.ticks.source === "data" && this.getDataTimestamps();
                for (time = first, count = 0; time < max; time = +adapter.add(time, stepSize, minor), 
                count++) addTick(ticks, time, timestamps);
                if (time === max || options.bounds === "ticks" || count === 1) addTick(ticks, time, timestamps);
                return Object.keys(ticks).sort(sorter).map((x => +x));
            }
            getLabelForValue(value) {
                const adapter = this._adapter;
                const timeOpts = this.options.time;
                if (timeOpts.tooltipFormat) return adapter.format(value, timeOpts.tooltipFormat);
                return adapter.format(value, timeOpts.displayFormats.datetime);
            }
            format(value, format) {
                const options = this.options;
                const formats = options.time.displayFormats;
                const unit = this._unit;
                const fmt = format || formats[unit];
                return this._adapter.format(value, fmt);
            }
            _tickFormatFunction(time, index, ticks, format) {
                const options = this.options;
                const formatter = options.ticks.callback;
                if (formatter) return callback(formatter, [ time, index, ticks ], this);
                const formats = options.time.displayFormats;
                const unit = this._unit;
                const majorUnit = this._majorUnit;
                const minorFormat = unit && formats[unit];
                const majorFormat = majorUnit && formats[majorUnit];
                const tick = ticks[index];
                const major = majorUnit && majorFormat && tick && tick.major;
                return this._adapter.format(time, format || (major ? majorFormat : minorFormat));
            }
            generateTickLabels(ticks) {
                let i, ilen, tick;
                for (i = 0, ilen = ticks.length; i < ilen; ++i) {
                    tick = ticks[i];
                    tick.label = this._tickFormatFunction(tick.value, i, ticks);
                }
            }
            getDecimalForValue(value) {
                return value === null ? NaN : (value - this.min) / (this.max - this.min);
            }
            getPixelForValue(value) {
                const offsets = this._offsets;
                const pos = this.getDecimalForValue(value);
                return this.getPixelForDecimal((offsets.start + pos) * offsets.factor);
            }
            getValueForPixel(pixel) {
                const offsets = this._offsets;
                const pos = this.getDecimalForPixel(pixel) / offsets.factor - offsets.end;
                return this.min + pos * (this.max - this.min);
            }
            _getLabelSize(label) {
                const ticksOpts = this.options.ticks;
                const tickLabelWidth = this.ctx.measureText(label).width;
                const angle = toRadians(this.isHorizontal() ? ticksOpts.maxRotation : ticksOpts.minRotation);
                const cosRotation = Math.cos(angle);
                const sinRotation = Math.sin(angle);
                const tickFontSize = this._resolveTickFontOptions(0).size;
                return {
                    w: tickLabelWidth * cosRotation + tickFontSize * sinRotation,
                    h: tickLabelWidth * sinRotation + tickFontSize * cosRotation
                };
            }
            _getLabelCapacity(exampleTime) {
                const timeOpts = this.options.time;
                const displayFormats = timeOpts.displayFormats;
                const format = displayFormats[timeOpts.unit] || displayFormats.millisecond;
                const exampleLabel = this._tickFormatFunction(exampleTime, 0, ticksFromTimestamps(this, [ exampleTime ], this._majorUnit), format);
                const size = this._getLabelSize(exampleLabel);
                const capacity = Math.floor(this.isHorizontal() ? this.width / size.w : this.height / size.h) - 1;
                return capacity > 0 ? capacity : 1;
            }
            getDataTimestamps() {
                let timestamps = this._cache.data || [];
                let i, ilen;
                if (timestamps.length) return timestamps;
                const metas = this.getMatchingVisibleMetas();
                if (this._normalized && metas.length) return this._cache.data = metas[0].controller.getAllParsedValues(this);
                for (i = 0, ilen = metas.length; i < ilen; ++i) timestamps = timestamps.concat(metas[i].controller.getAllParsedValues(this));
                return this._cache.data = this.normalize(timestamps);
            }
            getLabelTimestamps() {
                const timestamps = this._cache.labels || [];
                let i, ilen;
                if (timestamps.length) return timestamps;
                const labels = this.getLabels();
                for (i = 0, ilen = labels.length; i < ilen; ++i) timestamps.push(parse(this, labels[i]));
                return this._cache.labels = this._normalized ? timestamps : this.normalize(timestamps);
            }
            normalize(values) {
                return _arrayUnique(values.sort(sorter));
            }
        }
        function chart_interpolate(table, val, reverse) {
            let lo = 0;
            let hi = table.length - 1;
            let prevSource, nextSource, prevTarget, nextTarget;
            if (reverse) {
                if (val >= table[lo].pos && val <= table[hi].pos) ({lo, hi} = _lookupByKey(table, "pos", val));
                ({pos: prevSource, time: prevTarget} = table[lo]);
                ({pos: nextSource, time: nextTarget} = table[hi]);
            } else {
                if (val >= table[lo].time && val <= table[hi].time) ({lo, hi} = _lookupByKey(table, "time", val));
                ({time: prevSource, pos: prevTarget} = table[lo]);
                ({time: nextSource, pos: nextTarget} = table[hi]);
            }
            const span = nextSource - prevSource;
            return span ? prevTarget + (nextTarget - prevTarget) * (val - prevSource) / span : prevTarget;
        }
        class TimeSeriesScale extends TimeScale {
            static id="timeseries";
            static defaults=TimeScale.defaults;
            constructor(props) {
                super(props);
                this._table = [];
                this._minPos = void 0;
                this._tableRange = void 0;
            }
            initOffsets() {
                const timestamps = this._getTimestampsForTable();
                const table = this._table = this.buildLookupTable(timestamps);
                this._minPos = chart_interpolate(table, this.min);
                this._tableRange = chart_interpolate(table, this.max) - this._minPos;
                super.initOffsets(timestamps);
            }
            buildLookupTable(timestamps) {
                const {min, max} = this;
                const items = [];
                const table = [];
                let i, ilen, prev, curr, next;
                for (i = 0, ilen = timestamps.length; i < ilen; ++i) {
                    curr = timestamps[i];
                    if (curr >= min && curr <= max) items.push(curr);
                }
                if (items.length < 2) return [ {
                    time: min,
                    pos: 0
                }, {
                    time: max,
                    pos: 1
                } ];
                for (i = 0, ilen = items.length; i < ilen; ++i) {
                    next = items[i + 1];
                    prev = items[i - 1];
                    curr = items[i];
                    if (Math.round((next + prev) / 2) !== curr) table.push({
                        time: curr,
                        pos: i / (ilen - 1)
                    });
                }
                return table;
            }
            _generate() {
                const min = this.min;
                const max = this.max;
                let timestamps = super.getDataTimestamps();
                if (!timestamps.includes(min) || !timestamps.length) timestamps.splice(0, 0, min);
                if (!timestamps.includes(max) || timestamps.length === 1) timestamps.push(max);
                return timestamps.sort(((a, b) => a - b));
            }
            _getTimestampsForTable() {
                let timestamps = this._cache.all || [];
                if (timestamps.length) return timestamps;
                const data = this.getDataTimestamps();
                const label = this.getLabelTimestamps();
                if (data.length && label.length) timestamps = this.normalize(data.concat(label)); else timestamps = data.length ? data : label;
                timestamps = this._cache.all = timestamps;
                return timestamps;
            }
            getDecimalForValue(value) {
                return (chart_interpolate(this._table, value) - this._minPos) / this._tableRange;
            }
            getValueForPixel(pixel) {
                const offsets = this._offsets;
                const decimal = this.getDecimalForPixel(pixel) / offsets.factor - offsets.end;
                return chart_interpolate(this._table, decimal * this._tableRange + this._minPos, true);
            }
        }
        var scales = Object.freeze({
            __proto__: null,
            CategoryScale,
            LinearScale,
            LogarithmicScale,
            RadialLinearScale,
            TimeScale,
            TimeSeriesScale
        });
        const registerables = [ controllers, chart_elements, plugins, scales ];
        /*!
 * chartjs-plugin-datalabels v2.2.0
 * https://chartjs-plugin-datalabels.netlify.app
 * (c) 2017-2022 chartjs-plugin-datalabels contributors
 * Released under the MIT license
 */
        var devicePixelRatio = function() {
            if (typeof window !== "undefined") {
                if (window.devicePixelRatio) return window.devicePixelRatio;
                var screen = window.screen;
                if (screen) return (screen.deviceXDPI || 1) / (screen.logicalXDPI || 1);
            }
            return 1;
        }();
        var utils = {
            toTextLines: function(inputs) {
                var lines = [];
                var input;
                inputs = [].concat(inputs);
                while (inputs.length) {
                    input = inputs.pop();
                    if (typeof input === "string") lines.unshift.apply(lines, input.split("\n")); else if (Array.isArray(input)) inputs.push.apply(inputs, input); else if (!isNullOrUndef(inputs)) lines.unshift("" + input);
                }
                return lines;
            },
            textSize: function(ctx, lines, font) {
                var items = [].concat(lines);
                var ilen = items.length;
                var prev = ctx.font;
                var width = 0;
                var i;
                ctx.font = font.string;
                for (i = 0; i < ilen; ++i) width = Math.max(ctx.measureText(items[i]).width, width);
                ctx.font = prev;
                return {
                    height: ilen * font.lineHeight,
                    width
                };
            },
            bound: function(min, value, max) {
                return Math.max(min, Math.min(value, max));
            },
            arrayDiff: function(a0, a1) {
                var prev = a0.slice();
                var updates = [];
                var i, j, ilen, v;
                for (i = 0, ilen = a1.length; i < ilen; ++i) {
                    v = a1[i];
                    j = prev.indexOf(v);
                    if (j === -1) updates.push([ v, 1 ]); else prev.splice(j, 1);
                }
                for (i = 0, ilen = prev.length; i < ilen; ++i) updates.push([ prev[i], -1 ]);
                return updates;
            },
            rasterize: function(v) {
                return Math.round(v * devicePixelRatio) / devicePixelRatio;
            }
        };
        function orient(point, origin) {
            var x0 = origin.x;
            var y0 = origin.y;
            if (x0 === null) return {
                x: 0,
                y: -1
            };
            if (y0 === null) return {
                x: 1,
                y: 0
            };
            var dx = point.x - x0;
            var dy = point.y - y0;
            var ln = Math.sqrt(dx * dx + dy * dy);
            return {
                x: ln ? dx / ln : 0,
                y: ln ? dy / ln : -1
            };
        }
        function aligned(x, y, vx, vy, align) {
            switch (align) {
              case "center":
                vx = vy = 0;
                break;

              case "bottom":
                vx = 0;
                vy = 1;
                break;

              case "right":
                vx = 1;
                vy = 0;
                break;

              case "left":
                vx = -1;
                vy = 0;
                break;

              case "top":
                vx = 0;
                vy = -1;
                break;

              case "start":
                vx = -vx;
                vy = -vy;
                break;

              case "end":
                break;

              default:
                align *= Math.PI / 180;
                vx = Math.cos(align);
                vy = Math.sin(align);
                break;
            }
            return {
                x,
                y,
                vx,
                vy
            };
        }
        var R_INSIDE = 0;
        var R_LEFT = 1;
        var R_RIGHT = 2;
        var R_BOTTOM = 4;
        var R_TOP = 8;
        function region(x, y, rect) {
            var res = R_INSIDE;
            if (x < rect.left) res |= R_LEFT; else if (x > rect.right) res |= R_RIGHT;
            if (y < rect.top) res |= R_TOP; else if (y > rect.bottom) res |= R_BOTTOM;
            return res;
        }
        function clipped(segment, area) {
            var x0 = segment.x0;
            var y0 = segment.y0;
            var x1 = segment.x1;
            var y1 = segment.y1;
            var r0 = region(x0, y0, area);
            var r1 = region(x1, y1, area);
            var r, x, y;
            while (true) {
                if (!(r0 | r1) || r0 & r1) break;
                r = r0 || r1;
                if (r & R_TOP) {
                    x = x0 + (x1 - x0) * (area.top - y0) / (y1 - y0);
                    y = area.top;
                } else if (r & R_BOTTOM) {
                    x = x0 + (x1 - x0) * (area.bottom - y0) / (y1 - y0);
                    y = area.bottom;
                } else if (r & R_RIGHT) {
                    y = y0 + (y1 - y0) * (area.right - x0) / (x1 - x0);
                    x = area.right;
                } else if (r & R_LEFT) {
                    y = y0 + (y1 - y0) * (area.left - x0) / (x1 - x0);
                    x = area.left;
                }
                if (r === r0) {
                    x0 = x;
                    y0 = y;
                    r0 = region(x0, y0, area);
                } else {
                    x1 = x;
                    y1 = y;
                    r1 = region(x1, y1, area);
                }
            }
            return {
                x0,
                x1,
                y0,
                y1
            };
        }
        function compute$1(range, config) {
            var anchor = config.anchor;
            var segment = range;
            var x, y;
            if (config.clamp) segment = clipped(segment, config.area);
            if (anchor === "start") {
                x = segment.x0;
                y = segment.y0;
            } else if (anchor === "end") {
                x = segment.x1;
                y = segment.y1;
            } else {
                x = (segment.x0 + segment.x1) / 2;
                y = (segment.y0 + segment.y1) / 2;
            }
            return aligned(x, y, range.vx, range.vy, config.align);
        }
        var chartjs_plugin_datalabels_esm_positioners = {
            arc: function(el, config) {
                var angle = (el.startAngle + el.endAngle) / 2;
                var vx = Math.cos(angle);
                var vy = Math.sin(angle);
                var r0 = el.innerRadius;
                var r1 = el.outerRadius;
                return compute$1({
                    x0: el.x + vx * r0,
                    y0: el.y + vy * r0,
                    x1: el.x + vx * r1,
                    y1: el.y + vy * r1,
                    vx,
                    vy
                }, config);
            },
            point: function(el, config) {
                var v = orient(el, config.origin);
                var rx = v.x * el.options.radius;
                var ry = v.y * el.options.radius;
                return compute$1({
                    x0: el.x - rx,
                    y0: el.y - ry,
                    x1: el.x + rx,
                    y1: el.y + ry,
                    vx: v.x,
                    vy: v.y
                }, config);
            },
            bar: function(el, config) {
                var v = orient(el, config.origin);
                var x = el.x;
                var y = el.y;
                var sx = 0;
                var sy = 0;
                if (el.horizontal) {
                    x = Math.min(el.x, el.base);
                    sx = Math.abs(el.base - el.x);
                } else {
                    y = Math.min(el.y, el.base);
                    sy = Math.abs(el.base - el.y);
                }
                return compute$1({
                    x0: x,
                    y0: y + sy,
                    x1: x + sx,
                    y1: y,
                    vx: v.x,
                    vy: v.y
                }, config);
            },
            fallback: function(el, config) {
                var v = orient(el, config.origin);
                return compute$1({
                    x0: el.x,
                    y0: el.y,
                    x1: el.x + (el.width || 0),
                    y1: el.y + (el.height || 0),
                    vx: v.x,
                    vy: v.y
                }, config);
            }
        };
        var rasterize = utils.rasterize;
        function chartjs_plugin_datalabels_esm_boundingRects(model) {
            var borderWidth = model.borderWidth || 0;
            var padding = model.padding;
            var th = model.size.height;
            var tw = model.size.width;
            var tx = -tw / 2;
            var ty = -th / 2;
            return {
                frame: {
                    x: tx - padding.left - borderWidth,
                    y: ty - padding.top - borderWidth,
                    w: tw + padding.width + borderWidth * 2,
                    h: th + padding.height + borderWidth * 2
                },
                text: {
                    x: tx,
                    y: ty,
                    w: tw,
                    h: th
                }
            };
        }
        function getScaleOrigin(el, context) {
            var scale = context.chart.getDatasetMeta(context.datasetIndex).vScale;
            if (!scale) return null;
            if (scale.xCenter !== void 0 && scale.yCenter !== void 0) return {
                x: scale.xCenter,
                y: scale.yCenter
            };
            var pixel = scale.getBasePixel();
            return el.horizontal ? {
                x: pixel,
                y: null
            } : {
                x: null,
                y: pixel
            };
        }
        function getPositioner(el) {
            if (el instanceof ArcElement) return chartjs_plugin_datalabels_esm_positioners.arc;
            if (el instanceof PointElement) return chartjs_plugin_datalabels_esm_positioners.point;
            if (el instanceof BarElement) return chartjs_plugin_datalabels_esm_positioners.bar;
            return chartjs_plugin_datalabels_esm_positioners.fallback;
        }
        function drawRoundedRect(ctx, x, y, w, h, radius) {
            var HALF_PI = Math.PI / 2;
            if (radius) {
                var r = Math.min(radius, h / 2, w / 2);
                var left = x + r;
                var top = y + r;
                var right = x + w - r;
                var bottom = y + h - r;
                ctx.moveTo(x, top);
                if (left < right && top < bottom) {
                    ctx.arc(left, top, r, -Math.PI, -HALF_PI);
                    ctx.arc(right, top, r, -HALF_PI, 0);
                    ctx.arc(right, bottom, r, 0, HALF_PI);
                    ctx.arc(left, bottom, r, HALF_PI, Math.PI);
                } else if (left < right) {
                    ctx.moveTo(left, y);
                    ctx.arc(right, top, r, -HALF_PI, HALF_PI);
                    ctx.arc(left, top, r, HALF_PI, Math.PI + HALF_PI);
                } else if (top < bottom) {
                    ctx.arc(left, top, r, -Math.PI, 0);
                    ctx.arc(left, bottom, r, 0, Math.PI);
                } else ctx.arc(left, top, r, -Math.PI, Math.PI);
                ctx.closePath();
                ctx.moveTo(x, y);
            } else ctx.rect(x, y, w, h);
        }
        function drawFrame(ctx, rect, model) {
            var bgColor = model.backgroundColor;
            var borderColor = model.borderColor;
            var borderWidth = model.borderWidth;
            if (!bgColor && (!borderColor || !borderWidth)) return;
            ctx.beginPath();
            drawRoundedRect(ctx, rasterize(rect.x) + borderWidth / 2, rasterize(rect.y) + borderWidth / 2, rasterize(rect.w) - borderWidth, rasterize(rect.h) - borderWidth, model.borderRadius);
            ctx.closePath();
            if (bgColor) {
                ctx.fillStyle = bgColor;
                ctx.fill();
            }
            if (borderColor && borderWidth) {
                ctx.strokeStyle = borderColor;
                ctx.lineWidth = borderWidth;
                ctx.lineJoin = "miter";
                ctx.stroke();
            }
        }
        function textGeometry(rect, align, font) {
            var h = font.lineHeight;
            var w = rect.w;
            var x = rect.x;
            var y = rect.y + h / 2;
            if (align === "center") x += w / 2; else if (align === "end" || align === "right") x += w;
            return {
                h,
                w,
                x,
                y
            };
        }
        function drawTextLine(ctx, text, cfg) {
            var shadow = ctx.shadowBlur;
            var stroked = cfg.stroked;
            var x = rasterize(cfg.x);
            var y = rasterize(cfg.y);
            var w = rasterize(cfg.w);
            if (stroked) ctx.strokeText(text, x, y, w);
            if (cfg.filled) {
                if (shadow && stroked) ctx.shadowBlur = 0;
                ctx.fillText(text, x, y, w);
                if (shadow && stroked) ctx.shadowBlur = shadow;
            }
        }
        function drawText(ctx, lines, rect, model) {
            var align = model.textAlign;
            var color = model.color;
            var filled = !!color;
            var font = model.font;
            var ilen = lines.length;
            var strokeColor = model.textStrokeColor;
            var strokeWidth = model.textStrokeWidth;
            var stroked = strokeColor && strokeWidth;
            var i;
            if (!ilen || !filled && !stroked) return;
            rect = textGeometry(rect, align, font);
            ctx.font = font.string;
            ctx.textAlign = align;
            ctx.textBaseline = "middle";
            ctx.shadowBlur = model.textShadowBlur;
            ctx.shadowColor = model.textShadowColor;
            if (filled) ctx.fillStyle = color;
            if (stroked) {
                ctx.lineJoin = "round";
                ctx.lineWidth = strokeWidth;
                ctx.strokeStyle = strokeColor;
            }
            for (i = 0, ilen = lines.length; i < ilen; ++i) drawTextLine(ctx, lines[i], {
                stroked,
                filled,
                w: rect.w,
                x: rect.x,
                y: rect.y + rect.h * i
            });
        }
        var Label = function(config, ctx, el, index) {
            var me = this;
            me._config = config;
            me._index = index;
            me._model = null;
            me._rects = null;
            me._ctx = ctx;
            me._el = el;
        };
        merge(Label.prototype, {
            _modelize: function(display, lines, config, context) {
                var me = this;
                var index = me._index;
                var font = toFont(resolve([ config.font, {} ], context, index));
                var color = resolve([ config.color, defaults.color ], context, index);
                return {
                    align: resolve([ config.align, "center" ], context, index),
                    anchor: resolve([ config.anchor, "center" ], context, index),
                    area: context.chart.chartArea,
                    backgroundColor: resolve([ config.backgroundColor, null ], context, index),
                    borderColor: resolve([ config.borderColor, null ], context, index),
                    borderRadius: resolve([ config.borderRadius, 0 ], context, index),
                    borderWidth: resolve([ config.borderWidth, 0 ], context, index),
                    clamp: resolve([ config.clamp, false ], context, index),
                    clip: resolve([ config.clip, false ], context, index),
                    color,
                    display,
                    font,
                    lines,
                    offset: resolve([ config.offset, 4 ], context, index),
                    opacity: resolve([ config.opacity, 1 ], context, index),
                    origin: getScaleOrigin(me._el, context),
                    padding: toPadding(resolve([ config.padding, 4 ], context, index)),
                    positioner: getPositioner(me._el),
                    rotation: resolve([ config.rotation, 0 ], context, index) * (Math.PI / 180),
                    size: utils.textSize(me._ctx, lines, font),
                    textAlign: resolve([ config.textAlign, "start" ], context, index),
                    textShadowBlur: resolve([ config.textShadowBlur, 0 ], context, index),
                    textShadowColor: resolve([ config.textShadowColor, color ], context, index),
                    textStrokeColor: resolve([ config.textStrokeColor, color ], context, index),
                    textStrokeWidth: resolve([ config.textStrokeWidth, 0 ], context, index)
                };
            },
            update: function(context) {
                var me = this;
                var model = null;
                var rects = null;
                var index = me._index;
                var config = me._config;
                var value, label, lines;
                var display = resolve([ config.display, true ], context, index);
                if (display) {
                    value = context.dataset.data[index];
                    label = valueOrDefault(callback(config.formatter, [ value, context ]), value);
                    lines = isNullOrUndef(label) ? [] : utils.toTextLines(label);
                    if (lines.length) {
                        model = me._modelize(display, lines, config, context);
                        rects = chartjs_plugin_datalabels_esm_boundingRects(model);
                    }
                }
                me._model = model;
                me._rects = rects;
            },
            geometry: function() {
                return this._rects ? this._rects.frame : {};
            },
            rotation: function() {
                return this._model ? this._model.rotation : 0;
            },
            visible: function() {
                return this._model && this._model.opacity;
            },
            model: function() {
                return this._model;
            },
            draw: function(chart, center) {
                var me = this;
                var ctx = chart.ctx;
                var model = me._model;
                var rects = me._rects;
                var area;
                if (!this.visible()) return;
                ctx.save();
                if (model.clip) {
                    area = model.area;
                    ctx.beginPath();
                    ctx.rect(area.left, area.top, area.right - area.left, area.bottom - area.top);
                    ctx.clip();
                }
                ctx.globalAlpha = utils.bound(0, model.opacity, 1);
                ctx.translate(rasterize(center.x), rasterize(center.y));
                ctx.rotate(model.rotation);
                drawFrame(ctx, rects.frame, model);
                drawText(ctx, model.lines, rects.text, model);
                ctx.restore();
            }
        });
        var MIN_INTEGER = Number.MIN_SAFE_INTEGER || -9007199254740991;
        var MAX_INTEGER = Number.MAX_SAFE_INTEGER || 9007199254740991;
        function rotated(point, center, angle) {
            var cos = Math.cos(angle);
            var sin = Math.sin(angle);
            var cx = center.x;
            var cy = center.y;
            return {
                x: cx + cos * (point.x - cx) - sin * (point.y - cy),
                y: cy + sin * (point.x - cx) + cos * (point.y - cy)
            };
        }
        function projected(points, axis) {
            var min = MAX_INTEGER;
            var max = MIN_INTEGER;
            var origin = axis.origin;
            var i, pt, vx, vy, dp;
            for (i = 0; i < points.length; ++i) {
                pt = points[i];
                vx = pt.x - origin.x;
                vy = pt.y - origin.y;
                dp = axis.vx * vx + axis.vy * vy;
                min = Math.min(min, dp);
                max = Math.max(max, dp);
            }
            return {
                min,
                max
            };
        }
        function toAxis(p0, p1) {
            var vx = p1.x - p0.x;
            var vy = p1.y - p0.y;
            var ln = Math.sqrt(vx * vx + vy * vy);
            return {
                vx: (p1.x - p0.x) / ln,
                vy: (p1.y - p0.y) / ln,
                origin: p0,
                ln
            };
        }
        var HitBox = function() {
            this._rotation = 0;
            this._rect = {
                x: 0,
                y: 0,
                w: 0,
                h: 0
            };
        };
        merge(HitBox.prototype, {
            center: function() {
                var r = this._rect;
                return {
                    x: r.x + r.w / 2,
                    y: r.y + r.h / 2
                };
            },
            update: function(center, rect, rotation) {
                this._rotation = rotation;
                this._rect = {
                    x: rect.x + center.x,
                    y: rect.y + center.y,
                    w: rect.w,
                    h: rect.h
                };
            },
            contains: function(point) {
                var me = this;
                var margin = 1;
                var rect = me._rect;
                point = rotated(point, me.center(), -me._rotation);
                return !(point.x < rect.x - margin || point.y < rect.y - margin || point.x > rect.x + rect.w + margin * 2 || point.y > rect.y + rect.h + margin * 2);
            },
            intersects: function(other) {
                var r0 = this._points();
                var r1 = other._points();
                var axes = [ toAxis(r0[0], r0[1]), toAxis(r0[0], r0[3]) ];
                var i, pr0, pr1;
                if (this._rotation !== other._rotation) axes.push(toAxis(r1[0], r1[1]), toAxis(r1[0], r1[3]));
                for (i = 0; i < axes.length; ++i) {
                    pr0 = projected(r0, axes[i]);
                    pr1 = projected(r1, axes[i]);
                    if (pr0.max < pr1.min || pr1.max < pr0.min) return false;
                }
                return true;
            },
            _points: function() {
                var me = this;
                var rect = me._rect;
                var angle = me._rotation;
                var center = me.center();
                return [ rotated({
                    x: rect.x,
                    y: rect.y
                }, center, angle), rotated({
                    x: rect.x + rect.w,
                    y: rect.y
                }, center, angle), rotated({
                    x: rect.x + rect.w,
                    y: rect.y + rect.h
                }, center, angle), rotated({
                    x: rect.x,
                    y: rect.y + rect.h
                }, center, angle) ];
            }
        });
        function coordinates(el, model, geometry) {
            var point = model.positioner(el, model);
            var vx = point.vx;
            var vy = point.vy;
            if (!vx && !vy) return {
                x: point.x,
                y: point.y
            };
            var w = geometry.w;
            var h = geometry.h;
            var rotation = model.rotation;
            var dx = Math.abs(w / 2 * Math.cos(rotation)) + Math.abs(h / 2 * Math.sin(rotation));
            var dy = Math.abs(w / 2 * Math.sin(rotation)) + Math.abs(h / 2 * Math.cos(rotation));
            var vs = 1 / Math.max(Math.abs(vx), Math.abs(vy));
            dx *= vx * vs;
            dy *= vy * vs;
            dx += model.offset * vx;
            dy += model.offset * vy;
            return {
                x: point.x + dx,
                y: point.y + dy
            };
        }
        function collide(labels, collider) {
            var i, j, s0, s1;
            for (i = labels.length - 1; i >= 0; --i) {
                s0 = labels[i].$layout;
                for (j = i - 1; j >= 0 && s0._visible; --j) {
                    s1 = labels[j].$layout;
                    if (s1._visible && s0._box.intersects(s1._box)) collider(s0, s1);
                }
            }
            return labels;
        }
        function compute(labels) {
            var i, ilen, label, state, geometry, center, proxy;
            for (i = 0, ilen = labels.length; i < ilen; ++i) {
                label = labels[i];
                state = label.$layout;
                if (state._visible) {
                    proxy = new Proxy(label._el, {
                        get: (el, p) => el.getProps([ p ], true)[p]
                    });
                    geometry = label.geometry();
                    center = coordinates(proxy, label.model(), geometry);
                    state._box.update(center, geometry, label.rotation());
                }
            }
            return collide(labels, (function(s0, s1) {
                var h0 = s0._hidable;
                var h1 = s1._hidable;
                if (h0 && h1 || h1) s1._visible = false; else if (h0) s0._visible = false;
            }));
        }
        var layout = {
            prepare: function(datasets) {
                var labels = [];
                var i, j, ilen, jlen, label;
                for (i = 0, ilen = datasets.length; i < ilen; ++i) for (j = 0, jlen = datasets[i].length; j < jlen; ++j) {
                    label = datasets[i][j];
                    labels.push(label);
                    label.$layout = {
                        _box: new HitBox,
                        _hidable: false,
                        _visible: true,
                        _set: i,
                        _idx: label._index
                    };
                }
                labels.sort((function(a, b) {
                    var sa = a.$layout;
                    var sb = b.$layout;
                    return sa._idx === sb._idx ? sb._set - sa._set : sb._idx - sa._idx;
                }));
                this.update(labels);
                return labels;
            },
            update: function(labels) {
                var dirty = false;
                var i, ilen, label, model, state;
                for (i = 0, ilen = labels.length; i < ilen; ++i) {
                    label = labels[i];
                    model = label.model();
                    state = label.$layout;
                    state._hidable = model && model.display === "auto";
                    state._visible = label.visible();
                    dirty |= state._hidable;
                }
                if (dirty) compute(labels);
            },
            lookup: function(labels, point) {
                var i, state;
                for (i = labels.length - 1; i >= 0; --i) {
                    state = labels[i].$layout;
                    if (state && state._visible && state._box.contains(point)) return labels[i];
                }
                return null;
            },
            draw: function(chart, labels) {
                var i, ilen, label, state, geometry, center;
                for (i = 0, ilen = labels.length; i < ilen; ++i) {
                    label = labels[i];
                    state = label.$layout;
                    if (state._visible) {
                        geometry = label.geometry();
                        center = coordinates(label._el, label.model(), geometry);
                        state._box.update(center, geometry, label.rotation());
                        label.draw(chart, center);
                    }
                }
            }
        };
        var formatter = function(value) {
            if (isNullOrUndef(value)) return null;
            var label = value;
            var keys, klen, k;
            if (helpers_segment_isObject(value)) if (!isNullOrUndef(value.label)) label = value.label; else if (!isNullOrUndef(value.r)) label = value.r; else {
                label = "";
                keys = Object.keys(value);
                for (k = 0, klen = keys.length; k < klen; ++k) label += (k !== 0 ? ", " : "") + keys[k] + ": " + value[keys[k]];
            }
            return "" + label;
        };
        var chartjs_plugin_datalabels_esm_defaults = {
            align: "center",
            anchor: "center",
            backgroundColor: null,
            borderColor: null,
            borderRadius: 0,
            borderWidth: 0,
            clamp: false,
            clip: false,
            color: void 0,
            display: true,
            font: {
                family: void 0,
                lineHeight: 1.2,
                size: void 0,
                style: void 0,
                weight: null
            },
            formatter,
            labels: void 0,
            listeners: {},
            offset: 4,
            opacity: 1,
            padding: {
                top: 4,
                right: 4,
                bottom: 4,
                left: 4
            },
            rotation: 0,
            textAlign: "start",
            textStrokeColor: void 0,
            textStrokeWidth: 0,
            textShadowBlur: 0,
            textShadowColor: void 0
        };
        var chartjs_plugin_datalabels_esm_EXPANDO_KEY = "$datalabels";
        var DEFAULT_KEY = "$default";
        function configure(dataset, options) {
            var override = dataset.datalabels;
            var listeners = {};
            var configs = [];
            var labels, keys;
            if (override === false) return null;
            if (override === true) override = {};
            options = merge({}, [ options, override ]);
            labels = options.labels || {};
            keys = Object.keys(labels);
            delete options.labels;
            if (keys.length) keys.forEach((function(key) {
                if (labels[key]) configs.push(merge({}, [ options, labels[key], {
                    _key: key
                } ]));
            })); else configs.push(options);
            listeners = configs.reduce((function(target, config) {
                each(config.listeners || {}, (function(fn, event) {
                    target[event] = target[event] || {};
                    target[event][config._key || DEFAULT_KEY] = fn;
                }));
                delete config.listeners;
                return target;
            }), {});
            return {
                labels: configs,
                listeners
            };
        }
        function dispatchEvent(chart, listeners, label, event) {
            if (!listeners) return;
            var context = label.$context;
            var groups = label.$groups;
            var callback$1;
            if (!listeners[groups._set]) return;
            callback$1 = listeners[groups._set][groups._key];
            if (!callback$1) return;
            if (callback(callback$1, [ context, event ]) === true) {
                chart[chartjs_plugin_datalabels_esm_EXPANDO_KEY]._dirty = true;
                label.update(context);
            }
        }
        function dispatchMoveEvents(chart, listeners, previous, label, event) {
            var enter, leave;
            if (!previous && !label) return;
            if (!previous) enter = true; else if (!label) leave = true; else if (previous !== label) leave = enter = true;
            if (leave) dispatchEvent(chart, listeners.leave, previous, event);
            if (enter) dispatchEvent(chart, listeners.enter, label, event);
        }
        function handleMoveEvents(chart, event) {
            var expando = chart[chartjs_plugin_datalabels_esm_EXPANDO_KEY];
            var listeners = expando._listeners;
            var previous, label;
            if (!listeners.enter && !listeners.leave) return;
            if (event.type === "mousemove") label = layout.lookup(expando._labels, event); else if (event.type !== "mouseout") return;
            previous = expando._hovered;
            expando._hovered = label;
            dispatchMoveEvents(chart, listeners, previous, label, event);
        }
        function handleClickEvents(chart, event) {
            var expando = chart[chartjs_plugin_datalabels_esm_EXPANDO_KEY];
            var handlers = expando._listeners.click;
            var label = handlers && layout.lookup(expando._labels, event);
            if (label) dispatchEvent(chart, handlers, label, event);
        }
        var chartjs_plugin_datalabels_esm_plugin = {
            id: "datalabels",
            defaults: chartjs_plugin_datalabels_esm_defaults,
            beforeInit: function(chart) {
                chart[chartjs_plugin_datalabels_esm_EXPANDO_KEY] = {
                    _actives: []
                };
            },
            beforeUpdate: function(chart) {
                var expando = chart[chartjs_plugin_datalabels_esm_EXPANDO_KEY];
                expando._listened = false;
                expando._listeners = {};
                expando._datasets = [];
                expando._labels = [];
            },
            afterDatasetUpdate: function(chart, args, options) {
                var datasetIndex = args.index;
                var expando = chart[chartjs_plugin_datalabels_esm_EXPANDO_KEY];
                var labels = expando._datasets[datasetIndex] = [];
                var visible = chart.isDatasetVisible(datasetIndex);
                var dataset = chart.data.datasets[datasetIndex];
                var config = configure(dataset, options);
                var elements = args.meta.data || [];
                var ctx = chart.ctx;
                var i, j, ilen, jlen, cfg, key, el, label;
                ctx.save();
                for (i = 0, ilen = elements.length; i < ilen; ++i) {
                    el = elements[i];
                    el[chartjs_plugin_datalabels_esm_EXPANDO_KEY] = [];
                    if (visible && el && chart.getDataVisibility(i) && !el.skip) for (j = 0, jlen = config.labels.length; j < jlen; ++j) {
                        cfg = config.labels[j];
                        key = cfg._key;
                        label = new Label(cfg, ctx, el, i);
                        label.$groups = {
                            _set: datasetIndex,
                            _key: key || DEFAULT_KEY
                        };
                        label.$context = {
                            active: false,
                            chart,
                            dataIndex: i,
                            dataset,
                            datasetIndex
                        };
                        label.update(label.$context);
                        el[chartjs_plugin_datalabels_esm_EXPANDO_KEY].push(label);
                        labels.push(label);
                    }
                }
                ctx.restore();
                merge(expando._listeners, config.listeners, {
                    merger: function(event, target, source) {
                        target[event] = target[event] || {};
                        target[event][args.index] = source[event];
                        expando._listened = true;
                    }
                });
            },
            afterUpdate: function(chart) {
                chart[chartjs_plugin_datalabels_esm_EXPANDO_KEY]._labels = layout.prepare(chart[chartjs_plugin_datalabels_esm_EXPANDO_KEY]._datasets);
            },
            afterDatasetsDraw: function(chart) {
                layout.draw(chart, chart[chartjs_plugin_datalabels_esm_EXPANDO_KEY]._labels);
            },
            beforeEvent: function(chart, args) {
                if (chart[chartjs_plugin_datalabels_esm_EXPANDO_KEY]._listened) {
                    var event = args.event;
                    switch (event.type) {
                      case "mousemove":
                      case "mouseout":
                        handleMoveEvents(chart, event);
                        break;

                      case "click":
                        handleClickEvents(chart, event);
                        break;
                    }
                }
            },
            afterEvent: function(chart) {
                var expando = chart[chartjs_plugin_datalabels_esm_EXPANDO_KEY];
                var previous = expando._actives;
                var actives = expando._actives = chart.getActiveElements();
                var updates = utils.arrayDiff(previous, actives);
                var i, ilen, j, jlen, update, label, labels;
                for (i = 0, ilen = updates.length; i < ilen; ++i) {
                    update = updates[i];
                    if (update[1]) {
                        labels = update[0].element[chartjs_plugin_datalabels_esm_EXPANDO_KEY] || [];
                        for (j = 0, jlen = labels.length; j < jlen; ++j) {
                            label = labels[j];
                            label.$context.active = update[1] === 1;
                            label.update(label.$context);
                        }
                    }
                }
                if (expando._dirty || updates.length) {
                    layout.update(expando._labels);
                    chart.render();
                }
                delete expando._dirty;
            }
        };
        const chartConfigs = {
            clickability: {
                id: "clickability",
                data: {
                    labels: [ "00.00", "01.00", "02.00", "03.00", "04.00", "05.00", "06.00", "07.00", "08.00", "09.00", "10.00", "11.00", "12.00", "13.00", "14.00", "15.00", "16.00", "17.00", "18.00", "19.00", "20.00", "21.00", "22.00", "23.00" ],
                    datasets: [ {
                        label: "Сегодня",
                        data: [ 7844, 8699, 10259, 10963, 12395, 9993, 10192, 10632, 11999, 14935, 11467, 10155, 10521, 11684, 11851, 12718, 14085, 13952, 13901, null, null, null, null, null ],
                        borderColor: "#3777FF",
                        borderWidth: 2,
                        tension: .4,
                        datalabels: {
                            display: false
                        },
                        dashedSegments: [ {
                            start: 3,
                            end: 5,
                            color: "#FF0000",
                            dash: [ 10, 5 ]
                        }, {
                            start: 8,
                            end: 10,
                            color: "#00FF00",
                            dash: [ 10, 5 ]
                        }, {
                            start: 12,
                            end: 15,
                            color: "#FFA500",
                            dash: [ 2, 2 ]
                        } ]
                    }, {
                        label: "22.12",
                        data: [ 2701, 4032, 9266, 10492, 11852, 11985, 8907, 10499, 13028, 16995, 17229, 15266, 16966, 15369, 10369, 12136, 10995, 10862, 7596, 11762, 13197, 12511, 9910, 8913 ],
                        borderColor: "#99BAFF",
                        borderWidth: 2,
                        tension: .4,
                        borderDash: [ 5, 5 ],
                        datalabels: {
                            display: false
                        },
                        dashedSegments: [ {
                            start: 2,
                            end: 4,
                            color: "#FF0000",
                            dash: [ 0, 0 ]
                        }, {
                            start: 7,
                            end: 9,
                            color: "#00FF00",
                            dash: [ 0, 0 ]
                        } ]
                    } ]
                }
            },
            installs: {
                id: "installs",
                data: {
                    labels: [ "00.00", "01.00", "02.00", "03.00", "04.00", "05.00", "06.00", "07.00", "08.00", "09.00", "10.00", "11.00", "12.00", "13.00", "14.00", "15.00", "16.00", "17.00", "18.00", "19.00", "20.00", "21.00", "22.00", "23.00" ],
                    datasets: [ {
                        label: "Сегодня",
                        data: [ 7844, 5699, 10259, 10963, 12395, 1993, 5192, 10632, 180999, 14935, 11467, 10155, 10521, 11684, 11851, 12718, 14085, 13952, 13901, null, null, null, null, null ],
                        borderColor: "#3777FF",
                        borderWidth: 2,
                        tension: .4,
                        datalabels: {
                            display: false
                        },
                        dashedSegments: []
                    }, {
                        label: "22.12",
                        data: [ 2701, 4032, 9266, 10492, 11852, 11985, 8907, 10499, 13028, 16995, 17229, 15266, 16966, 15369, 10369, 12136, 10995, 10862, 7596, 11762, 13197, 12511, 9910, 8913 ],
                        borderColor: "#99BAFF",
                        borderWidth: 2,
                        tension: .4,
                        borderDash: [ 5, 5 ],
                        datalabels: {
                            display: false
                        },
                        dashedSegments: []
                    } ]
                }
            },
            income: {
                id: "income",
                data: {
                    labels: [ "00.00", "01.00", "02.00", "03.00", "04.00", "05.00", "06.00", "07.00", "08.00", "09.00", "10.00", "11.00", "12.00", "13.00", "14.00", "15.00", "16.00", "17.00", "18.00", "19.00", "20.00", "21.00", "22.00", "23.00" ],
                    datasets: [ {
                        label: "Сегодня",
                        data: [ 0, 500, 1e3, 1400, 1800, 5e3, 4e3, 3700, 3e3, 5500, 5700, 5750, 15e3, 15500, 14500, 14200, 13700, null, null, null, null, null, null, null ],
                        borderColor: "#3777FF",
                        borderWidth: 2,
                        tension: .3,
                        datalabels: {
                            display: false
                        },
                        dashedSegments: [ {
                            start: 14,
                            end: 17,
                            color: "#DBE2EB",
                            dash: [ 0, 0 ]
                        } ]
                    }, {
                        label: "15 апреля",
                        data: [ 1232, 950, 2050, 3900, 6100, 7800, 10200, 11800, 13200, 13900, 13600, 12800, 12300, 12100, 11600, 10900, 10400, 9800, 9200, 8600, 8100, 7500, 7200, 6800 ],
                        borderColor: "#99BAFF",
                        borderWidth: 2,
                        tension: .3,
                        borderDash: [ 10, 5 ],
                        datalabels: {
                            display: false
                        }
                    } ]
                },
                appsTimeline: [ {
                    time: "0.00",
                    appId: "plant-app",
                    name: "Plant Saver - Plant Identifier",
                    icon: "../img/apps/icon.png",
                    developer: "Internet Media",
                    checkDate: "26 апреля, 0:12"
                }, {
                    time: "1.00",
                    appId: "plant-app",
                    name: "Plant Saver - Plant Identifier",
                    icon: "../img/apps/icon.png",
                    developer: "Internet Media",
                    checkDate: "26 апреля, 1:05"
                }, {
                    time: "2.00",
                    appId: "wave-app",
                    name: "Rastreamento correios - pkge",
                    icon: "../img/apps/icon-2.png",
                    developer: "Vintex Corp",
                    checkDate: "26 апреля, 2:18"
                }, {
                    time: "3.00",
                    appId: "plant-app",
                    name: "Plant Saver - Plant Identifier",
                    icon: "../img/apps/icon.png",
                    developer: "Internet Media",
                    checkDate: "26 апреля, 3:22"
                }, {
                    time: "4.00",
                    appId: "wave-app",
                    name: "Rastreamento correios - pkge",
                    icon: "../img/apps/icon-2.png",
                    developer: "Vintex Corp",
                    checkDate: "26 апреля, 4:10"
                }, {
                    time: "5.00",
                    appId: "plant-app",
                    name: "Plant Saver - Plant Identifier",
                    icon: "../img/apps/icon.png",
                    developer: "Internet Media",
                    checkDate: "26 апреля, 5:33"
                }, {
                    time: "6.00",
                    appId: "tracker-app",
                    name: "Fitness Tracker Pro",
                    icon: "../img/apps/icon-3.png",
                    developer: "HealthTech Inc",
                    checkDate: "26 апреля, 6:45"
                }, {
                    time: "7.00",
                    appId: "plant-app",
                    name: "Plant Saver - Plant Identifier",
                    icon: "../img/apps/icon.png",
                    developer: "Internet Media",
                    checkDate: "26 апреля, 7:15"
                }, {
                    time: "8.00",
                    appId: "wave-app",
                    name: "Rastreamento correios - pkge",
                    icon: "../img/apps/icon-2.png",
                    developer: "Vintex Corp",
                    checkDate: "26 апреля, 8:02"
                }, {
                    time: "9.00",
                    appId: "wave-app",
                    name: "Rastreamento correios - pkge",
                    icon: "../img/apps/icon-2.png",
                    developer: "Vintex Corp",
                    checkDate: "26 апреля, 9:35"
                }, {
                    time: "10.00",
                    appId: "wave-app",
                    name: "Rastreamento correios - pkge",
                    icon: "../img/apps/icon-2.png",
                    developer: "Vintex Corp",
                    checkDate: "26 апреля, 10:48"
                }, {
                    time: "11.00",
                    appId: "tracker-app",
                    name: "Fitness Tracker Pro",
                    icon: "../img/apps/icon-3.png",
                    developer: "HealthTech Inc",
                    checkDate: "26 апреля, 11:20"
                }, {
                    time: "12.00",
                    appId: "plant-app",
                    name: "Plant Saver - Plant Identifier",
                    icon: "../img/apps/icon.png",
                    developer: "Internet Media",
                    checkDate: "26 апреля, 12:55"
                }, {
                    time: "14.00",
                    appId: "plant-app",
                    name: "Plant Saver - Plant Identifier",
                    icon: "../img/apps/icon.png",
                    developer: "Internet Media",
                    checkDate: "26 апреля, 14:30"
                }, {
                    time: "15.00",
                    appId: "tracker-app",
                    name: "Fitness Tracker Pro",
                    icon: "../img/apps/icon-3.png",
                    developer: "HealthTech Inc",
                    checkDate: "26 апреля, 15:10"
                }, {
                    time: "17.00",
                    appId: "plant-app",
                    name: "Plant Saver - Plant Identifier",
                    icon: "../img/apps/icon.png",
                    developer: "Internet Media",
                    checkDate: "26 апреля, 17:42"
                }, {
                    time: "18.00",
                    appId: "wave-app",
                    name: "Rastreamento correios - pkge",
                    icon: "../img/apps/icon-2.png",
                    developer: "Vintex Corp",
                    checkDate: "26 апреля, 18:05"
                }, {
                    time: "19.00",
                    appId: "plant-app",
                    name: "Plant Saver - Plant Identifier",
                    icon: "../img/apps/icon.png",
                    developer: "Internet Media",
                    checkDate: "26 апреля, 19:28"
                }, {
                    time: "20.00",
                    appId: "tracker-app",
                    name: "Fitness Tracker Pro",
                    icon: "../img/apps/icon-3.png",
                    developer: "HealthTech Inc",
                    checkDate: "26 апреля, 20:15"
                }, {
                    time: "22.00",
                    appId: "plant-app",
                    name: "Plant Saver - Plant Identifier",
                    icon: "../img/apps/icon.png",
                    developer: "Internet Media",
                    checkDate: "26 апреля, 22:50"
                }, {
                    time: "23.00",
                    appId: "plant-app",
                    name: "Plant Saver - Plant Identifier",
                    icon: "../img/apps/icon.png",
                    developer: "Internet Media",
                    checkDate: "26 апреля, 23:37"
                } ],
                changes: {
                    annotations: [ {
                        type: "point",
                        time: "12.00",
                        oldValue: 9.74,
                        newValue: 7.35,
                        change: {
                            type: "bid_price",
                            percentage: 10,
                            direction: "decrease"
                        },
                        user: {
                            name: "Dianne Russell",
                            email: "jackson.graham@gmail.com",
                            avatar: "https://picsum.photos/200/300"
                        },
                        style: {
                            backgroundColor: "#3777FF",
                            borderColor: "#FFFFFF",
                            borderWidth: 2,
                            radius: 6
                        }
                    }, {
                        type: "point",
                        time: "8.00",
                        oldValue: 14.74,
                        newValue: 7.35,
                        change: {
                            type: "budget",
                            percentage: 15,
                            direction: "decrease"
                        },
                        user: {
                            name: "Dianne Russell",
                            email: "jackson.graham@gmail.com",
                            avatar: "https://picsum.photos/200/300"
                        },
                        style: {
                            backgroundColor: "#3777FF",
                            borderColor: "#FFFFFF",
                            borderWidth: 2,
                            radius: 6
                        }
                    }, {
                        type: "point",
                        time: "3.24",
                        oldValue: 6.74,
                        newValue: 13.35,
                        change: {
                            type: "budget",
                            percentage: 15,
                            direction: "decrease"
                        },
                        user: {
                            name: "Dianne Russell",
                            email: "jackson.graham@gmail.com",
                            avatar: "https://picsum.photos/200/300"
                        },
                        style: {
                            backgroundColor: "#3777FF",
                            borderColor: "#FFFFFF",
                            borderWidth: 2,
                            radius: 6
                        }
                    }, {
                        type: "point",
                        time: "13.40",
                        oldValue: 1e3,
                        newValue: 1500,
                        change: {
                            type: "budget",
                            percentage: 50,
                            direction: "increase"
                        },
                        user: {
                            name: "Dianne Russell",
                            email: "jackson.graham@gmail.com",
                            avatar: null
                        }
                    }, {
                        type: "point",
                        time: "18.00",
                        oldValue: 1500,
                        newValue: 100,
                        change: {
                            type: "budget",
                            percentage: 50,
                            direction: "increase"
                        },
                        user: {
                            name: "Dianne Russell",
                            email: "jackson.graham@gmail.com",
                            avatar: null
                        }
                    } ]
                }
            },
            costs: {
                id: "costs",
                data: {
                    labels: [ "00.00", "01.00", "02.00", "03.00", "04.00", "05.00", "06.00", "07.00", "08.00", "09.00", "10.00", "11.00", "12.00", "13.00", "14.00", "15.00", "16.00", "17.00", "18.00", "19.00", "20.00", "21.00", "22.00", "23.00" ],
                    datasets: [ {
                        label: "Расходы текущего дня",
                        data: [ 5200, 6100, 8200, 9100, 11500, 1500, 15500, 17500, 15800, 21500, 23500, 25500, 27500, 29500, 31500, 33500, 35500, 37500, 30500, 12500, 5200, null, null, null ],
                        borderColor: "#FF5733",
                        borderWidth: 2,
                        tension: .3,
                        datalabels: {
                            display: false
                        }
                    }, {
                        label: "Расходы прошлого дня",
                        data: [ 3200, 4200, 7200, 8200, 10200, 8200, 1200, 16200, 1200, 5e3, 10500, 15150, 26500, 28500, 30500, 32500, 34500, 36500, 38500, 1300, 4227, null, null, null ],
                        borderColor: "#33C1FF",
                        borderWidth: 2,
                        tension: .3,
                        borderDash: [ 10, 5 ],
                        datalabels: {
                            display: false
                        }
                    } ]
                }
            },
            installs2: {
                id: "installs2",
                data: {
                    labels: [ "00.00", "01.00", "02.00", "03.00", "04.00", "05.00", "06.00", "07.00", "08.00", "09.00", "10.00", "11.00", "12.00", "13.00", "14.00", "15.00", "16.00", "17.00", "18.00", "19.00", "20.00", "21.00", "22.00", "23.00" ],
                    datasets: [ {
                        label: "Сегодня",
                        data: [ 7844, 5699, 10259, 10963, 12395, 1993, 5192, 10632, 18999, 14935, 11467, 10155, 10521, 11684, 11851, 12718, 14085, 13952, 13901, null, null, null, null, null ],
                        borderColor: "#3777FF",
                        borderWidth: 2,
                        tension: .4,
                        datalabels: {
                            display: false
                        },
                        dashedSegments: []
                    }, {
                        label: "22.12",
                        data: [ 2701, 4032, 9266, 10492, 11852, 11985, 8907, 10499, 13028, 16995, 17229, 15266, 16966, 15369, 10369, 12136, 10995, 10862, 7596, 11762, 13197, 12511, 9910, 8913 ],
                        borderColor: "#99BAFF",
                        borderWidth: 2,
                        tension: .4,
                        borderDash: [ 5, 5 ],
                        datalabels: {
                            display: false
                        },
                        dashedSegments: []
                    } ]
                }
            },
            income2: {
                id: "income2",
                data: {
                    labels: [ "00.00", "01.00", "02.00", "03.00", "04.00", "05.00", "06.00", "07.00", "08.00", "09.00", "10.00", "11.00", "12.00", "13.00", "14.00", "15.00", "16.00", "17.00", "18.00", "19.00", "20.00", "21.00", "22.00", "23.00" ],
                    datasets: [ {
                        label: "Сегодня",
                        data: [ 7844, 5699, 6259, 7963, 8395, 1993, 5192, 10632, 18999, 14935, 11467, 10155, 10521, 11684, 11851, 12718, 14085, 13952, 13901, null, null, null, null, null ],
                        borderColor: "#3777FF",
                        borderWidth: 2,
                        tension: .4,
                        datalabels: {
                            display: false
                        },
                        dashedSegments: []
                    }, {
                        label: "22.12",
                        data: [ 2701, 4032, 9266, 5492, 1500, 11985, 8907, 10499, 13028, 16995, 17229, 15266, 16966, 15369, 10369, 12136, 10995, 10862, 7596, 11762, 13197, 12511, 9910, 8913 ],
                        borderColor: "#99BAFF",
                        borderWidth: 2,
                        tension: .4,
                        borderDash: [ 5, 5 ],
                        datalabels: {
                            display: false
                        },
                        dashedSegments: []
                    } ]
                }
            },
            incomeLast7: {
                id: "incomeLast7",
                data: {
                    labels: [ "00.00", "01.00", "02.00", "03.00", "04.00", "05.00", "06.00", "07.00", "08.00", "09.00", "10.00", "11.00", "12.00", "13.00", "14.00", "15.00", "16.00", "17.00", "18.00", "19.00", "20.00", "21.00", "22.00", "23.00" ],
                    datasets: [ {
                        label: "Сегодня",
                        data: [ 7844, 5699, 6259, 7963, 8395, 1993, 5192, 10632, 18999, 14935, 11467, 10155, 10521, 11684, 11851, 12718, 14085, 13952, 13901, 12701, 14032, 19266, 15492, 15500 ],
                        borderColor: "#3777FF",
                        borderWidth: 2,
                        tension: .4,
                        datalabels: {
                            display: false
                        },
                        dashedSegments: []
                    }, {
                        label: "22.12",
                        data: [ 12701, 14032, 19266, 15492, 1500, 11985, 8907, 10499, 13028, 16995, 17229, 15266, 16966, 15369, 10369, 12136, 10995, 10862, 7596, 11762, 13197, 12511, 9910, 8913 ],
                        borderColor: "#99BAFF",
                        borderWidth: 2,
                        tension: .4,
                        borderDash: [ 5, 5 ],
                        datalabels: {
                            display: false
                        },
                        dashedSegments: []
                    } ]
                }
            },
            incomeLast28: {
                id: "incomeLast28",
                data: {
                    labels: [ "00.00", "01.00", "02.00", "03.00", "04.00", "05.00", "06.00", "07.00", "08.00", "09.00", "10.00", "11.00", "12.00", "13.00", "14.00", "15.00", "16.00", "17.00", "18.00", "19.00", "20.00", "21.00", "22.00", "23.00" ],
                    datasets: [ {
                        label: "Сегодня",
                        data: [ 7844, 5699, 6259, 7963, 8395, 1993, 5192, 10632, 18999, 14935, 11467, 10155, 10521, 11684, 11851, 12718, 14085, 13952, 13901, 12701, 14032, 19266, 15492, 15500 ],
                        borderColor: "#3777FF",
                        borderWidth: 2,
                        tension: .4,
                        datalabels: {
                            display: false
                        },
                        dashedSegments: []
                    }, {
                        label: "22.12",
                        data: [ 12701, 14032, 19266, 15492, 1500, 5985, 8907, 10499, 5028, 6995, 7229, 15266, 16966, 15369, 10369, 12136, 10995, 10862, 7596, 11762, 13197, 12511, 9910, 8913 ],
                        borderColor: "#99BAFF",
                        borderWidth: 2,
                        tension: .4,
                        borderDash: [ 5, 5 ],
                        datalabels: {
                            display: false
                        },
                        dashedSegments: []
                    } ]
                }
            }
        };
        function extractDominantColor(img) {
            try {
                const canvas = document.createElement("canvas");
                const size = Math.min(img.naturalWidth || img.width, img.naturalHeight || img.height, 64);
                if (size === 0) return {
                    r: 154,
                    g: 164,
                    b: 178
                };
                canvas.width = size;
                canvas.height = size;
                const ctx = canvas.getContext("2d");
                ctx.drawImage(img, 0, 0, size, size);
                const imageData = ctx.getImageData(0, 0, size, size);
                const data = imageData.data;
                let r = 0, g = 0, b = 0, count = 0;
                const margin = Math.floor(size * .15);
                for (let y = margin; y < size - margin; y++) for (let x = margin; x < size - margin; x++) {
                    const i = (y * size + x) * 4;
                    if (data[i + 3] < 128) continue;
                    r += data[i];
                    g += data[i + 1];
                    b += data[i + 2];
                    count++;
                }
                if (count === 0) return {
                    r: 154,
                    g: 164,
                    b: 178
                };
                return {
                    r: Math.round(r / count),
                    g: Math.round(g / count),
                    b: Math.round(b / count)
                };
            } catch (e) {
                return {
                    r: 154,
                    g: 164,
                    b: 178
                };
            }
        }
        function parseTimeValue(timeStr) {
            const [hours, minutes] = timeStr.split(".").map(Number);
            return hours + (minutes || 0) / 60;
        }
        function groupTimelineEntries(entries) {
            if (!entries || entries.length === 0) return [];
            const sorted = [ ...entries ].sort(((a, b) => parseTimeValue(a.time) - parseTimeValue(b.time)));
            const groups = [];
            let currentGroup = [ sorted[0] ];
            for (let i = 1; i < sorted.length; i++) {
                const prev = sorted[i - 1];
                const curr = sorted[i];
                const timeDiff = parseTimeValue(curr.time) - parseTimeValue(prev.time);
                if (curr.appId === prev.appId && timeDiff <= 1.5) currentGroup.push(curr); else {
                    groups.push(currentGroup);
                    currentGroup = [ curr ];
                }
            }
            groups.push(currentGroup);
            return groups;
        }
        function getPixelForTime(chart, timeStr) {
            const xScale = chart.scales.x;
            const labels = chart.data.labels;
            const [hours, minutes] = timeStr.split(".").map(Number);
            const currentHourIndex = labels.findIndex((label => {
                const [labelHours] = label.split(".").map(Number);
                return labelHours === hours;
            }));
            if (currentHourIndex === -1) return null;
            const currentPixel = xScale.getPixelForValue(currentHourIndex);
            const nextPixel = currentHourIndex + 1 < labels.length ? xScale.getPixelForValue(currentHourIndex + 1) : currentPixel + (currentPixel - xScale.getPixelForValue(Math.max(0, currentHourIndex - 1)));
            const fraction = (minutes || 0) / 60;
            return currentPixel + (nextPixel - currentPixel) * fraction;
        }
        function loadTimelineImages(timelineData) {
            const uniqueApps = {};
            timelineData.forEach((entry => {
                if (!uniqueApps[entry.appId]) uniqueApps[entry.appId] = entry;
            }));
            const images = {};
            const colors = {};
            const promises = [];
            Object.entries(uniqueApps).forEach((([appId, entry]) => {
                const promise = new Promise((resolve => {
                    const img = new Image;
                    img.crossOrigin = "anonymous";
                    img.onload = () => {
                        images[appId] = img;
                        colors[appId] = extractDominantColor(img);
                        resolve();
                    };
                    img.onerror = () => {
                        images[appId] = null;
                        colors[appId] = {
                            r: 154,
                            g: 164,
                            b: 178
                        };
                        resolve();
                    };
                    img.src = entry.icon;
                }));
                promises.push(promise);
            }));
            return Promise.all(promises).then((() => ({
                images,
                colors
            })));
        }
        const TIMELINE_TOP_PADDING = 78;
        const TIMELINE_ROW_HEIGHT = 14;
        const TOTAL_TIMELINE_HEIGHT = TIMELINE_ROW_HEIGHT;
        const ICON_SIZE = 24;
        const ICON_SIZE_SINGLE = 22;
        const ICON_BORDER_RADIUS = 6;
        const DOT_RADIUS = 4;
        const LINE_WIDTH = 3;
        const DASH_LINE_WIDTH = 2;
        const DASH_COLOR = "#CDD5DF";
        class BaseChartManager {
            constructor() {
                this.charts = {};
            }
            _createChartWrapper(canvasId, type, isSimple = false) {
                const canvas = document.getElementById(canvasId);
                if (!canvas) return null;
                let wrapper = canvas.closest(".chart-wrapper");
                if (!wrapper) {
                    wrapper = document.createElement("div");
                    wrapper.className = "chart-wrapper relative";
                    if (!isSimple) wrapper.style.cssText = `\n          min-height:375px;\n          width: 100%;\n          overflow: hidden;\n        `; else wrapper.style.cssText = `\n          width: 100%;\n          overflow: hidden;\n        `;
                    canvas.parentNode.insertBefore(wrapper, canvas);
                    const overflow = document.createElement("div");
                    overflow.className = "chart-overflow";
                    if (!isSimple) overflow.style.cssText = `\n          position: relative;\n          width: 100%;\n          height: 100%;\n          min-height: 375px;\n          overflow-x: auto;\n          overflow-y: hidden;\n          -webkit-overflow-scrolling: touch;\n        `; else overflow.style.cssText = `\n          position: relative;\n          width: 100%;\n          height: 100%;\n          overflow: hidden;\n        `;
                    const chartContainer = document.createElement("div");
                    chartContainer.className = "chart-container";
                    chartContainer.style.cssText = `\n        position: relative;\n        ${!isSimple && window.innerWidth < 768 ? "min-width: 800px;" : "width: 100%;"}\n        height: 100%;\n      `;
                    wrapper.appendChild(overflow);
                    overflow.appendChild(chartContainer);
                    chartContainer.appendChild(canvas);
                }
                return wrapper;
            }
            applyDashedSegments(data, dashedSegments) {
                (data.datasets || []).forEach((dataset => {
                    Object.assign(dataset, {
                        pointBackgroundColor: dataset.borderColor,
                        pointBorderColor: "#FFFFFF",
                        pointBorderWidth: 2,
                        pointRadius: 0,
                        pointHoverRadius: 8,
                        pointHoverBorderWidth: 2
                    });
                    if (dataset.dashedSegments) dataset.segment = {
                        borderColor: ctx => this._getSegmentValue(ctx, dataset, "color", dataset.borderColor),
                        borderDash: ctx => this._getSegmentValue(ctx, dataset, "dash", dataset.borderDash || [])
                    };
                }));
            }
            _getSegmentValue(ctx, dataset, key, defaultValue) {
                const {p0DataIndex, p1DataIndex} = ctx;
                for (const seg of dataset.dashedSegments) if (p0DataIndex >= seg.start && p1DataIndex <= seg.end) return seg[key];
                return defaultValue;
            }
            loadDataFromJsonFile(filePath, callback) {
                fetch(filePath).then((response => {
                    if (!response.ok) throw new Error(`Не удалось загрузить JSON файл: ${response.statusText}`);
                    return response.json();
                })).then((data => callback(data))).catch((error => console.error("Ошибка при загрузке JSON файла:", error)));
            }
            destroyAllCharts() {
                Object.values(this.charts).forEach((chart => chart.destroy()));
                this.charts = {};
            }
            _parseJsonConfig(jsonConfig, data, options, dashedSegments) {
                try {
                    const parsed = JSON.parse(jsonConfig);
                    return {
                        data: parsed.data || data,
                        options: {
                            ...options,
                            ...parsed.options
                        },
                        dashedSegments: parsed.dashedSegments || dashedSegments
                    };
                } catch (error) {
                    console.error("Неверный JSON конфиг:", error);
                    return null;
                }
            }
            _resetTooltipState(tooltip, isVisible) {
                if (!tooltip) return;
                if (isVisible) {
                    tooltip.style.opacity = "1";
                    tooltip.style.visibility = "visible";
                    tooltip.style.display = "block";
                    tooltip.classList.remove("opacity-0");
                    tooltip.classList.add("opacity-100");
                    tooltip.style.pointerEvents = "none";
                    tooltip.style.userSelect = "none";
                    tooltip.style.webkitUserSelect = "none";
                } else {
                    tooltip.style.opacity = "0";
                    tooltip.style.visibility = "hidden";
                    tooltip.style.display = "none";
                    tooltip.classList.add("opacity-0");
                    tooltip.classList.remove("opacity-100");
                    tooltip.style.pointerEvents = "none";
                    tooltip.style.userSelect = "none";
                    tooltip.style.webkitUserSelect = "none";
                }
            }
        }
        class ChartManager extends BaseChartManager {
            createChart({id, canvasId, type = "line", data = {}, options = {}, jsonConfig = null, dashedSegments = []}) {
                if (this.charts[id]) {
                    console.warn(`Chart with ID "${id}" уже существует.`);
                    return this.charts[id];
                }
                const canvas = document.getElementById(canvasId);
                if (!canvas) {
                    console.error(`Canvas с ID "${canvasId}" не найден.`);
                    return null;
                }
                const chartWrapper = this._createChartWrapper(canvasId, type, false);
                if (!chartWrapper) return null;
                const chartOverflow = chartWrapper.querySelector(".chart-overflow");
                if (jsonConfig) {
                    const parsed = this._parseJsonConfig(jsonConfig, data, options, dashedSegments);
                    if (!parsed) return null;
                    ({data, options, dashedSegments} = parsed);
                }
                const ctx = canvas.getContext("2d");
                this.applyDashedSegments(data, dashedSegments);
                const chartConfig = this.getChartConfig(type, data, options);
                const tooltipEl = this._createTooltipElement(chartOverflow);
                chartConfig.options.plugins.tooltip = {
                    enabled: false,
                    external: context => this._renderCustomTooltip(context, tooltipEl, chartWrapper)
                };
                chartConfig.options.plugins.verticalLine = {
                    color: "rgba(0, 0, 0, 0.1)",
                    dash: [ 5, 5 ],
                    lineWidth: 1
                };
                const config = chartConfigs[id];
                if (config?.appsTimeline?.length) {
                    chartConfig.options.plugins.appsTimelinePlugin = {
                        data: config.appsTimeline
                    };
                    chartConfig.options.layout = chartConfig.options.layout || {};
                    const existingPadding = chartConfig.options.layout.padding || 0;
                    const timelineSpace = TOTAL_TIMELINE_HEIGHT + TIMELINE_TOP_PADDING;
                    if (typeof existingPadding === "number") chartConfig.options.layout.padding = {
                        top: existingPadding,
                        right: existingPadding,
                        bottom: existingPadding + timelineSpace,
                        left: existingPadding
                    }; else chartConfig.options.layout.padding = {
                        ...existingPadding,
                        bottom: (existingPadding.bottom || 0) + timelineSpace
                    };
                }
                const chart = new chart_Chart(ctx, chartConfig);
                this._createCustomLegend(chart, chartWrapper);
                if (config?.changes?.annotations) this._addChangeMarkers(chart, chartWrapper, config.changes.annotations);
                if (config?.appsTimeline?.length) {
                    const timelineTooltip = document.createElement("div");
                    timelineTooltip.className = "apps-timeline-tooltip absolute bg-white shadow-md rounded-md";
                    timelineTooltip.style.cssText = `\n        position: absolute;\n        display: none;\n        z-index: 1010;\n        pointer-events: none;\n        user-select: none;\n        -webkit-user-select: none;\n        min-width: 200px;\n      `;
                    chartOverflow.appendChild(timelineTooltip);
                    chart._appsTimeline = {
                        images: {},
                        colors: {},
                        groups: groupTimelineEntries(config.appsTimeline),
                        imagesLoaded: false,
                        hoveredApp: null,
                        hitRegions: [],
                        tooltipEl: timelineTooltip
                    };
                    loadTimelineImages(config.appsTimeline).then((({images, colors}) => {
                        chart._appsTimeline.images = images;
                        chart._appsTimeline.colors = colors;
                        chart._appsTimeline.imagesLoaded = true;
                        this._addTimelinePercentages(chartWrapper, config.appsTimeline, images);
                        chart.draw();
                    }));
                }
                this.charts[id] = chart;
                return chart;
            }
            getChartConfig(type, data, options) {
                return {
                    type,
                    data: data || {
                        labels: [],
                        datasets: []
                    },
                    options: {
                        interaction: {
                            mode: "index",
                            intersect: false
                        },
                        plugins: {
                            legend: {
                                display: false
                            },
                            tooltip: {
                                enabled: false
                            },
                            verticalLinePlugin: {
                                color: "rgba(0, 0, 0, 0.1)",
                                dash: [ 5, 5 ],
                                lineWidth: 1
                            }
                        },
                        scales: {
                            x: {
                                grid: {
                                    display: false,
                                    drawBorder: false,
                                    color: "#F5F7FC"
                                },
                                ticks: {
                                    color: "#9aa4b2",
                                    padding: 10,
                                    font: {
                                        size: 14,
                                        family: "Inter, sans-serif",
                                        weight: "500"
                                    }
                                }
                            },
                            y: {
                                grid: {
                                    display: options.showGridY !== false,
                                    drawBorder: false,
                                    color: "#F5F7FC"
                                },
                                ticks: {
                                    color: "#9aa4b2",
                                    padding: 5,
                                    callback: function(value) {
                                        if (value >= 1e6) return "$" + (value / 1e6).toFixed(1) + "M";
                                        if (value >= 1e5) return "$" + (value / 1e3).toFixed(1) + "K";
                                        return "$" + value;
                                    },
                                    font: {
                                        size: 14,
                                        family: "Inter, sans-serif",
                                        weight: "500"
                                    }
                                },
                                beginAtZero: true,
                                suggestedMin: 0
                            }
                        }
                    },
                    plugins: [ this._createVerticalLinePlugin(), this._createAppsTimelinePlugin() ]
                };
            }
            _createTooltipElement(wrapper) {
                let tooltipEl = wrapper.querySelector(".custom-tooltip");
                if (!tooltipEl) {
                    tooltipEl = document.createElement("div");
                    tooltipEl.className = "custom-tooltip absolute bg-white shadow-md rounded-md opacity-0 transition-opacity duration-300 z-[1005] whitespace-nowrap";
                    tooltipEl.style.cssText = `\n        pointer-events: none;\n        user-select: none;\n        -webkit-user-select: none;\n      `;
                    wrapper.appendChild(tooltipEl);
                }
                return tooltipEl;
            }
            _renderCustomTooltip(context, tooltipEl, wrapper) {
                const {chart, tooltip} = context;
                if (!this._shouldShowTooltip(tooltip)) {
                    this._resetTooltipState(tooltipEl, false);
                    return;
                }
                this._resetTooltipState(tooltipEl, true);
                const tooltipData = this._extractTooltipData(context);
                const content = this._generateTooltipContent(tooltipData, chart);
                this._updateTooltipPosition(tooltipEl, content, chart, tooltip, wrapper);
            }
            _shouldShowTooltip(tooltip) {
                return tooltip.opacity !== 0 && tooltip.dataPoints && tooltip.dataPoints.length > 0;
            }
            _hideTooltip(tooltipEl) {
                tooltipEl.classList.add("opacity-0");
                tooltipEl.style.visibility = "hidden";
            }
            _extractTooltipData(context) {
                const {dataset, dataIndex, raw} = context.tooltip.dataPoints[0];
                const previousDataset = context.chart.data.datasets[1];
                return {
                    currentDataset: dataset,
                    currentIndex: dataIndex,
                    currentValue: raw,
                    previousDataset,
                    previousValue: previousDataset ? previousDataset.data[dataIndex] : null,
                    label: context.chart.data.labels[dataIndex]
                };
            }
            _generateTooltipContent(data, chart) {
                const {currentDataset, currentValue, previousDataset, previousValue, label} = data;
                const isCurrentVisible = !chart.getDatasetMeta(0).hidden;
                const isPreviousVisible = chart.data.datasets[1] && !chart.getDatasetMeta(1).hidden;
                const formatValue = value => {
                    if (value >= 1e6) return `$${(value / 1e6).toFixed(1)}M`;
                    if (value >= 1e5) return `$${(value / 1e3).toFixed(1)}K`;
                    return `$${value.toLocaleString()}`;
                };
                const header = `\n      <div class="p-2 border-b bg-gray-200 border-gray-200">\n        <span class="text-sm text-gray-700">${label}</span>\n      </div>\n    `;
                let body = "";
                if (isCurrentVisible && isPreviousVisible && currentValue === previousValue && currentValue !== null) body = `\n            <div class="p-2 flex items-center space-x-2">\n                <span class="inline-block w-2 h-2 rounded-full" style="background-color: ${currentDataset.borderColor};"></span>\n                <span class="text-gray-600 text-base">${currentDataset.label}:</span>\n                <span class="font-semibold text-gray-900 text-base">${formatValue(currentValue)}</span>\n            </div>\n        `; else {
                    if (isCurrentVisible && currentValue !== null) {
                        const difference = isPreviousVisible && previousValue !== null ? currentValue - previousValue : null;
                        const pctChange = difference !== null && previousValue ? (difference / previousValue * 100).toFixed(1) : null;
                        const arrow = difference > 0 ? "↑" : "↓";
                        const arrowColor = difference > 0 ? "text-green-500" : "text-red-500";
                        body += `\n                <div class="p-2 flex items-center space-x-2">\n                    <span class="inline-block w-2 h-2 rounded-full" style="background-color: ${currentDataset.borderColor};"></span>\n                    <span class="text-gray-600 text-base">${currentDataset.label}:</span>\n                    <span class="font-semibold text-gray-900 text-base">${formatValue(currentValue)}</span>\n                    ${difference !== null && difference !== 0 ? `<span class="${arrowColor} font-bold ml-2">${arrow} ${formatValue(Math.abs(difference))} (${pctChange}%)</span>` : ""}\n                </div>\n            `;
                    }
                    if (isPreviousVisible && previousValue !== null) body += `\n                <div class="p-2 pt-0 flex items-center space-x-2">\n                    <span class="inline-block w-2 h-2 rounded-full" style="background-color: ${previousDataset.borderColor};"></span>\n                    <span class="text-gray-600 text-base">${previousDataset.label}:</span>\n                    <span class="font-semibold text-gray-900 text-base">${formatValue(previousValue)}</span>\n                </div>\n            `;
                }
                return `<div class="bg-white shadow-md rounded-md">${header}${body}</div>`;
            }
            _updateTooltipPosition(tooltipEl, content, chart, tooltip, wrapper) {
                tooltipEl.innerHTML = content;
                tooltipEl.style.opacity = 1;
                const overflow = wrapper.querySelector(".chart-overflow");
                const chartRect = chart.canvas.getBoundingClientRect();
                overflow.getBoundingClientRect();
                const position = {
                    x: tooltip.caretX,
                    y: tooltip.caretY
                };
                const tooltipWidth = tooltipEl.offsetWidth;
                const tooltipHeight = tooltipEl.offsetHeight;
                const padding = 12;
                const spaceRight = chartRect.width - position.x - padding;
                const spaceLeft = position.x - padding;
                let left = position.x + padding;
                if (spaceRight < tooltipWidth && spaceLeft > tooltipWidth) left = position.x - tooltipWidth - padding;
                let top = position.y - tooltipHeight / 2;
                const minTop = 8;
                if (top < minTop) top = minTop;
                const maxTop = chartRect.height - tooltipHeight - 8;
                if (top > maxTop) top = maxTop;
                const minLeft = 8;
                const maxLeft = chartRect.width - tooltipWidth - 8;
                left = Math.max(minLeft, Math.min(left, maxLeft));
                tooltipEl.style.left = `${left}px`;
                tooltipEl.style.top = `${top}px`;
            }
            _createVerticalLinePlugin() {
                return {
                    id: "verticalLinePlugin",
                    afterDraw: (chart, args, options) => {
                        if (chart._hoverPosition != null && chart.chartArea) {
                            const ctx = chart.ctx;
                            ctx.save();
                            ctx.beginPath();
                            ctx.setLineDash(options.dash || [ 5, 5 ]);
                            ctx.lineWidth = options.lineWidth || 1;
                            ctx.strokeStyle = options.color || "rgba(0, 0, 0, 0.1)";
                            ctx.moveTo(chart._hoverPosition, chart.chartArea.top);
                            ctx.lineTo(chart._hoverPosition, chart.chartArea.bottom);
                            ctx.stroke();
                            ctx.restore();
                        }
                    },
                    afterEvent: (chart, args) => {
                        const {event} = args;
                        const chartArea = chart.chartArea;
                        if (!chartArea) return;
                        if (!event.x) {
                            chart._hoverPosition = null;
                            chart.draw();
                            return;
                        }
                        const xAxis = chart.scales.x;
                        if (event.x < chartArea.left || event.x > chartArea.right || event.y < chartArea.top || event.y > chartArea.bottom) {
                            chart._hoverPosition = null;
                            chart.draw();
                            return;
                        }
                        const points = xAxis.ticks;
                        let closestPoint = points[0];
                        let minDistance = Math.abs(xAxis.getPixelForTick(0) - event.x);
                        points.forEach(((point, index) => {
                            const pixelPosition = xAxis.getPixelForTick(index);
                            const distance = Math.abs(pixelPosition - event.x);
                            if (distance < minDistance) {
                                minDistance = distance;
                                closestPoint = point;
                                chart._hoverPosition = pixelPosition;
                            }
                        }));
                        chart.draw();
                    }
                };
            }
            _createAppsTimelinePlugin() {
                return {
                    id: "appsTimelinePlugin",
                    afterDraw(chart) {
                        const state = chart._appsTimeline;
                        if (!state || !state.imagesLoaded || !state.groups.length) return;
                        if (!chart.chartArea || !chart.scales?.x) return;
                        const ctx = chart.ctx;
                        const chartArea = chart.chartArea;
                        const centerY = chartArea.bottom + TIMELINE_TOP_PADDING;
                        const hoverBorder = 3;
                        const hoveredRegion = state.hoveredApp;
                        state.hitRegions = [];
                        ctx.save();
                        ctx.globalAlpha = 1;
                        const drawIcon = (img, cx, cy, size, radius) => {
                            const h = size / 2;
                            ctx.save();
                            ctx.globalAlpha = 1;
                            ctx.beginPath();
                            ctx.roundRect(cx - h, cy - h, size, size, radius);
                            ctx.clip();
                            if (img) ctx.drawImage(img, cx - h, cy - h, size, size); else {
                                ctx.fillStyle = "#9AA4B2";
                                ctx.fill();
                            }
                            ctx.restore();
                        };
                        const drawIconHoverBorder = (cx, cy, size, radius) => {
                            const h = size / 2 + hoverBorder;
                            ctx.save();
                            ctx.globalAlpha = 1;
                            ctx.fillStyle = "#FFFFFF";
                            ctx.beginPath();
                            ctx.roundRect(cx - h, cy - h, h * 2, h * 2, radius + 2);
                            ctx.fill();
                            ctx.restore();
                        };
                        const drawDot = (cx, cy, radius, color) => {
                            ctx.save();
                            ctx.globalAlpha = 1;
                            ctx.fillStyle = color;
                            ctx.beginPath();
                            ctx.arc(cx, cy, radius, 0, Math.PI * 2);
                            ctx.fill();
                            ctx.restore();
                        };
                        const drawDotHoverBorder = (cx, cy, dotRadius) => {
                            ctx.save();
                            ctx.globalAlpha = 1;
                            ctx.fillStyle = "#FFFFFF";
                            ctx.beginPath();
                            ctx.arc(cx, cy, dotRadius + hoverBorder, 0, Math.PI * 2);
                            ctx.fill();
                            ctx.restore();
                        };
                        const groupPositions = [];
                        state.groups.forEach((group => {
                            if (group.length === 1) {
                                const px = getPixelForTime(chart, group[0].time);
                                if (px !== null) groupPositions.push({
                                    startX: px,
                                    endX: px
                                });
                            } else {
                                const pixels = group.map((e => getPixelForTime(chart, e.time))).filter((p => p !== null));
                                if (pixels.length >= 2) groupPositions.push({
                                    startX: pixels[0],
                                    endX: pixels[pixels.length - 1]
                                });
                            }
                        }));
                        ctx.save();
                        ctx.globalAlpha = 1;
                        ctx.setLineDash([ 6, 4 ]);
                        ctx.lineWidth = DASH_LINE_WIDTH;
                        ctx.strokeStyle = DASH_COLOR;
                        ctx.lineCap = "round";
                        for (let i = 0; i < groupPositions.length - 1; i++) {
                            ctx.beginPath();
                            ctx.moveTo(groupPositions[i].endX, centerY);
                            ctx.lineTo(groupPositions[i + 1].startX, centerY);
                            ctx.stroke();
                        }
                        ctx.restore();
                        state.groups.forEach((group => {
                            const appId = group[0].appId;
                            const img = state.images[appId];
                            const color = state.colors[appId] || {
                                r: 154,
                                g: 164,
                                b: 178
                            };
                            const colorStr = `rgb(${color.r}, ${color.g}, ${color.b})`;
                            if (group.length === 1) {
                                const entry = group[0];
                                const x = getPixelForTime(chart, entry.time);
                                if (x === null) return;
                                const hr = {
                                    appId,
                                    name: entry.name,
                                    icon: entry.icon,
                                    developer: entry.developer || "",
                                    checkDate: entry.checkDate || "",
                                    time: entry.time,
                                    cx: x,
                                    x1: x - ICON_SIZE_SINGLE / 2 - 4,
                                    x2: x + ICON_SIZE_SINGLE / 2 + 4,
                                    y1: centerY - ICON_SIZE_SINGLE / 2 - 4,
                                    y2: centerY + ICON_SIZE_SINGLE / 2 + 4
                                };
                                state.hitRegions.push(hr);
                                const isHovered = hoveredRegion && hoveredRegion.cx === x && hoveredRegion.time === entry.time;
                                if (isHovered) drawIconHoverBorder(x, centerY, ICON_SIZE_SINGLE, ICON_BORDER_RADIUS);
                                drawIcon(img, x, centerY, ICON_SIZE_SINGLE, ICON_BORDER_RADIUS);
                            } else {
                                const pixelEntries = [];
                                group.forEach((entry => {
                                    const px = getPixelForTime(chart, entry.time);
                                    if (px !== null) pixelEntries.push({
                                        entry,
                                        px
                                    });
                                }));
                                if (pixelEntries.length < 2) return;
                                const startX = pixelEntries[0].px;
                                const endX = pixelEntries[pixelEntries.length - 1].px;
                                const iconX = (startX + endX) / 2;
                                const iconHalf = ICON_SIZE / 2;
                                ctx.save();
                                ctx.globalAlpha = 1;
                                ctx.setLineDash([]);
                                ctx.strokeStyle = colorStr;
                                ctx.lineWidth = LINE_WIDTH;
                                ctx.lineCap = "round";
                                ctx.beginPath();
                                ctx.moveTo(startX, centerY);
                                ctx.lineTo(endX, centerY);
                                ctx.stroke();
                                ctx.restore();
                                pixelEntries.forEach((({entry, px}) => {
                                    const isUnderIcon = Math.abs(px - iconX) < iconHalf + 2;
                                    const hr = {
                                        appId,
                                        name: entry.name,
                                        icon: entry.icon,
                                        developer: entry.developer || "",
                                        checkDate: entry.checkDate || "",
                                        time: entry.time,
                                        cx: px,
                                        x1: px - DOT_RADIUS - 6,
                                        x2: px + DOT_RADIUS + 6,
                                        y1: centerY - DOT_RADIUS - 6,
                                        y2: centerY + DOT_RADIUS + 6
                                    };
                                    state.hitRegions.push(hr);
                                    if (!isUnderIcon) {
                                        const isHovered = hoveredRegion && hoveredRegion.cx === px && hoveredRegion.time === entry.time;
                                        if (isHovered) drawDotHoverBorder(px, centerY, DOT_RADIUS);
                                        drawDot(px, centerY, DOT_RADIUS, colorStr);
                                    }
                                }));
                                const centerEntry = pixelEntries[Math.floor(pixelEntries.length / 2)].entry;
                                const isIconHovered = hoveredRegion && hoveredRegion.cx === iconX && hoveredRegion.time === centerEntry.time;
                                if (isIconHovered) drawIconHoverBorder(iconX, centerY, ICON_SIZE, ICON_BORDER_RADIUS);
                                drawIcon(img, iconX, centerY, ICON_SIZE, ICON_BORDER_RADIUS);
                                state.hitRegions.push({
                                    appId,
                                    name: centerEntry.name,
                                    icon: centerEntry.icon,
                                    developer: centerEntry.developer || "",
                                    checkDate: centerEntry.checkDate || "",
                                    time: centerEntry.time,
                                    cx: iconX,
                                    x1: iconX - ICON_SIZE / 2 - 2,
                                    x2: iconX + ICON_SIZE / 2 + 2,
                                    y1: centerY - ICON_SIZE / 2 - 2,
                                    y2: centerY + ICON_SIZE / 2 + 2
                                });
                            }
                        }));
                        ctx.restore();
                        const tooltipEl = state.tooltipEl;
                        if (tooltipEl) if (hoveredRegion) {
                            tooltipEl.innerHTML = `\n              <div class="flex flex-col">\n                <div class="flex items-center justify-between bg-Gray-100 p-2 rounded-t-md">\n                  <span class="text-sm text-Gray-700">${hoveredRegion.checkDate}</span>\n                </div>\n                <div class="flex items-center gap-2 p-2">\n                  <img src="${hoveredRegion.icon || ""}" class="w-8 h-8 min-w-8 rounded-lg" alt="">\n                  <div class="flex flex-col">\n                    <span class="text-sm font-medium text-Gray-900">${hoveredRegion.name}</span>\n                    <span class="text-xs text-Gray-600">${hoveredRegion.developer || ""}</span>\n                  </div>\n                </div>\n              </div>\n            `;
                            tooltipEl.style.display = "block";
                            const tw = tooltipEl.offsetWidth;
                            const th = tooltipEl.offsetHeight;
                            let left = hoveredRegion.cx - tw / 2;
                            let top = hoveredRegion.y1 - th - 10;
                            left = Math.max(8, Math.min(left, chart.canvas.width - tw - 8));
                            if (top < 0) top = hoveredRegion.y2 + 10;
                            tooltipEl.style.left = `${left}px`;
                            tooltipEl.style.top = `${top}px`;
                        } else tooltipEl.style.display = "none";
                    },
                    afterEvent(chart, args) {
                        const state = chart._appsTimeline;
                        if (!state || !state.hitRegions || !chart.chartArea) return;
                        const {event} = args;
                        if (!event.x || !event.y) {
                            if (state.hoveredApp) {
                                state.hoveredApp = null;
                                args.changed = true;
                            }
                            return;
                        }
                        let found = null;
                        for (const region of state.hitRegions) if (event.x >= region.x1 && event.x <= region.x2 && event.y >= region.y1 && event.y <= region.y2) {
                            found = region;
                            break;
                        }
                        const prevHovered = state.hoveredApp;
                        state.hoveredApp = found;
                        if (found !== prevHovered) args.changed = true;
                    }
                };
            }
            _createCustomLegend(chart, wrapper) {
                const existingLegend = wrapper.querySelector(".custom-legend");
                if (existingLegend) existingLegend.remove();
                const legendContainer = document.createElement("div");
                legendContainer.className = "custom-legend";
                chart.data.datasets.forEach(((dataset, index) => {
                    const legendItem = this._createLegendItem(dataset, index, chart);
                    legendContainer.appendChild(legendItem);
                }));
                wrapper.appendChild(legendContainer);
            }
            _createLegendItem(dataset, index, chart) {
                const legendItem = document.createElement("button");
                legendItem.className = "custom-legend-item";
                legendItem.setAttribute("data-index", index);
                const colorBox = document.createElement("span");
                colorBox.className = "dot";
                colorBox.style.backgroundColor = dataset.borderColor;
                const label = document.createElement("span");
                label.textContent = dataset.label;
                legendItem.append(colorBox, label);
                legendItem.addEventListener("click", (() => {
                    const meta = chart.getDatasetMeta(index);
                    meta.hidden = meta.hidden == null ? !chart.data.datasets[index].hidden : null;
                    chart.update();
                    legendItem.classList.toggle("opacity-50", meta.hidden);
                }));
                return legendItem;
            }
            _addTimelinePercentages(wrapper, timelineData, images) {
                const legendContainer = wrapper.querySelector(".custom-legend");
                if (!legendContainer) return;
                const existing = legendContainer.querySelector(".apps-timeline-pct");
                if (existing) existing.remove();
                const totalEntries = timelineData.length;
                const appCounts = {};
                const appMeta = {};
                timelineData.forEach((entry => {
                    appCounts[entry.appId] = (appCounts[entry.appId] || 0) + 1;
                    if (!appMeta[entry.appId]) appMeta[entry.appId] = {
                        name: entry.name,
                        icon: entry.icon
                    };
                }));
                const sorted = Object.entries(appCounts).map((([appId, count]) => ({
                    appId,
                    count,
                    pct: Math.round(count / totalEntries * 100)
                }))).sort(((a, b) => b.count - a.count));
                const pctContainer = document.createElement("div");
                pctContainer.className = "apps-timeline-pct";
                pctContainer.style.cssText = "display:flex;align-items:center;gap:12px;";
                sorted.forEach((item => {
                    const itemEl = document.createElement("div");
                    itemEl.style.cssText = "display:flex;align-items:center;gap:4px;";
                    const iconImg = document.createElement("img");
                    iconImg.src = appMeta[item.appId].icon;
                    iconImg.style.cssText = "width:20px;height:20px;border-radius:5px;";
                    iconImg.alt = appMeta[item.appId].name;
                    const pctSpan = document.createElement("span");
                    pctSpan.textContent = `${item.pct}%`;
                    pctSpan.style.cssText = "font-size:13px;font-weight:500;color:#364152;";
                    itemEl.append(iconImg, pctSpan);
                    pctContainer.appendChild(itemEl);
                }));
                legendContainer.appendChild(pctContainer);
            }
            _addChangeMarkers(chart, wrapper, annotations) {
                const chartOverflow = wrapper.querySelector(".chart-overflow");
                const tooltip = document.createElement("div");
                tooltip.className = "marker-tooltip absolute bg-white shadow-md rounded-md hidden";
                tooltip.style.cssText = `\n      position: absolute;\n      z-index: 1001;\n      min-width: 200px;\n      pointer-events: none;\n      user-select: none;\n      -webkit-user-select: none;\n    `;
                chartOverflow.appendChild(tooltip);
                const markersContainer = document.createElement("div");
                markersContainer.className = "chart-markers absolute inset-0";
                markersContainer.style.cssText = `\n      position: absolute;\n      inset: 0;\n      overflow: visible;\n      z-index: 999;\n      pointer-events: none;\n    `;
                chartOverflow.appendChild(markersContainer);
                const sortedAnnotations = [ ...annotations ].sort(((a, b) => {
                    const [hoursA, minutesA] = a.time.split(".").map(Number);
                    const [hoursB, minutesB] = b.time.split(".").map(Number);
                    const timeA = hoursA * 60 + minutesA;
                    const timeB = hoursB * 60 + minutesB;
                    return timeA - timeB;
                }));
                const groups = [];
                let currentGroup = [ sortedAnnotations[0] ];
                for (let i = 1; i < sortedAnnotations.length; i++) {
                    const current = sortedAnnotations[i];
                    const prev = sortedAnnotations[i - 1];
                    const [hoursCurr, minsCurr] = current.time.split(".").map(Number);
                    const [hoursPrev, minsPrev] = prev.time.split(".").map(Number);
                    const timeCurr = hoursCurr * 60 + minsCurr;
                    const timePrev = hoursPrev * 60 + minsPrev;
                    if (Math.abs(timeCurr - timePrev) <= 15) currentGroup.push(current); else {
                        groups.push(currentGroup);
                        currentGroup = [ current ];
                    }
                }
                groups.push(currentGroup);
                groups.forEach((groupAnnotations => {
                    const offset = 5;
                    groupAnnotations.forEach(((annotation, index) => {
                        let horizontalOffset = 0;
                        if (groupAnnotations.length > 1) horizontalOffset = (index - (groupAnnotations.length - 1) / 2) * offset;
                        const marker = this._createMarker(chart, annotation, tooltip, {
                            offsetX: horizontalOffset
                        });
                        if (marker) markersContainer.appendChild(marker);
                    }));
                }));
            }
            _createMarker(chart, annotation, tooltip, {offsetX = 0} = {}) {
                const marker = document.createElement("div");
                marker.className = "chart-marker absolute";
                marker.style.cssText = `\n      position: absolute;\n      z-index: 1000;\n      pointer-events: auto;\n      cursor: pointer;\n    `;
                const icon = document.createElement("img");
                icon.src = "../img/icons/icon-chart.svg";
                icon.className = "w-6 min-w-6 min-h-6 h-6";
                marker.appendChild(icon);
                const wrapper = chart.canvas.closest(".chart-wrapper");
                wrapper.querySelector(".chart-container");
                const xScale = chart.scales.x;
                let xPixel;
                if (annotation.time) {
                    const labels = chart.data.labels;
                    const [hours, minutes] = annotation.time.split(".").map(Number);
                    const currentHourIndex = labels.findIndex((label => {
                        const [labelHours] = label.split(".").map(Number);
                        return labelHours === hours;
                    }));
                    const nextHourIndex = labels.findIndex((label => {
                        const [labelHours] = label.split(".").map(Number);
                        return labelHours === hours + 1;
                    }));
                    if (currentHourIndex !== -1) {
                        const currentPixel = xScale.getPixelForValue(currentHourIndex);
                        const nextPixel = nextHourIndex !== -1 ? xScale.getPixelForValue(nextHourIndex) : xScale.getPixelForValue(currentHourIndex + 1);
                        const fraction = minutes / 60;
                        xPixel = currentPixel + (nextPixel - currentPixel) * fraction;
                    }
                } else if (annotation.xValue !== void 0) xPixel = xScale.getPixelForValue(annotation.xValue);
                if (xPixel === void 0) return null;
                const chartArea = chart.chartArea;
                const markerX = xPixel - 16 + offsetX;
                const markerY = chartArea.bottom - 16;
                marker.style.left = `${markerX}px`;
                marker.style.top = `${markerY}px`;
                const showTooltip = () => {
                    const customTooltip = wrapper.querySelector(".custom-tooltip");
                    this._resetTooltipState(customTooltip, false);
                    this._updateTooltipContent(tooltip, annotation);
                    tooltip.classList.remove("hidden");
                    const markerRect = marker.getBoundingClientRect();
                    const tooltipRect = tooltip.getBoundingClientRect();
                    const chartRect = chart.canvas.getBoundingClientRect();
                    wrapper.querySelector(".chart-overflow");
                    const x = markerRect.left - chartRect.left + markerRect.width / 2 - tooltipRect.width / 2;
                    const y = markerRect.top - chartRect.top - tooltipRect.height - 8;
                    const minX = 8;
                    const maxX = chartRect.width - tooltipRect.width - 8;
                    const finalX = Math.max(minX, Math.min(x, maxX));
                    tooltip.style.transform = "none";
                    tooltip.style.left = `${finalX}px`;
                    tooltip.style.top = `${y}px`;
                };
                const hideTooltip = () => {
                    tooltip.classList.add("hidden");
                    const customTooltip = wrapper.querySelector(".custom-tooltip");
                    this._resetTooltipState(customTooltip, true);
                };
                marker.addEventListener("mouseenter", showTooltip);
                marker.addEventListener("mouseleave", hideTooltip);
                return marker;
            }
            _updateTooltipContent(tooltip, annotation) {
                const changeType = annotation.change.type;
                let valuePrefix = "$";
                const priceIcon = `\n      <svg xmlns="http://www.w3.org/2000/svg" width="20" height="21" viewBox="0 0 20 21" fill="none" class="inline-block ml-1">\n        <g clip-path="url(#clip0_1361_57932)">\n          <path d="M10.8772 4.7325C11.6863 3.975 12.8305 2.76583 13.2888 1.6125C13.5013 1.07833 13.0747 0.5 12.4997 0.5H7.49967C6.92467 0.5 6.49801 1.0775 6.71051 1.6125C7.16884 2.76583 8.31301 3.975 9.12217 4.7325C4.64051 5.39833 0.833008 11.015 0.833008 15.5C0.833008 18.2575 3.07551 20.5 5.83301 20.5H14.1663C16.9238 20.5 19.1663 18.2575 19.1663 15.5C19.1663 11.015 15.3588 5.39833 10.8772 4.7325ZM8.86967 11.9675L11.4047 12.39C12.5222 12.5758 13.3338 13.5342 13.3338 14.6675C13.3338 16.0458 12.2122 17.1675 10.8338 17.1675V18.0008C10.8338 18.4608 10.4605 18.8342 10.0005 18.8342C9.54051 18.8342 9.16717 18.4608 9.16717 18.0008V17.1675H8.94384C8.05384 17.1675 7.22467 16.6892 6.77884 15.9183C6.54884 15.52 6.68467 15.0108 7.08301 14.78C7.47967 14.5492 7.99051 14.685 8.22134 15.0842C8.36967 15.3408 8.64717 15.5008 8.94384 15.5008H10.8338C11.293 15.5008 11.6672 15.1267 11.6672 14.6675C11.6672 14.3525 11.4413 14.0858 11.1305 14.0342L8.59551 13.6117C7.47801 13.4258 6.66634 12.4675 6.66634 11.3342C6.66634 9.95583 7.78801 8.83417 9.16634 8.83417V8.00083C9.16634 7.54083 9.53967 7.1675 9.99967 7.1675C10.4597 7.1675 10.833 7.54083 10.833 8.00083V8.83417H11.0563C11.9455 8.83417 12.7755 9.31333 13.2213 10.0842C13.4513 10.4825 13.3155 10.9917 12.9172 11.2225C12.5197 11.4533 12.0097 11.3175 11.7788 10.9183C11.6297 10.6608 11.353 10.5017 11.0563 10.5017H9.16634C8.70717 10.5017 8.33301 10.8758 8.33301 11.335C8.33301 11.65 8.55884 11.9167 8.86967 11.9683V11.9675Z" fill="#CDD5DF"/>\n        </g>\n        <defs>\n          <clipPath id="clip0_1361_57932">\n            <rect width="20" height="20" fill="white" transform="translate(0 0.5)"/>\n          </clipPath>\n        </defs>\n      </svg>\n    `;
                const userAvatar = annotation.user.avatar ? `<img src="${annotation.user.avatar}" class="w-8 min-w-8 min-h-8 h-8 rounded-full" alt="${annotation.user.name}">` : `<div class="w-8 h-8 bg-gray-100 rounded-full flex items-center justify-center">\n        <span class="text-Gray-900 text-xs font-bold">${annotation.user.name.split(" ").map((n => n[0])).join("")}</span>\n      </div>`;
                const oldValue = `${valuePrefix}${annotation.oldValue}`;
                const newValue = `${valuePrefix}${annotation.newValue}`;
                const isIncrease = parseFloat(annotation.newValue) >= parseFloat(annotation.oldValue);
                const changeColor = isIncrease ? "price-up" : "price-down";
                tooltip.innerHTML = `\n      <div class="flex flex-col gap-2">\n        <div class="flex items-center justify-between bg-Gray-100 p-2">\n          <span class="text-sm text-Gray-700">${annotation.time}</span>\n        </div>\n        <div class="flex items-center gap-2 px-2">\n          <div class="flex items-center">\n            <span class="text-sm font-semibold text-Gray-900 inline-flex items-center gap-2">${changeType === "budget" ? priceIcon : ""}${oldValue}</span>\n            <span class="mx-2 text-Gray-500 font-bold"><svg xmlns="http://www.w3.org/2000/svg" width="12" height="13" viewBox="0 0 12 13" fill="none">\n              <path d="M11.9348 6.84337C11.9996 6.67929 12.0166 6.49875 11.9835 6.32457C11.9504 6.15039 11.8687 5.99041 11.7487 5.86487L8.31995 2.27406C8.24088 2.18832 8.14629 2.11993 8.04171 2.07288C7.93713 2.02583 7.82465 2.00107 7.71083 2.00003C7.59701 1.999 7.48414 2.02171 7.37879 2.06685C7.27344 2.11199 7.17774 2.17864 7.09725 2.26293C7.01677 2.34722 6.95312 2.44745 6.91002 2.55777C6.86692 2.6681 6.84523 2.78631 6.84622 2.9055C6.84721 3.0247 6.87085 3.1425 6.91578 3.25202C6.9607 3.36154 7.02601 3.4606 7.10788 3.54341L9.07429 5.60274H0.857197C0.629854 5.60274 0.411823 5.69732 0.251067 5.86568C0.0903117 6.03403 0 6.26236 0 6.50045C0 6.73853 0.0903117 6.96687 0.251067 7.13522C0.411823 7.30357 0.629854 7.39815 0.857197 7.39815H9.07429L7.10874 9.45659C7.02686 9.5394 6.96156 9.63846 6.91664 9.74798C6.87171 9.8575 6.84806 9.9753 6.84707 10.0945C6.84609 10.2137 6.86777 10.3319 6.91088 10.4422C6.95398 10.5526 7.01763 10.6528 7.09811 10.7371C7.1786 10.8214 7.2743 10.888 7.37965 10.9332C7.485 10.9783 7.59787 11.001 7.71169 11C7.82551 10.9989 7.93799 10.9742 8.04257 10.9271C8.14715 10.8801 8.24174 10.8117 8.32081 10.7259L11.7496 7.13513C11.829 7.05155 11.8919 6.95241 11.9348 6.84337Z" fill="#CDD5DF"/>\n            </svg></span>\n            <span class="text-sm font-semibold ${changeColor}">${newValue}</span>\n          </div>\n        </div>\n        <div class="flex items-center gap-2 px-2 pb-2">\n          ${userAvatar}\n          <div class="flex flex-col">\n            <span class="text-sm font-medium text-Gray-900">${annotation.user.name}</span>\n            <span class="text-xs text-Gray-600">${annotation.user.email}</span>\n          </div>\n        </div>\n      </div>\n    `;
            }
        }
        class SimpleChartManager extends BaseChartManager {
            createChart({id, canvasId, type = "line", data = {}, options: chartOptions = {}, jsonConfig = null, dashedSegments = []}) {
                if (this.charts[id]) {
                    console.warn(`График с ID "${id}" уже существует.`);
                    return this.charts[id];
                }
                const canvas = document.getElementById(canvasId);
                if (!canvas) {
                    console.error(`Canvas с ID "${canvasId}" не найден.`);
                    return null;
                }
                const chartWrapper = this._createChartWrapper(canvasId, type, true);
                if (!chartWrapper) return null;
                if (jsonConfig) {
                    const parsed = this._parseJsonConfig(jsonConfig, data, chartOptions, dashedSegments);
                    if (!parsed) return null;
                    ({data, options: chartOptions, dashedSegments} = parsed);
                }
                const ctx = canvas.getContext("2d");
                this.applyDashedSegments(data, dashedSegments);
                const chartConfig = this.getChartConfig(type, data, chartOptions);
                const chart = new chart_Chart(ctx, chartConfig);
                this.charts[id] = chart;
                return chart;
            }
            getChartConfig(type, data, options) {
                return {
                    type,
                    data: data || {
                        labels: [],
                        datasets: []
                    },
                    options: {
                        plugins: {
                            legend: {
                                display: false
                            },
                            tooltip: {
                                enabled: false
                            }
                        },
                        elements: {
                            point: {
                                radius: 0,
                                hoverRadius: 0,
                                hitRadius: 0,
                                borderWidth: 0,
                                backgroundColor: "transparent"
                            },
                            line: {
                                tension: .1,
                                borderWidth: 2,
                                capBezierPoints: true
                            }
                        },
                        hover: {
                            mode: null,
                            intersect: false
                        },
                        scales: {
                            x: {
                                display: false,
                                grid: {
                                    display: false,
                                    drawBorder: false,
                                    color: "rgba(0, 0, 0, 0.1)"
                                }
                            },
                            y: {
                                display: false,
                                grid: {
                                    display: false,
                                    drawBorder: false,
                                    color: "red"
                                },
                                ticks: {
                                    callback: function(value) {
                                        if (value >= 1e6) return (value / 1e6).toFixed(1) + "M";
                                        if (value >= 1e3) return (value / 1e3).toFixed(0) + "k";
                                        return value;
                                    }
                                },
                                beginAtZero: true,
                                suggestedMax: function(context) {
                                    const values = context.chart.data.datasets[0].data;
                                    const max = Math.max(...values.filter((v => v !== null)));
                                    return max * 1.1;
                                }
                            }
                        },
                        maintainAspectRatio: false,
                        responsive: true
                    }
                };
            }
        }
        window.initCharts = () => {
            Object.values(chartConfigs).forEach((config => {
                initChart({
                    id: config.id,
                    canvasId: `chart-${config.id}`,
                    data: config.data
                });
                initChart({
                    id: `simple-${config.id}`,
                    simple: true,
                    canvasId: `simpleСhart-${config.id}`,
                    originalChartId: config.id
                });
            }));
        };
        window.initChart = (options = {}) => {
            const manager = options.simple ? new SimpleChartManager : new ChartManager;
            const config = options.simple ? chartConfigs[options.originalChartId] : chartConfigs[options.id];
            return manager.createChart({
                id: options.id,
                canvasId: options.canvasId,
                type: options.type || "line",
                data: options.data || config?.data,
                options: {
                    tooltip: true,
                    ...options.chartOptions
                }
            });
        };
        document.addEventListener("DOMContentLoaded", window.initCharts);
        class HorizBarChart {
            constructor(canvasId, chartData, userOptions = {}) {
                this.canvasId = canvasId;
                this.chartData = chartData;
                this.userOptions = userOptions;
                this.canvasEl = null;
                this.chart = null;
                this.legendEl = null;
                this.tooltipEl = null;
                this.chartOverflow = null;
                this.activeLegend = {};
                const originalCanvas = document.getElementById(this.canvasId);
                if (!originalCanvas) {
                    console.error(`Canvas with id="${this.canvasId}" not found.`);
                    return;
                }
                this.canvasEl = originalCanvas;
                this._ensureLabelsMatchData();
                const {chartWrapper, chartOverflow, chartInner} = this._createWrappers(this.canvasEl);
                this.chartOverflow = chartOverflow;
                if (this.chartData.labels.length > 3) {
                    chartOverflow.style.maxHeight = "300px";
                    chartOverflow.style.overflowY = "auto";
                }
                this.legendEl = document.createElement("div");
                this.legendEl.id = `${this.canvasId}-legend`;
                this.legendEl.classList.add("custom-legend");
                chartWrapper.appendChild(this.legendEl);
                if (!this._validateData(this.chartData)) {
                    console.error("Invalid chart data");
                    return;
                }
                const defaultOptions = this._getDefaultOptions();
                const finalOptions = this._deepMerge(defaultOptions, this.userOptions);
                const customLabelsPlugin = {
                    id: "customLabels",
                    afterDatasetsDraw: chart => {
                        const horizBarChart = chart.options.plugins.customLabelsContext;
                        horizBarChart._addCustomLabels(chart);
                    },
                    afterUpdate: chart => {
                        chart.options.plugins.customLabelsContext._addCustomLabels(chart);
                    }
                };
                const ctx = this.canvasEl.getContext("2d");
                this.chart = new Chart(ctx, {
                    type: "bar",
                    data: this.chartData,
                    options: {
                        ...finalOptions,
                        plugins: {
                            ...finalOptions.plugins,
                            customLabelsContext: this,
                            tooltip: {
                                enabled: false,
                                external: this._renderCustomTooltip.bind(this)
                            }
                        }
                    },
                    plugins: [ customLabelsPlugin ]
                });
                this._buildLegend();
                this._createTooltipElement(chartOverflow);
                this._loadLegendState();
            }
            _ensureLabelsMatchData() {
                const maxDataLength = Math.max(...this.chartData.datasets.map((ds => ds.data.length)));
                const currentLabelsLength = this.chartData.labels.length;
                if (maxDataLength > currentLabelsLength) {
                    for (let i = currentLabelsLength; i < maxDataLength; i++) this.chartData.labels.push(`Label ${i + 1}`);
                    console.warn(`Добавлено ${maxDataLength - currentLabelsLength} автоматически сгенерированных лейблов.`);
                }
            }
            _deepMerge(target, source) {
                const merged = {
                    ...target
                };
                for (const key in source) if (source[key] && typeof source[key] === "object" && !Array.isArray(source[key])) merged[key] = this._deepMerge(target[key] || {}, source[key]); else merged[key] = source[key];
                return merged;
            }
            _createWrappers(originalCanvas) {
                const uniqueModifier = this.canvasId.replace(/\s+/g, "-").toLowerCase();
                const typeModifier = "bar";
                const chartWrapper = document.createElement("div");
                chartWrapper.classList.add("chart-wrapper", `chart-wrapper--horiz-${uniqueModifier}`, `chart-wrapper--horiz-${typeModifier}`);
                const chartOverflow = document.createElement("div");
                chartOverflow.classList.add("chart-overflow", `chart-overflow--horiz-${uniqueModifier}`, `chart-overflow--horiz-${typeModifier}`);
                chartOverflow.style.position = "relative";
                const chartInner = document.createElement("div");
                chartInner.classList.add("chart-inner", "chart-inner--scrollable", `chart-inner--horiz-${uniqueModifier}`, `chart-inner--horiz-${typeModifier}`);
                const parent = originalCanvas.parentNode;
                parent.replaceChild(chartWrapper, originalCanvas);
                chartWrapper.appendChild(chartOverflow);
                chartOverflow.appendChild(chartInner);
                chartInner.appendChild(originalCanvas);
                return {
                    chartWrapper,
                    chartOverflow,
                    chartInner
                };
            }
            _createTooltipElement(chartOverflow) {
                this.tooltipEl = document.createElement("div");
                this.tooltipEl.classList.add("bg-white", "shadow-md", "min-w-64", "absolute", "opacity-0", "pointer-events-none", "transition-opacity", "duration-200");
                this.tooltipEl.style.position = "absolute";
                this.tooltipEl.style.top = "0";
                this.tooltipEl.style.left = "0";
                this.tooltipEl.style.transform = "translate(0, 0)";
                this.tooltipEl.style.zIndex = "1000";
                chartOverflow.appendChild(this.tooltipEl);
            }
            _saveLegendState() {
                const today = (new Date).toDateString();
                const storageKey = `HorizBarChart_${this.canvasId}_legendState`;
                const stateToSave = {
                    date: today,
                    activeLegend: this.activeLegend
                };
                localStorage.setItem(storageKey, JSON.stringify(stateToSave));
            }
            _loadLegendState() {
                const today = (new Date).toDateString();
                const storageKey = `HorizBarChart_${this.canvasId}_legendState`;
                const savedState = localStorage.getItem(storageKey);
                if (savedState) try {
                    const parsedState = JSON.parse(savedState);
                    if (parsedState.date === today) {
                        this.activeLegend = parsedState.activeLegend;
                        this.chartData.datasets.forEach(((ds, index) => {
                            const meta = this.chart.getDatasetMeta(index);
                            if (this.activeLegend[index] === true) meta.hidden = true; else if (this.activeLegend[index] === false) meta.hidden = false;
                        }));
                        this.chart.update();
                    } else {
                        localStorage.removeItem(storageKey);
                        this.activeLegend = {};
                    }
                } catch (e) {
                    console.error("Error parsing legend state from localStorage:", e);
                    this.activeLegend = {};
                }
            }
            _renderCustomTooltip(context) {
                const {chart, tooltip} = context;
                const tooltipEl = this.tooltipEl;
                if (tooltip.opacity === 0) {
                    tooltipEl.style.opacity = 0;
                    return;
                }
                if (!tooltip.dataPoints || tooltip.dataPoints.length === 0) {
                    tooltipEl.style.opacity = 0;
                    return;
                }
                const dataPoint = tooltip.dataPoints[0];
                const datasetIndex = dataPoint.datasetIndex;
                const index = dataPoint.dataIndex;
                if (typeof datasetIndex !== "number" || typeof index !== "number" || !chart.data.datasets[datasetIndex] || !chart.data.labels[index]) {
                    console.log("Invalid datasetIndex or dataIndex, hiding tooltip");
                    tooltipEl.style.opacity = 0;
                    return;
                }
                const dataset = chart.data.datasets[datasetIndex];
                const label = chart.data.labels[index];
                const currentValue = dataset.data[index];
                const formattedCurrentValue = typeof currentValue === "number" ? currentValue.toLocaleString() : "N/A";
                let previousValue = null;
                const previousDataset = chart.data.datasets.find(((ds, idx) => idx !== datasetIndex));
                if (chart.data.datasets.length > 1) if (previousDataset && previousDataset.data[index] !== void 0) previousValue = previousDataset.data[index];
                let difference = null;
                let pctChange = null;
                let arrow = "";
                let arrowColor = "";
                if (previousValue !== null && typeof previousValue === "number") {
                    difference = currentValue - previousValue;
                    pctChange = previousValue !== 0 ? (difference / Math.abs(previousValue) * 100).toFixed(1) : "0.0";
                    arrow = difference > 0 ? "↑" : "↓";
                    arrowColor = difference > 0 ? "secondaryTwo-700" : "systemRed-600";
                }
                let tooltipHTML = `\n      <div class="bg-gray-100 p-2 font-medium text-Gray-700">${label}</div>\n      <div class="flex items-center p-2 gap-2">\n        <div class="inline-flex items-center gap-2 text-base text-Gray-600">\n          <span style="background-color: ${dataset.backgroundColor}" class="w-2 h-2 min-w-2 min-h-2 rounded-full"></span>\n          ${dataset.label}:\n        </div>\n        <h2 class="text-base font-bold text-Gray-800">$${formattedCurrentValue}</h2>\n        ${difference !== null ? `<span class="text-${arrowColor} font-bold">${arrow}$${Math.abs(difference).toLocaleString()}</span>` : ""}\n      </div>\n      ${previousValue !== null ? `\n        <div class="inline-flex items-center gap-2 text-gray-500 text-sm p-2 pt-0">\n          <div class="inline-flex items-center gap-2 text-base text-Gray-600">\n            <span style="background-color: ${previousDataset.backgroundColor}" class="w-2 h-2 min-w-2 min-h-2 rounded-full"></span>\n            ${previousDataset.label}:\n          </div>\n          <span class="text-base font-bold text-Gray-800">$${previousValue.toLocaleString()}</span>\n        </div>\n      ` : ""}\n    `;
                tooltipEl.innerHTML = tooltipHTML;
                tooltipEl.style.opacity = 1;
                tooltipEl.style.visibility = "hidden";
                const tooltipRect = tooltipEl.getBoundingClientRect();
                tooltipEl.style.visibility = "visible";
                tooltipEl.style.opacity = 0;
                this.chartOverflow.getBoundingClientRect();
                const tooltipX = tooltip.caretX;
                const tooltipY = tooltip.caretY;
                let relativeX = tooltipX;
                let relativeY = tooltipY;
                console.log("Tooltip.caretX:", tooltip.caretX, "Tooltip.caretY:", tooltip.caretY);
                console.log("Relative X:", relativeX, "Relative Y:", relativeY);
                let finalX = relativeX - tooltipRect.width / 2;
                let finalY = relativeY - tooltipRect.height - 10;
                if (finalX + tooltipRect.width > this.chartOverflow.clientWidth) finalX = this.chartOverflow.clientWidth - tooltipRect.width - 10;
                if (finalX < 0) finalX = 10;
                if (finalY < 0) finalY = relativeY + 10;
                if (finalY + tooltipRect.height > this.chartOverflow.clientHeight) finalY = this.chartOverflow.clientHeight - tooltipRect.height - 10;
                tooltipEl.style.left = `${finalX}px`;
                tooltipEl.style.top = `${finalY}px`;
                tooltipEl.style.opacity = 1;
            }
            _validateData(data) {
                if (!data || typeof data !== "object") return false;
                if (!Array.isArray(data.labels) || !Array.isArray(data.datasets)) return false;
                for (const ds of data.datasets) {
                    if (!Array.isArray(ds.data)) return false;
                    if (typeof ds.label !== "string" || typeof ds.backgroundColor !== "string") return false;
                }
                return true;
            }
            _getDefaultOptions() {
                const maxValue = Math.max(...this.chartData.datasets.flatMap((d => d.data))) || 0;
                return {
                    indexAxis: "y",
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            display: false
                        },
                        tooltip: {
                            enabled: false
                        }
                    },
                    scales: {
                        x: {
                            display: false,
                            beginAtZero: true,
                            max: maxValue * 1.5
                        },
                        y: {
                            display: false
                        }
                    },
                    datasets: {
                        bar: {
                            categoryPercentage: 2,
                            barPercentage: 1
                        }
                    },
                    layout: {
                        padding: {
                            top: 0,
                            bottom: 0,
                            left: 0,
                            right: 0
                        }
                    },
                    animation: {
                        duration: 1e3,
                        easing: "easeOutCubic"
                    }
                };
            }
            _addCustomLabels(chart) {
                const {ctx, data, scales} = chart;
                const xScale = scales.x;
                const yScale = scales.y;
                data.labels.forEach(((label, idx) => {
                    const yPos = yScale.getPixelForTick(idx);
                    const font = "bold 16px Inter";
                    const color = "#121926";
                    const textAlign = "left";
                    const textBaseline = "bottom";
                    const labelX = xScale.left + 10;
                    const labelY = yPos - 35;
                    this._drawText(ctx, label, font, color, textAlign, textBaseline, labelX, labelY);
                }));
                data.datasets.forEach(((dataset, datasetIdx) => {
                    const meta = chart.getDatasetMeta(datasetIdx);
                    if (meta.hidden) return;
                    data.labels.forEach(((label, idx) => {
                        const bar = meta.data[idx];
                        if (!bar) return;
                        const barEndX = bar.x;
                        const barCenterY = bar.y;
                        const value = dataset.data[idx];
                        let currentX = barEndX + 10;
                        let currentY = barCenterY;
                        this._drawText(ctx, `$${value}`, "bold 14px Inter", "#000", "left", "middle", currentX, currentY);
                        currentX += ctx.measureText(`$${value}`).width + 25;
                        const nextDatasetIdx = datasetIdx + 1;
                        if (nextDatasetIdx < data.datasets.length) {
                            const nextMeta = chart.getDatasetMeta(nextDatasetIdx);
                            if (!nextMeta.hidden) {
                                const nextValue = chart.data.datasets[nextDatasetIdx].data[idx];
                                const difference = value - nextValue;
                                const pctChange = (difference / Math.abs(nextValue) * 100).toFixed(1);
                                const arrow = difference > 0 ? "↑" : "↓";
                                const arrowColor = difference > 0 ? "#00A985" : "#EB5050";
                                this._drawText(ctx, arrow, "bold 16px Inter", arrowColor, "left", "middle", currentX, currentY);
                                currentX += ctx.measureText(arrow).width + 10;
                                this._drawText(ctx, `$${Math.abs(difference)}`, "bold 14px Inter", arrowColor, "left", "middle", currentX, currentY);
                                currentX += ctx.measureText(`$${Math.abs(difference)}`).width + 20;
                                this._drawText(ctx, `(${pctChange}%)`, "14px Inter", "#9AA4B2", "left", "middle", currentX, currentY);
                            }
                        }
                    }));
                }));
            }
            _drawText(ctx, text, font, color, align, baseline, x, y) {
                ctx.save();
                ctx.font = font;
                ctx.fillStyle = color;
                ctx.textAlign = align;
                ctx.textBaseline = baseline;
                ctx.fillText(text, x, y);
                ctx.restore();
            }
            _buildLegend() {
                if (!this.legendEl) return;
                this.legendEl.innerHTML = "";
                this.chartData.datasets.forEach(((ds, index) => {
                    const legendItem = document.createElement("div");
                    legendItem.classList.add("custom-legend-item");
                    const isActive = this.activeLegend[index] !== false;
                    if (!isActive) legendItem.classList.add("active");
                    legendItem.innerHTML = `\n        <span class="dot" style="background-color: ${ds.backgroundColor};"></span>\n        <span>${ds.label}</span>\n      `;
                    legendItem.addEventListener("click", (() => {
                        const meta = this.chart.getDatasetMeta(index);
                        meta.hidden = !meta.hidden;
                        this.chart.update();
                        legendItem.classList.toggle("active");
                        this.activeLegend[index] = meta.hidden;
                        this._saveLegendState();
                    }));
                    this.legendEl.appendChild(legendItem);
                }));
            }
            updateData(newData) {
                if (!this._validateData(newData)) {
                    console.error("Invalid data for update");
                    return;
                }
                this.chartData = newData;
                this.chart.data = newData;
                const maxValue = Math.max(...newData.datasets.flatMap((d => d.data))) || 0;
                this.chart.options.scales.x.max = maxValue * 1.5;
                this.chart.update();
                if (this.legendEl) {
                    this.legendEl.innerHTML = "";
                    this._buildLegend();
                }
                this._ensureLabelsMatchData();
                if (this.chartData.labels.length > 3) this.chartOverflow.style.maxHeight = "1000px"; else this.chartOverflow.style.maxHeight = "";
            }
        }
        const exampleData = {
            labels: [ "Low Popularity – USA", "Mid Popularity – USA", "High Popularity – USA" ],
            datasets: [ {
                label: "Today",
                data: [ 490, 760, 290 ],
                backgroundColor: "#00C7DC",
                borderRadius: 5,
                barThickness: 27
            }, {
                label: "15.04",
                data: [ 783, 680, 150 ],
                backgroundColor: "#C1F5FA",
                borderRadius: 5,
                barThickness: 27
            } ]
        };
        const exampleData1 = {
            labels: [ "Low Popularity – USA", "Mid Popularity – USA", "High Popularity – USA" ],
            datasets: [ {
                label: "Today",
                data: [ 490, 760, 290 ],
                backgroundColor: "#5E92FF",
                borderRadius: 5,
                barThickness: 27
            }, {
                label: "15.04",
                data: [ 783, 680, 150 ],
                backgroundColor: "#D9E5FF",
                borderRadius: 5,
                barThickness: 27
            } ]
        };
        new HorizBarChart("chart-container1", exampleData);
        new HorizBarChart("chart-container2", exampleData1);
        chart_Chart.register(...registerables, chartjs_plugin_datalabels_esm_plugin);
        chart_Chart.register({
            id: "roundedBar",
            beforeDatasetsDraw(chart) {
                const {ctx} = chart;
                const radius = 10;
                function drawRoundedBar(x, y, width, base) {
                    ctx.beginPath();
                    ctx.moveTo(x - width / 2, base);
                    ctx.lineTo(x - width / 2, y + radius);
                    ctx.quadraticCurveTo(x - width / 2, y, x - width / 2 + radius, y);
                    ctx.lineTo(x + width / 2 - radius, y);
                    ctx.quadraticCurveTo(x + width / 2, y, x + width / 2, y + radius);
                    ctx.lineTo(x + width / 2, base);
                    ctx.closePath();
                }
                chart.data.datasets.forEach(((dataset, index) => {
                    const meta = chart.getDatasetMeta(index);
                    if (!meta.hidden) {
                        ctx.save();
                        ctx.fillStyle = dataset.backgroundColor;
                        meta.data.forEach((bar => {
                            const {x, y, base, width} = bar;
                            drawRoundedBar(x, y, width, base);
                            ctx.fill();
                        }));
                        ctx.restore();
                    }
                }));
            }
        });
        chart_Chart.register({
            id: "horizontalLinesInsideBars",
            beforeDatasetsDraw(chart) {
                const {ctx} = chart;
                const spacing = 10;
                chart.data.datasets.forEach(((dataset, datasetIndex) => {
                    if (dataset.label === "Today") {
                        const meta = chart.getDatasetMeta(datasetIndex);
                        meta.data.forEach((bar => {
                            const {x, y, base, width} = bar;
                            ctx.save();
                            ctx.strokeStyle = "rgba(255, 255, 255, 0.5)";
                            ctx.lineWidth = 1;
                            for (let posY = y + spacing; posY < base; posY += spacing) {
                                ctx.beginPath();
                                ctx.moveTo(x - width / 2, posY);
                                ctx.lineTo(x + width / 2, posY);
                                ctx.stroke();
                            }
                            ctx.restore();
                        }));
                    }
                }));
            }
        });
        chart_Chart.defaults.font.family = "Inter";
        class DynamicBarChart {
            constructor(canvasId, originalData) {
                this.canvasId = canvasId;
                this.canvasEl = document.getElementById(canvasId);
                if (!this.canvasEl) {
                    console.error(`Canvas with id "${canvasId}" not found.`);
                    return;
                }
                this._createWrappers();
                this.data = this._prepareDataForChart(originalData);
                if (!this.data) {
                    console.error("Invalid chart data, chart will not be created.");
                    return;
                }
                const ctx = this.canvasEl.getContext("2d");
                this.chart = new chart_Chart(ctx, {
                    type: "bar",
                    data: this.data,
                    options: this._getChartOptions()
                });
                this._renderCustomLegend();
            }
            _createWrappers() {
                const chartWrapper = document.createElement("div");
                chartWrapper.classList.add("chart-wrapper", `chart-wrapper--${this.canvasId}`, "chart-wrapper--bar");
                const chartOverflow = document.createElement("div");
                chartOverflow.classList.add("chart-overflow", `chart-overflow--${this.canvasId}`, "chart-overflow--bar");
                const chartInner = document.createElement("div");
                chartInner.classList.add("chart-inner", "chart-inner--scrollable", `chart-inner--${this.canvasId}`, "chart-inner--bar");
                const parent = this.canvasEl.parentNode;
                parent.replaceChild(chartWrapper, this.canvasEl);
                chartWrapper.appendChild(chartOverflow);
                chartOverflow.appendChild(chartInner);
                chartInner.appendChild(this.canvasEl);
                const legendContainer = document.createElement("div");
                legendContainer.id = `${this.canvasId}-legend`;
                legendContainer.classList.add("custom-legend");
                chartWrapper.appendChild(legendContainer);
            }
            updateData(newData) {
                const prepared = this._prepareDataForChart(newData);
                if (!prepared) {
                    console.warn("Invalid data provided for update");
                    return;
                }
                const animation = {
                    duration: 800,
                    easing: "easeInOutQuart"
                };
                this.chart.data = prepared;
                this.chart.options = this._getChartOptions();
                this.chart.update(animation);
                this._renderCustomLegend();
            }
            _prepareDataForChart(originalData) {
                if (!this._validateChartData(originalData)) return null;
                const dataCopy = {
                    labels: [ ...originalData.labels ],
                    datasets: originalData.datasets.map((ds => ({
                        ...ds,
                        data: [ ...ds.data ]
                    })))
                };
                const maxLength = dataCopy.datasets.reduce(((acc, ds) => Math.max(acc, ds.data.length)), dataCopy.labels.length);
                if (dataCopy.labels.length < maxLength) for (let i = dataCopy.labels.length; i < maxLength; i++) dataCopy.labels.push(`Company name ${i + 1}`);
                return dataCopy;
            }
            _validateChartData(data) {
                if (!data || typeof data !== "object") return false;
                if (!Array.isArray(data.labels) || !Array.isArray(data.datasets)) return false;
                for (const ds of data.datasets) if (!Array.isArray(ds.data) || !ds.label || !ds.backgroundColor) return false;
                return true;
            }
            _getChartOptions() {
                const isMobile = window.innerWidth < 768;
                const maxValue = Math.max(...this.data.datasets.flatMap((ds => ds.data)));
                return {
                    maintainAspectRatio: false,
                    layout: {
                        padding: {
                            top: 20,
                            left: 0,
                            right: 10,
                            bottom: 10
                        }
                    },
                    plugins: {
                        legend: {
                            display: false
                        },
                        tooltip: {
                            enabled: false,
                            external: context => this._renderCustomTooltip(context)
                        },
                        datalabels: {
                            display: true,
                            align: "top",
                            anchor: "end",
                            color: "#121926",
                            font: {
                                size: isMobile ? 10 : 14,
                                weight: "bold"
                            },
                            formatter: value => value
                        }
                    },
                    scales: {
                        x: {
                            grid: {
                                display: false
                            },
                            ticks: {
                                callback: function(value) {
                                    const label = this.getLabelForValue(value) || "";
                                    const maxLength = 10;
                                    const words = label.split(" ");
                                    const lines = [];
                                    let currentLine = "";
                                    for (const word of words) if ((currentLine + word).length > maxLength) {
                                        lines.push(currentLine);
                                        currentLine = word + " ";
                                    } else currentLine += word + " ";
                                    if (currentLine) lines.push(currentLine.trim());
                                    return lines;
                                },
                                font: {
                                    size: 12
                                }
                            }
                        },
                        y: {
                            beginAtZero: true,
                            suggestedMax: maxValue * 1.15,
                            grid: {
                                color: "#ECEEF4",
                                lineWidth: 1
                            },
                            ticks: {
                                padding: 10,
                                color: "#9aa4b2",
                                font: {
                                    size: 14,
                                    weight: "500"
                                }
                            }
                        }
                    }
                };
            }
            _renderCustomTooltip(context) {
                const tooltipId = `tooltip-${this.canvasId}`;
                let tooltipEl = document.getElementById(tooltipId);
                const chartOverflow = document.querySelector(`.chart-overflow--${this.canvasId}`);
                if (!chartOverflow) return;
                if (!tooltipEl) {
                    tooltipEl = document.createElement("div");
                    tooltipEl.id = tooltipId;
                    tooltipEl.classList.add("tooltip-custom", `tooltip-custom--${this.canvasId}`);
                    chartOverflow.appendChild(tooltipEl);
                }
                const tooltipModel = context.tooltip;
                if (tooltipModel.opacity === 0) {
                    tooltipEl.style.opacity = 0;
                    tooltipEl.style.pointerEvents = "none";
                    return;
                }
                const title = tooltipModel.title?.[0] || "";
                const lines = tooltipModel.dataPoints?.map((point => {
                    try {
                        const dataset = this.chart.data.datasets[point.datasetIndex];
                        if (!dataset) return "";
                        return `<div class="tooltip-line">\n          <span class="tooltip-label">${dataset.label}</span>\n          <span class="tooltip-value">${point.formattedValue}</span>\n        </div>`;
                    } catch (error) {
                        console.warn("Error formatting tooltip line:", error);
                        return "";
                    }
                })).filter((line => line)).join("");
                tooltipEl.innerHTML = `\n      <div class="tooltip-header">${title}</div>\n      <div class="tooltip-body">${lines}</div>\n    `;
                try {
                    tooltipEl.style.opacity = 1;
                    tooltipEl.style.position = "absolute";
                    tooltipEl.style.pointerEvents = "none";
                    const tooltipRect = tooltipEl.getBoundingClientRect();
                    const chartRect = chartOverflow.getBoundingClientRect();
                    let left = tooltipModel.caretX - tooltipRect.width / 2;
                    let top = tooltipModel.caretY - tooltipRect.height - 8;
                    if (left < 0) left = 5; else if (left + tooltipRect.width > chartRect.width) left = chartRect.width - tooltipRect.width - 5;
                    if (top < 0) top = tooltipModel.caretY + 8;
                    tooltipEl.style.transform = "translate3d(0, 0, 0)";
                    tooltipEl.style.left = `${left}px`;
                    tooltipEl.style.top = `${top}px`;
                } catch (error) {
                    console.warn("Error positioning tooltip:", error);
                    tooltipEl.style.opacity = 0;
                }
            }
            _renderCustomLegend() {
                const legendId = `${this.canvasId}-legend`;
                const legendContainer = document.getElementById(legendId);
                if (!legendContainer) {
                    console.warn(`Legend container #${legendId} not found.`);
                    return;
                }
                legendContainer.innerHTML = "";
                this.chart.data.datasets.forEach(((dataset, index) => {
                    const legendItem = document.createElement("div");
                    legendItem.classList.add("custom-legend-item");
                    legendItem.innerHTML = `\n        <span class="dot" style="background-color: ${dataset.backgroundColor};"></span>\n        ${dataset.label}\n      `;
                    legendItem.addEventListener("click", (() => {
                        const meta = this.chart.getDatasetMeta(index);
                        meta.hidden = !meta.hidden;
                        this.chart.update();
                        legendItem.classList.toggle("active");
                    }));
                    legendContainer.appendChild(legendItem);
                }));
            }
        }
        const dynamicChartBar_exampleData = {
            labels: [ "General - Low Popularity - USA", "General - Mid Popularity - USA", "Competitors", "General - High Popularity - USA" ],
            datasets: [ {
                label: "Today",
                data: [ 1215, 600, 1215, 1215, 1215, 1215 ],
                backgroundColor: "#00B4C7",
                borderRadius: 6
            }, {
                label: "22.04",
                data: [ 350, 2139, 2139, 2139, 2139, 2139 ],
                backgroundColor: "#C1F5FA",
                borderRadius: 6
            } ]
        };
        new DynamicBarChart("example-chart", dynamicChartBar_exampleData);
        class RoaswayTable {
            constructor(selector = "[data-table]", options = {}) {
                this.tables = Array.from(document.querySelectorAll(selector));
                this.states = new Map;
                if (this.tables.length === 0) {
                    this.showError(`Не найдено таблиц с селектором: ${selector}`);
                    return;
                }
                this.options = {
                    onResize: options.onResize || (() => {}),
                    onScroll: options.onScroll || (() => {}),
                    onStickyAdjust: options.onStickyAdjust || (() => {}),
                    minWidthResize: options.minWidthResize || 50,
                    maxWidth: options.maxWidth || 300
                };
                this.tables.forEach((table => {
                    const state = this.initTable(table);
                    if (state) this.states.set(table, state);
                }));
                const debouncedResize = tableCustom_debounce((() => this.handleGlobalResize()), 100);
                window.addEventListener("resize", debouncedResize);
                window.addEventListener("load", debouncedResize);
            }
            initTable(table) {
                try {
                    const state = {
                        table,
                        headerCells: Array.from(table.querySelectorAll(".header-row .table-line")),
                        rows: Array.from(table.querySelectorAll(".table-row")),
                        maxColumnWidths: [],
                        tableOverflowThumb: table.querySelector(".table-overflow-thumb"),
                        callbacks: {
                            onResize: [ this.options.onResize ],
                            onScroll: [ this.options.onScroll ],
                            onStickyAdjust: [ this.options.onStickyAdjust ]
                        }
                    };
                    if (!state.headerCells.length || !state.rows.length) throw new Error("Отсутствуют заголовки или строки в одной из таблиц.");
                    state.isFlexible = state.headerCells.length < 7;
                    this.calculateColumnWidths(state);
                    this.setupCells(state);
                    this.setupResizableHeaders(state);
                    this.setupStickyColumns(state);
                    this.createShadowBlock(state);
                    this.adjustTableHeight(state);
                    this.setupRowToggleContent(state, table);
                    this.setupGlobalToggle(state, table);
                    return state;
                } catch (error) {
                    this.showError(`Ошибка при инициализации таблицы: ${error.message}`);
                    return null;
                }
            }
            showError(message) {
                console.error(message);
                const errorContainer = document.createElement("div");
                errorContainer.textContent = message;
                errorContainer.style.color = "red";
                document.body.appendChild(errorContainer);
            }
            handleGlobalResize() {
                this.states.forEach((state => this.adjustStickyColumns(state)));
            }
            isNonMobileWidth() {
                return window.innerWidth >= 992;
            }
            setupRowToggleContent(state, table) {
                const rows = table.querySelectorAll(".table-row-more-content");
                const globalToggleButton = table.querySelector(".toggle-hide-content-global");
                rows.forEach((row => {
                    const toggleButton = row.querySelector(".toggle-hide-content");
                    const hiddenContent = row.querySelectorAll(".hide-content-table-line");
                    hiddenContent.forEach((content => {
                        if (!content.classList.contains("hidden")) content.classList.add("hidden");
                    }));
                    if (toggleButton) toggleButton.addEventListener("click", (() => {
                        if (globalToggleButton && globalToggleButton.classList.contains("rotate-180")) globalToggleButton.classList.remove("rotate-180");
                        const isOpening = Array.from(hiddenContent).some((content => content.classList.contains("hidden")));
                        hiddenContent.forEach((content => content.classList.toggle("hidden")));
                        toggleButton.classList.toggle("rotate-180");
                        if (isOpening) row.classList.add("content-self-start", "focused"); else row.classList.remove("content-self-start", "focused");
                    }));
                }));
            }
            setupGlobalToggle(state, table) {
                const globalToggleButton = table.querySelector(".toggle-hide-content-global");
                if (!globalToggleButton) return;
                globalToggleButton.addEventListener("click", (() => {
                    const isAnyContentHidden = Array.from(state.rows).some((row => row.querySelectorAll(".hide-content-table-line.hidden").length > 0));
                    state.rows.forEach((row => {
                        if (row.classList.contains("table-row-more-content")) {
                            const hiddenContent = row.querySelectorAll(".hide-content-table-line");
                            const toggleButton = row.querySelector(".toggle-hide-content");
                            hiddenContent.forEach((content => {
                                if (isAnyContentHidden) content.classList.remove("hidden"); else content.classList.add("hidden");
                            }));
                            if (toggleButton) toggleButton.classList.toggle("rotate-180", isAnyContentHidden);
                            if (isAnyContentHidden) row.classList.add("content-self-start", "focused"); else row.classList.remove("content-self-start", "focused");
                        }
                    }));
                    globalToggleButton.classList.toggle("rotate-180");
                }));
            }
            getActualWidth(element, useFullWidth = false) {
                if (!element) return 0;
                const style = window.getComputedStyle(element);
                const elementWidth = element.offsetWidth;
                const paddingLeft = parseFloat(style.paddingLeft) || 0;
                const paddingRight = parseFloat(style.paddingRight) || 0;
                const borderLeft = parseFloat(style.borderLeftWidth) || 0;
                const borderRight = parseFloat(style.borderRightWidth) || 0;
                const fullWidth = elementWidth + paddingLeft + paddingRight + borderLeft + borderRight;
                return useFullWidth ? fullWidth : elementWidth;
            }
            calculateColumnWidths(state) {
                const tableWidth = state.table.offsetWidth;
                let totalFitWidth = 0;
                state.maxColumnWidths = state.headerCells.map(((header, index) => {
                    const width = this.getMinContentWidth(header, state.rows, index);
                    if (header.classList.contains("fit")) totalFitWidth += width;
                    return width;
                }));
                const shouldStretch = this.shouldStretchColumns(state, totalFitWidth, tableWidth);
                if (shouldStretch) this.stretchColumns(state, totalFitWidth, tableWidth);
                this.applyColumnWidths(state);
            }
            shouldStretchColumns(state, totalFitWidth, tableWidth) {
                const totalWidth = state.maxColumnWidths.reduce(((sum, width) => sum + width), 0);
                return totalWidth < tableWidth;
            }
            stretchColumns(state, totalFitWidth, tableWidth) {
                const totalCurrentWidth = state.maxColumnWidths.reduce(((sum, w) => sum + w), 0);
                const extraSpace = tableWidth - totalCurrentWidth;
                if (extraSpace <= 0) return;
                const nonFitColumns = state.headerCells.map(((header, index) => ({
                    index,
                    width: state.maxColumnWidths[index],
                    isFit: header.classList.contains("fit")
                }))).filter((col => !col.isFit));
                const stretchable = nonFitColumns.length > 0 ? nonFitColumns : state.maxColumnWidths.map(((w, i) => ({
                    index: i,
                    width: w
                })));
                if (stretchable.length === 0) return;
                const totalStretchableWidth = stretchable.reduce(((sum, col) => sum + col.width), 0);
                stretchable.forEach((col => {
                    const ratio = totalStretchableWidth > 0 ? col.width / totalStretchableWidth : 1 / stretchable.length;
                    const addWidth = Math.floor(extraSpace * ratio);
                    state.maxColumnWidths[col.index] = col.width + addWidth;
                }));
            }
            getMinContentWidth(header, rows, index) {
                const getCellFullWidth = cell => {
                    const innerDiv = cell.querySelector("div");
                    if (!innerDiv) return 0;
                    const rect = innerDiv.getBoundingClientRect();
                    const divWidth = Math.ceil(rect.width);
                    const cellStyle = window.getComputedStyle(cell);
                    const cellPadding = parseFloat(cellStyle.paddingLeft) + parseFloat(cellStyle.paddingRight);
                    const totalWidth = divWidth + cellPadding;
                    return totalWidth;
                };
                let maxWidth = getCellFullWidth(header);
                rows.forEach((row => {
                    const cell = row.querySelectorAll(".table-line")[index];
                    if (!cell) return;
                    maxWidth = Math.max(maxWidth, getCellFullWidth(cell));
                }));
                const isFit = header.classList.contains("fit");
                if (!isFit) maxWidth += 2;
                maxWidth = Math.min(maxWidth, 300);
                return maxWidth;
            }
            getOptimalColumnWidth(header, rows, index) {
                const contentWidth = this.getMinContentWidth(header, rows, index);
                const isText = this.isTextContent(header, rows, index);
                const isNumeric = this.isNumericContent(header, rows, index);
                if (isNumeric) return Math.min(120, contentWidth);
                if (isText) {
                    const avgWordLength = this.getAverageWordLength(header, rows, index);
                    return avgWordLength > 10 ? 200 : Math.min(300, contentWidth);
                }
                return Math.min(200, contentWidth);
            }
            isTextContent(header, rows, index) {
                const cells = [ header, ...rows.map((row => row.querySelectorAll(".table-line")[index])) ];
                const textCells = cells.filter((cell => {
                    if (!cell) return false;
                    const content = cell.textContent.trim();
                    return content.length > 0 && isNaN(content);
                }));
                return textCells.length / cells.length > .7;
            }
            isNumericContent(header, rows, index) {
                const cells = [ header, ...rows.map((row => row.querySelectorAll(".table-line")[index])) ];
                const numericCells = cells.filter((cell => {
                    if (!cell) return false;
                    const content = cell.textContent.trim();
                    return !isNaN(content) && content.length > 0;
                }));
                return numericCells.length / cells.length > .7;
            }
            getAverageWordLength(header, rows, index) {
                const cells = [ header, ...rows.map((row => row.querySelectorAll(".table-line")[index])) ];
                let totalLength = 0;
                let wordCount = 0;
                cells.forEach((cell => {
                    if (!cell) return;
                    const words = cell.textContent.trim().split(/\s+/);
                    words.forEach((word => {
                        if (word.length > 0) {
                            totalLength += word.length;
                            wordCount++;
                        }
                    }));
                }));
                return wordCount > 0 ? totalLength / wordCount : 0;
            }
            getCellWidth(cell, isHeader = false) {
                if (!cell) return 0;
                const contentDiv = cell.querySelector("div");
                const contentWidth = contentDiv ? contentDiv.scrollWidth : 0;
                const computedStyle = window.getComputedStyle(cell);
                const paddingLeft = parseFloat(computedStyle.paddingLeft) || 0;
                const paddingRight = parseFloat(computedStyle.paddingRight) || 0;
                return contentWidth + paddingLeft + paddingRight;
            }
            applyColumnWidths(state) {
                const isFlexible = state.isFlexible;
                state.headerCells.forEach(((header, index) => {
                    this.setCellWidth(header, state.maxColumnWidths[index], isFlexible);
                }));
                state.rows.forEach((row => {
                    row.querySelectorAll(".table-line").forEach(((cell, index) => {
                        this.setCellWidth(cell, state.maxColumnWidths[index], isFlexible);
                    }));
                }));
            }
            setCellWidth(cell, width, isFlexible = false) {
                if (!cell) return;
                width = Math.max(0, width);
                cell.style.width = `${width}px`;
            }
            setupCells(state) {
                const isFlexible = state.isFlexible;
                state.headerCells.forEach(((header, headerIndex) => {
                    this.setCellWidth(header, state.maxColumnWidths[headerIndex], isFlexible);
                    header.setAttribute("role", "columnheader");
                    header.setAttribute("cell-index", headerIndex);
                }));
                state.rows.forEach(((row, rowIndex) => {
                    row.setAttribute("role", "row");
                    row.setAttribute("aria-rowindex", rowIndex + 1);
                    row.setAttribute("tabindex", "-1");
                    row.setAttribute("row-index", rowIndex);
                    row.setAttribute("row-id", rowIndex + 1);
                    row.querySelectorAll(".table-line").forEach(((cell, cellIndex) => {
                        cell.setAttribute("role", "gridcell");
                        cell.setAttribute("cell-index", cellIndex);
                        if (state.headerCells[cellIndex].classList.contains("fit")) cell.classList.add("fit");
                        this.setCellWidth(cell, state.maxColumnWidths[cellIndex], isFlexible);
                    }));
                }));
            }
            setupResizableHeaders(state) {
                const resizableHeaders = state.headerCells.filter((cell => cell.classList.contains("resizable") && !cell.classList.contains("fit")));
                resizableHeaders.forEach((resizable => {
                    const resizer = resizable.querySelector(".resizer");
                    if (!resizer) return;
                    const columnIndex = parseInt(resizable.getAttribute("cell-index"));
                    if (isNaN(columnIndex)) return;
                    resizer.addEventListener("mousedown", (e => {
                        if (!this.isNonMobileWidth()) return;
                        e.preventDefault();
                        this.startColumnResize(e, resizable, columnIndex, state);
                    }));
                }));
            }
            startColumnResize(e, resizable, index, state) {
                const startX = e.clientX;
                const originalWidth = resizable.offsetWidth;
                const initialColumnWidths = state.headerCells.map((header => header.offsetWidth));
                const maxStickyWidth = state.table.offsetWidth * .7;
                const minWidth = Math.max(50, typeof this.options.minWidthResize === "number" ? this.options.minWidthResize : state.maxColumnWidths[index]);
                document.body.style.cursor = "col-resize";
                const onMouseMove = moveEvent => {
                    requestAnimationFrame((() => {
                        const widthChange = moveEvent.clientX - startX;
                        let newWidth = Math.round(Math.max(minWidth, originalWidth + widthChange));
                        let totalStickyWidth = 0;
                        state.headerCells.forEach(((header, i) => {
                            if (header.classList.contains("sticky")) totalStickyWidth += i === index ? newWidth : header.offsetWidth;
                        }));
                        if (resizable.classList.contains("sticky") && totalStickyWidth > maxStickyWidth) {
                            const maxAllowedChange = maxStickyWidth - (totalStickyWidth - newWidth);
                            newWidth = Math.min(newWidth, maxAllowedChange);
                        }
                        this.updateColumnWidth(state, index, newWidth, initialColumnWidths);
                        state.callbacks.onResize.forEach((callback => {
                            const columnId = state.headerCells[index].getAttribute("data-column-id") || index;
                            callback(newWidth, columnId);
                        }));
                        const shadowContent = state.table.querySelector(".shadow-block .block");
                        if (shadowContent) this.updateShadowDimensions(state, shadowContent);
                    }));
                };
                const onMouseUp = () => {
                    document.removeEventListener("mousemove", onMouseMove);
                    document.removeEventListener("mouseup", onMouseUp);
                    document.body.style.cursor = "";
                };
                document.addEventListener("mousemove", onMouseMove);
                document.addEventListener("mouseup", onMouseUp);
            }
            setupStickyColumns(state) {
                if (!this.isNonMobileWidth()) return;
                const maxStickyWidth = state.table.offsetWidth * .7;
                let totalStickyWidth = 0;
                state.headerCells.forEach((header => {
                    if (header.classList.contains("sticky")) totalStickyWidth += header.offsetWidth;
                }));
                if (totalStickyWidth > maxStickyWidth) {
                    const ratio = maxStickyWidth / totalStickyWidth;
                    state.headerCells.forEach(((header, index) => {
                        if (header.classList.contains("sticky")) {
                            const newWidth = Math.floor(header.offsetWidth * ratio);
                            this.setCellWidth(header, newWidth, false);
                            state.rows.forEach((row => {
                                const cell = row.querySelectorAll(".table-line")[index];
                                if (cell) this.setCellWidth(cell, newWidth, false);
                            }));
                        }
                    }));
                }
                this.setStickyPosition(state.headerCells);
                state.rows.forEach((row => {
                    this.setStickyPosition(row.querySelectorAll(".table-line"));
                }));
            }
            setStickyPosition(elements) {
                elements.forEach((element => {
                    if (element.classList.contains("sticky")) {
                        element.style.position = "sticky";
                        element.style.left = `${element.offsetLeft}px`;
                    }
                }));
            }
            createShadowBlock(state) {
                if (!this.isNonMobileWidth()) return;
                const shadowBlock = document.createElement("div");
                shadowBlock.classList.add("shadow-block", "absolute", "inset-0", "pointer-events-none", "z-50");
                const shadowContent = document.createElement("span");
                shadowContent.classList.add("block", "bg-opacity-10");
                shadowContent.style.opacity = "0";
                shadowContent.style.maxWidth = "70%";
                shadowBlock.appendChild(shadowContent);
                const tableWrapper = state.table.querySelector(".table-type-one__wrapper");
                if (!tableWrapper) {
                    this.showError("Table wrapper .table-type-one__wrapper not found.");
                    return;
                }
                tableWrapper.appendChild(shadowBlock);
                this.updateShadowDimensions(state, shadowContent, false);
                if (state.tableOverflowThumb) state.tableOverflowThumb.addEventListener("scroll", (() => {
                    this.updateShadowDimensions(state, shadowContent, true);
                }));
            }
            updateShadowDimensions(state, shadowContent, isScrolling = false) {
                const totalStickyWidth = Array.from(state.table.querySelectorAll(".header-row > .sticky")).reduce(((acc, stickyHeader) => acc + stickyHeader.offsetWidth), 0);
                const tableHeight = state.table.querySelector(".table-type-one__body")?.offsetHeight || 0;
                shadowContent.style.width = `${totalStickyWidth}px`;
                shadowContent.style.height = `${tableHeight}px`;
                if (isScrolling) this.checkShadowVisibility(state, shadowContent);
            }
            checkShadowVisibility(state, shadowContent) {
                const tableWrapper = state.table.querySelector(".table-type-one__wrapper");
                if (!tableWrapper) return;
                const stickyElements = state.table.querySelectorAll(".sticky, .sticky-row");
                if (stickyElements.length === 0) return;
                const wrapperRect = tableWrapper.getBoundingClientRect();
                const firstStickyRect = stickyElements[0].getBoundingClientRect();
                const hasScroll = state.tableOverflowThumb && state.tableOverflowThumb.scrollLeft > 0;
                const shouldShowShadow = hasScroll && Math.abs(firstStickyRect.left - wrapperRect.left) <= 1;
                shadowContent.style.opacity = shouldShowShadow ? "1" : "0";
            }
            adjustStickyColumns(state) {
                if (!this.isNonMobileWidth()) return;
                const stickyHeaders = state.table.querySelectorAll(".header-row > .sticky");
                this.updateStickyPositions(stickyHeaders);
                state.rows.forEach((row => {
                    const stickyCells = row.querySelectorAll(".sticky-row");
                    this.updateStickyPositions(stickyCells);
                }));
                state.callbacks.onStickyAdjust.forEach((callback => callback()));
            }
            adjustTableHeight(state) {
                const totalRows = state.rows.length + 1;
                const tableBody = state.table.querySelector(".table-type-one__body");
                if (tableBody) if (totalRows > 15) tableBody.style.height = "500px"; else tableBody.style.height = "";
            }
            updateColumnWidth(state, index, newWidth, initialColumnWidths = null) {
                if (state.isFlexible) {
                    this.setCellWidth(state.headerCells[index], newWidth, state.isFlexible);
                    state.rows.forEach((row => {
                        const cell = row.querySelectorAll(".table-line")[index];
                        if (cell) this.setCellWidth(cell, newWidth, state.isFlexible);
                    }));
                    if (initialColumnWidths) state.headerCells.forEach(((header, idx) => {
                        if (idx !== index && header.classList.contains("fit")) {
                            const fitWidth = initialColumnWidths[idx];
                            this.setCellWidth(header, fitWidth, state.isFlexible);
                            state.rows.forEach((row => {
                                const cell = row.querySelectorAll(".table-line")[idx];
                                if (cell) this.setCellWidth(cell, fitWidth, state.isFlexible);
                            }));
                        }
                    }));
                } else {
                    this.setCellWidth(state.headerCells[index], newWidth, state.isFlexible);
                    state.rows.forEach((row => {
                        const cell = row.querySelectorAll(".table-line")[index];
                        if (cell) this.setCellWidth(cell, newWidth, state.isFlexible);
                    }));
                }
            }
            updateStickyPositions(elements) {
                let offset = 0;
                elements.forEach((element => {
                    element.style.left = `${offset}px`;
                    offset += element.offsetWidth;
                }));
            }
        }
        function tableCustom_debounce(func, delay) {
            let timer;
            return function(...args) {
                clearTimeout(timer);
                timer = setTimeout((() => func.apply(this, args)), delay);
            };
        }
        document.addEventListener("DOMContentLoaded", (() => {
            new RoaswayTable(".table-type-one", {
                minWidthResize: 70,
                onResize: tableCustom_debounce(((width, columnId) => {
                    console.log(`Column ${columnId} resized to ${width}px`);
                }), 200),
                onScroll: tableCustom_debounce((scrollLeft => {
                    console.log(`Scrolled to ${scrollLeft}px`);
                }), 200),
                onStickyAdjust: tableCustom_debounce((() => {
                    console.log("Sticky columns adjusted");
                }), 200)
            });
        }));
        chart_Chart.register(...registerables, chartjs_plugin_datalabels_esm_plugin);
        class CampaignTrialsChart {
            constructor(containerId, config) {
                this.containerId = containerId;
                this.config = config;
                this.container = document.querySelector(`[data-campaign-trials="${containerId}"]`);
                if (!this.container) {
                    console.error(`CampaignTrialsChart: container [data-campaign-trials="${containerId}"] not found.`);
                    return;
                }
                this.chart = null;
                this.tooltipEl = null;
                this._createChart();
            }
            _createChart() {
                const chartWrap = this.container.querySelector("[data-trials-chart]");
                if (!chartWrap) return;
                const canvas = document.createElement("canvas");
                chartWrap.appendChild(canvas);
                const ctx = canvas.getContext("2d");
                const campaigns = this.config.campaigns;
                const total = campaigns.reduce(((sum, c) => sum + c.trials), 0);
                const centerTextPlugin = {
                    id: `centerText_${this.containerId}`,
                    afterDraw: chart => {
                        const {ctx: c, chartArea} = chart;
                        if (!chartArea) return;
                        const cx = (chartArea.left + chartArea.right) / 2;
                        const cy = (chartArea.top + chartArea.bottom) / 2;
                        c.save();
                        c.textAlign = "center";
                        c.textBaseline = "middle";
                        c.font = "bold 28px Inter";
                        c.fillStyle = "#121926";
                        c.fillText(total, cx, cy - 10);
                        c.font = "13px Inter";
                        c.fillStyle = "#9AA4B2";
                        c.fillText("Триалов", cx, cy + 14);
                        c.restore();
                    }
                };
                this.chart = new chart_Chart(ctx, {
                    type: "doughnut",
                    data: {
                        labels: campaigns.map((c => c.name)),
                        datasets: [ {
                            data: campaigns.map((c => c.trials)),
                            backgroundColor: campaigns.map((c => c.color)),
                            borderWidth: 0,
                            hoverBorderWidth: 0,
                            hoverOffset: 4
                        } ]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: true,
                        cutout: "65%",
                        layout: {
                            padding: 6
                        },
                        plugins: {
                            legend: {
                                display: false
                            },
                            datalabels: {
                                display: false
                            },
                            tooltip: {
                                enabled: false,
                                external: context => this._renderTooltip(context)
                            }
                        },
                        animation: {
                            duration: 800,
                            easing: "easeOutCubic"
                        }
                    },
                    plugins: [ centerTextPlugin ]
                });
            }
            _renderTooltip(context) {
                const {tooltip} = context;
                const chartWrap = this.container.querySelector("[data-trials-chart]");
                if (!this.tooltipEl) {
                    this.tooltipEl = document.createElement("div");
                    this.tooltipEl.className = "absolute z-50 bg-white rounded-lg shadow-md pointer-events-none opacity-0 transition-opacity duration-150 min-w-40";
                    chartWrap.appendChild(this.tooltipEl);
                }
                if (tooltip.opacity === 0) {
                    this.tooltipEl.style.opacity = "0";
                    return;
                }
                const dataPoint = tooltip.dataPoints?.[0];
                if (!dataPoint) return;
                const idx = dataPoint.dataIndex;
                const campaign = this.config.campaigns[idx];
                if (!campaign) return;
                this.tooltipEl.innerHTML = `\n      <div class="bg-Gray-100 px-3 py-2 rounded-t-lg text-xs font-medium text-Gray-700">${campaign.name}</div>\n      <div class="flex items-center gap-2 px-3 py-2">\n        <span class="w-2 h-2 min-w-2 rounded-full" style="background-color: ${campaign.color};"></span>\n        <span class="text-sm font-semibold text-Gray-900">${campaign.trials} триалов</span>\n        <span class="text-sm text-Gray-600 ml-auto">${campaign.price}</span>\n      </div>\n    `;
                this.tooltipEl.style.opacity = "1";
                const tooltipRect = this.tooltipEl.getBoundingClientRect();
                const chartRect = chartWrap.getBoundingClientRect();
                let left = tooltip.caretX - tooltipRect.width / 2;
                let top = tooltip.caretY - tooltipRect.height - 12;
                left = Math.max(4, Math.min(left, chartRect.width - tooltipRect.width - 4));
                if (top < 4) top = tooltip.caretY + 12;
                this.tooltipEl.style.left = `${left}px`;
                this.tooltipEl.style.top = `${top}px`;
            }
            destroy() {
                if (this.chart) {
                    this.chart.destroy();
                    this.chart = null;
                }
                if (this.tooltipEl) {
                    this.tooltipEl.remove();
                    this.tooltipEl = null;
                }
            }
        }
        const campaignTrials = CampaignTrialsChart;
        const campaignTrialsConfigs = {
            "trials-income": {
                title: "Триалы по кампаниям",
                campaigns: [ {
                    name: "General - Low Popularity - USA",
                    color: "#3F83F8",
                    trials: 30,
                    trialsDiff: 21,
                    trialsPct: -1.07,
                    price: "$32",
                    priceDiff: "$9.74",
                    pricePct: -1.07
                }, {
                    name: "General - Mid Popularity - USA",
                    color: "#76A9FA",
                    trials: 19,
                    trialsDiff: 7,
                    trialsPct: -1.07,
                    price: "$53",
                    priceDiff: "$9.74",
                    pricePct: -1.07
                }, {
                    name: "Competitors",
                    color: "#16BDCA",
                    trials: 14,
                    trialsDiff: -12,
                    trialsPct: -1.07,
                    price: "$12",
                    priceDiff: "$9.74",
                    pricePct: -1.07
                }, {
                    name: "General - High Popularity - USA",
                    color: "#C3DDFD",
                    trials: 7,
                    trialsDiff: -3,
                    trialsPct: -1.07,
                    price: "$15",
                    priceDiff: "$9.74",
                    pricePct: -1.07
                }, {
                    name: "Test USA",
                    color: "#E1EFFE",
                    trials: 4,
                    trialsDiff: 8,
                    trialsPct: -1.07,
                    price: "$32",
                    priceDiff: "$9.74",
                    pricePct: -1.07
                } ]
            }
        };
        chart_Chart.register(...registerables, chartjs_plugin_datalabels_esm_plugin);
        chart_Chart.defaults.font.family = "Inter";
        document.addEventListener("DOMContentLoaded", (() => {
            Object.entries(campaignTrialsConfigs).forEach((([id, config]) => {
                const container = document.querySelector(`[data-campaign-trials="${id}"]`);
                if (container) new campaignTrials(id, config);
            }));
        }));
        window["FLS"] = true;
        addLoadedClass();
    })();
})();